<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>RFC 9113 - HTTP/2</title><script>
function getMeta(rfcno, container) {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://www.rfc-editor.org/rfc/rfc" + rfcno + ".json", true);
  xhr.onload = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var data = JSON.parse(xhr.response);
        
        var cont = document.getElementById(container);
        // empty the container
        while (cont.firstChild) {
          cont.removeChild(myNode.firstChild);
        }

        var c = data.status;
        if (c) {
          var bld = newElementWithText("b", c);
          cont.appendChild(bld);
        } else {
          cont.appendChild(newElementWithText("i", "(document status unknown)"));
        }

        c = data.updated_by;
        if (c && c.length > 0 && c[0] !== null && c[0].length > 0) {
          cont.appendChild(newElement("br"));
          cont.appendChild(newText("Updated by: "));
          appendRfcLinks(cont, c);
        }

        c = data.obsoleted_by;
        if (c && c.length > 0 && c[0] !== null && c[0].length > 0) {
          cont.appendChild(newElement("br"));
          cont.appendChild(newText("Obsoleted by: "));
          appendRfcLinks(cont, c);
        }

        c = data.errata_url;
        if (c) {
          cont.appendChild(newElement("br"));
          var link = newElementWithText("a", "errata");
          link.setAttribute("href", c);
          var errata = newElementWithText("i", "This document has ");
          errata.appendChild(link);
          errata.appendChild(newText("."));
          cont.appendChild(errata);
        }

        cont.style.display = "block";
      } else {
        console.error(xhr.statusText);
      }
    }
  };
  xhr.onerror = function (e) {
    console.error(xhr.status + " " + xhr.statusText);
  };
  xhr.send(null);
}
function appendRfcLinks(parent, updates) {
  var template = "https://www.rfc-editor.org/rfc/rfc{rfc}.html";
  for (var i = 0; i < updates.length; i++) {
    var rfc = updates[i].trim().toLowerCase();
    if (rfc.substring(0, 3) == "rfc") {
      var no = parseInt(rfc.substring(3), 10);
      
      var link = newElement("a");
      link.setAttribute("href", template.replace("{rfc}", no));
      link.appendChild(newText(no));
      parent.appendChild(link);
    } else {
      parent.appendChild(newText(rfc));
    }
    if (i != updates.length - 1) {
      parent.appendChild(newText(", "));
    }
  }
}

// DOM helpers
function newElement(name) {
  return document.createElement(name);
}
function newElementWithText(name, txt) {
  var e = document.createElement(name);
  e.appendChild(newText(txt));
  return e;
}
function newText(text) {
  return document.createTextNode(text);
}
</script><script>
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8).replace("-",".p.");
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9).replace("-",".p.");
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5).replace("-",".p.");
          } else {
            window.location.hash = prefix + "section." + postfix.replace("-",".p.");
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><meta property="og:type" content="article"><meta property="og:title" content="RFC9113"><meta property="og:description" content="HTTP/2"><meta property="og:url" content="https://httpwg.org/specs/rfc9113.html"><meta property="og:site_name" content="IETF HTTP Working Group Specifications"><meta property="og:image" content="https://httpwg.org/assets/favicon/apple-icon-180x180.png"><link rel="stylesheet" type="text/css" href="/assets/node_modules/bootstrap/dist/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #sidebar {
        margin-top: -10px;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      .toc ul {
        list-style: none;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="stylesheet" type="text/css" href="/assets/site.css"><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="License" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 HTTP/2 Protocol Overview" href="#rfc.section.2"><link rel="Chapter" title="3 Starting HTTP/2" href="#rfc.section.3"><link rel="Chapter" title="4 HTTP Frames" href="#rfc.section.4"><link rel="Chapter" title="5 Streams and Multiplexing" href="#rfc.section.5"><link rel="Chapter" title="6 Frame Definitions" href="#rfc.section.6"><link rel="Chapter" title="7 Error Codes" href="#rfc.section.7"><link rel="Chapter" title="8 Expressing HTTP Semantics in HTTP/2" href="#rfc.section.8"><link rel="Chapter" title="9 HTTP/2 Connections" href="#rfc.section.9"><link rel="Chapter" title="10 Security Considerations" href="#rfc.section.10"><link rel="Chapter" title="11 IANA Considerations" href="#rfc.section.11"><link rel="Chapter" title="12 References" href="#rfc.section.12"><link rel="Appendix" title="A Prohibited TLS 1.2 Cipher Suites" href="#rfc.section.A"><link rel="Appendix" title="B Changes from RFC 7540" href="#rfc.section.B"><link rel="Appendix" title="Acknowledgments" href="#rfc.section.unnumbered-4"><link rel="Appendix" title="Contributors" href="#rfc.section.unnumbered-5"><link href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2bis-latest" rel="prev"><link href="https://dx.doi.org/10.17487/rfc9113" rel="alternate"><link href="urn:issn:2070-1721" rel="alternate"><link rel="Alternate" title="Plain Text Version" href="http://www.ietf.org/rfc/rfc9113.txt"><link rel="Help" title="RFC-Editor's Status Page" href="https://www.rfc-editor.org/info/rfc9113"><meta name="viewport" content="initial-scale=1"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="HTTP, SPDY, Web"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Thomson, M."><meta name="dcterms.creator" content="Benfield, C."><meta name="dcterms.identifier" content="urn:ietf:rfc:9113"><meta name="dcterms.issued" content="2022-06"><meta name="dct.replaces" content="urn:ietf:rfc:7540"><meta name="dct.replaces" content="urn:ietf:rfc:8740"><meta name="dcterms.abstract" content="This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.This document obsoletes RFCs 7540 and 8740."><meta name="dcterms.isPartOf" content="urn:issn:2070-1721"><meta name="description" content="This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.This document obsoletes RFCs 7540 and 8740."></head><body onload="getMeta(9113,&#34;rfc.meta&#34;);"><nav class="navbar navbar-dark bg-dark navbar-expand-lg fixed-top ps-3 pe-3" role="navigation">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapse" aria-controls="navbarToggler" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    
    <a class="navbar-brand" href="https://httpwg.org/"><img src="https://httpwg.org/assets/http.svg" height="23"></a>
  </div>
  
  <div class="collapse navbar-collapse" id="navbar-collapse">
      
    <div class="navbar-nav me-auto">

      <a class="nav-item ms-1 text-white" href="https://httpwg.org/specs/">ðŸ“„ Documentation</a>

      <div class="dropdown ms-4">
        <a href="#" class="nav-item dropdown-toggle text-white" data-bs-toggle="dropdown">Work in Progress</a>
          <ul class="dropdown-menu"><li class="dropdown-item"><a href="https://httpwg.org/http-extensions/">HTTP Extensions</a></li><li class="dropdown-item"><a href="https://github.com/httpwg/admin/issues?q=is%3Aissue+is%3Aopen+label%3Aadoption">Future Work</a></li></ul>
      </div>

      <div class="dropdown ms-4">
        <a href="#" class="nav-item dropdown-toggle text-white" data-bs-toggle="dropdown">Participate</a>
          <ul class="dropdown-menu"><li class="dropdown-item"><a href="https://httpwg.org/about/">About the HTTP Working Group</a></li><li class="divider"></li><li class="dropdown-item"><a href="https://httpwg.org/CONTRIBUTING.html">Contribution Policy</a></li><li class="dropdown-item"><a href="http://datatracker.ietf.org/wg/httpbis/charter/">WG Charter</a></li><li class="dropdown-item"><a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">Group Mailing List ðŸ“¨</a></li><li class="dropdown-item"><a href="https://httpwg.org/wg-materials/">Meeting Materials</a></li><li class="dropdown-item"><a href="https://httpwg.org/admin/editors/">Document Editor Resources</a></li></ul>
      </div>
    </div>
            
    <div class="nav navbar-nav ms-auto">
      <a class="navbar" href="https://twitter.com/http_wg">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon  twtr-color-fill--blue-dark  has-hover"><path opacity="0" d="M0 0h24v24H0z"/><path d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572 0-4.658 2.086-4.658 4.66 0 .364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342 0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3 0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376 0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57 0 13.255-7.098 13.255-13.254 0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg>
      </a>
    </div>
  </div>
</nav><div class="container" id="top"><div class="row"><div class="col-lg-4 order-last d-none d-lg-block" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top"><strong>RFC </strong>9113</a></div><br clear="all"><div class=""><div class="toc "><ul><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#Overview">HTTP/2 Protocol Overview</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.1">Document Organization</a></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.2">Conventions and Terminology</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#starting">Starting HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#versioning">HTTP/2 Version Identification</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#discover-https">Starting HTTP/2 for "<span class="tt">https</span>" URIs</a></li><li><a href="#rfc.section.3.3">3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#known-http">Starting HTTP/2 with Prior Knowledge</a></li><li><a href="#rfc.section.3.4">3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#preface">HTTP/2 Connection Preface</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#FramingLayer">HTTP Frames</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameHeader">Frame Format</a></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameSize">Frame Size</a></li><li><a href="#rfc.section.4.3">4.3.</a>&nbsp;&nbsp;&nbsp;<a href="#FieldBlock">Field Section Compression and Decompression</a><ul><li><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#dynamic-table">Compression State</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamsLayer">Streams and Multiplexing</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamStates">Stream States</a><ul><li><a href="#rfc.section.5.1.1">5.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamIdentifiers">Stream Identifiers</a></li><li><a href="#rfc.section.5.1.2">5.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.1.2">Stream Concurrency</a></li></ul></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#FlowControl">Flow Control</a><ul><li><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#fc-principles">Flow-Control Principles</a></li><li><a href="#rfc.section.5.2.2">5.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#DisableFlowControl">Appropriate Use of Flow Control</a></li><li><a href="#rfc.section.5.2.3">5.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#FlowControlPerformance">Flow-Control Performance</a></li></ul></li><li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamPriority">Prioritization</a><ul><li><a href="#rfc.section.5.3.1">5.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#PriorityHistory">Background on Priority in RFC 7540</a></li><li><a href="#rfc.section.5.3.2">5.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#PriorityHere">Priority Signaling in This Document</a></li></ul></li><li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorHandler">Error Handling</a><ul><li><a href="#rfc.section.5.4.1">5.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionErrorHandler">Connection Error Handling</a></li><li><a href="#rfc.section.5.4.2">5.4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></li><li><a href="#rfc.section.5.4.3">5.4.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4.3">Connection Termination</a></li></ul></li><li><a href="#rfc.section.5.5">5.5.</a>&nbsp;&nbsp;&nbsp;<a href="#extensibility">Extending HTTP/2</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameTypes">Frame Definitions</a><ul><li><a href="#rfc.section.6.1">6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#DATA">DATA</a></li><li><a href="#rfc.section.6.2">6.2.</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS">HEADERS</a></li><li><a href="#rfc.section.6.3">6.3.</a>&nbsp;&nbsp;&nbsp;<a href="#PRIORITY">PRIORITY</a></li><li><a href="#rfc.section.6.4">6.4.</a>&nbsp;&nbsp;&nbsp;<a href="#RST_STREAM">RST_STREAM</a></li><li><a href="#rfc.section.6.5">6.5.</a>&nbsp;&nbsp;&nbsp;<a href="#SETTINGS">SETTINGS</a><ul><li><a href="#rfc.section.6.5.1">6.5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#SettingFormat">SETTINGS Format</a></li><li><a href="#rfc.section.6.5.2">6.5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#SettingValues">Defined Settings</a></li><li><a href="#rfc.section.6.5.3">6.5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#SettingsSync">Settings Synchronization</a></li></ul></li><li><a href="#rfc.section.6.6">6.6.</a>&nbsp;&nbsp;&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></li><li><a href="#rfc.section.6.7">6.7.</a>&nbsp;&nbsp;&nbsp;<a href="#PING">PING</a></li><li><a href="#rfc.section.6.8">6.8.</a>&nbsp;&nbsp;&nbsp;<a href="#GOAWAY">GOAWAY</a></li><li><a href="#rfc.section.6.9">6.9.</a>&nbsp;&nbsp;&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a><ul><li><a href="#rfc.section.6.9.1">6.9.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.9.1">The Flow-Control Window</a></li><li><a href="#rfc.section.6.9.2">6.9.2.</a>&nbsp;&nbsp;&nbsp;<a href="#InitialWindowSize">Initial Flow-Control Window Size</a></li><li><a href="#rfc.section.6.9.3">6.9.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.9.3">Reducing the Stream Window Size</a></li></ul></li><li><a href="#rfc.section.6.10">6.10.</a>&nbsp;&nbsp;&nbsp;<a href="#CONTINUATION">CONTINUATION</a></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorCodes">Error Codes</a></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpLayer">Expressing HTTP Semantics in HTTP/2</a><ul><li><a href="#rfc.section.8.1">8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpFraming">HTTP Message Framing</a><ul><li><a href="#rfc.section.8.1.1">8.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#malformed">Malformed Messages</a></li></ul></li><li><a href="#rfc.section.8.2">8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpHeaders">HTTP Fields</a><ul><li><a href="#rfc.section.8.2.1">8.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.2.1">Field Validity</a></li><li><a href="#rfc.section.8.2.2">8.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionSpecific">Connection-Specific Header Fields</a></li><li><a href="#rfc.section.8.2.3">8.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#CompressCookie">Compressing the Cookie Header Field</a></li></ul></li><li><a href="#rfc.section.8.3">8.3.</a>&nbsp;&nbsp;&nbsp;<a href="#PseudoHeaderFields">HTTP Control Data</a><ul><li><a href="#rfc.section.8.3.1">8.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpRequest">Request Pseudo-Header Fields</a></li><li><a href="#rfc.section.8.3.2">8.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpResponse">Response Pseudo-Header Fields</a></li></ul></li><li><a href="#rfc.section.8.4">8.4.</a>&nbsp;&nbsp;&nbsp;<a href="#PushResources">Server Push</a><ul><li><a href="#rfc.section.8.4.1">8.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#PushRequests">Push Requests</a></li><li><a href="#rfc.section.8.4.2">8.4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#PushResponses">Push Responses</a></li></ul></li><li><a href="#rfc.section.8.5">8.5.</a>&nbsp;&nbsp;&nbsp;<a href="#CONNECT">The CONNECT Method</a></li><li><a href="#rfc.section.8.6">8.6.</a>&nbsp;&nbsp;&nbsp;<a href="#informational-responses">The Upgrade Header Field</a></li><li><a href="#rfc.section.8.7">8.7.</a>&nbsp;&nbsp;&nbsp;<a href="#Reliability">Request Reliability</a></li><li><a href="#rfc.section.8.8">8.8.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExamples">Examples</a><ul><li><a href="#rfc.section.8.8.1">8.8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.1">Simple Request</a></li><li><a href="#rfc.section.8.8.2">8.8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.2">Simple Response</a></li><li><a href="#rfc.section.8.8.3">8.8.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.3">Complex Request</a></li><li><a href="#rfc.section.8.8.4">8.8.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.4">Response with Body</a></li><li><a href="#rfc.section.8.8.5">8.8.5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.5">Informational Responses</a></li></ul></li></ul></li><li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExtra">HTTP/2 Connections</a><ul><li><a href="#rfc.section.9.1">9.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.1">Connection Management</a><ul><li><a href="#rfc.section.9.1.1">9.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#reuse">Connection Reuse</a></li></ul></li><li><a href="#rfc.section.9.2">9.2.</a>&nbsp;&nbsp;&nbsp;<a href="#TLSUsage">Use of TLS Features</a><ul><li><a href="#rfc.section.9.2.1">9.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#tls12features">TLS 1.2 Features</a></li><li><a href="#rfc.section.9.2.2">9.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#tls12ciphers">TLS 1.2 Cipher Suites</a></li><li><a href="#rfc.section.9.2.3">9.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#tls13features">TLS 1.3 Features</a></li></ul></li></ul></li><li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#security">Security Considerations</a><ul><li><a href="#rfc.section.10.1">10.1.</a>&nbsp;&nbsp;&nbsp;<a href="#authority">Server Authority</a></li><li><a href="#rfc.section.10.2">10.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.2">Cross-Protocol Attacks</a></li><li><a href="#rfc.section.10.3">10.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.3">Intermediary Encapsulation Attacks</a></li><li><a href="#rfc.section.10.4">10.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.4">Cacheability of Pushed Responses</a></li><li><a href="#rfc.section.10.5">10.5.</a>&nbsp;&nbsp;&nbsp;<a href="#dos">Denial-of-Service Considerations</a><ul><li><a href="#rfc.section.10.5.1">10.5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#MaxFieldBlock">Limits on Field Block Size</a></li><li><a href="#rfc.section.10.5.2">10.5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#connectDos">CONNECT Issues</a></li></ul></li><li><a href="#rfc.section.10.6">10.6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.6">Use of Compression</a></li><li><a href="#rfc.section.10.7">10.7.</a>&nbsp;&nbsp;&nbsp;<a href="#padding">Use of Padding</a></li><li><a href="#rfc.section.10.8">10.8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.8">Privacy Considerations</a></li><li><a href="#rfc.section.10.9">10.9.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.9">Remote Timing Attacks</a></li></ul></li><li><a href="#rfc.section.11">11.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a><ul><li><a href="#rfc.section.11.1">11.1.</a>&nbsp;&nbsp;&nbsp;<a href="#HTTP2-Settings">HTTP2-Settings Header Field Registration</a></li><li><a href="#rfc.section.11.2">11.2.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-h2c">The h2c Upgrade Token</a></li></ul></li><li><a href="#rfc.section.12">12.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.12.1">12.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Normative References</a></li><li><a href="#rfc.section.12.2">12.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.3">Informative References</a></li></ul></li><li><a href="#rfc.section.A">Appendix A.</a>&nbsp;&nbsp;&nbsp;<a href="#BadCipherSuites">Prohibited TLS 1.2 Cipher Suites</a></li><li><a href="#rfc.section.B">Appendix B.</a>&nbsp;&nbsp;&nbsp;<a href="#revision-updates">Changes from RFC 7540</a></li><li><a href="#rfc.section.unnumbered-4">Acknowledgments</a></li><li><a href="#rfc.section.unnumbered-5">Contributors</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-lg-8 order-first main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Internet Engineering Task Force (IETF)</td><td class="text-right">M. Thomson, Editor</td></tr><tr><td class="text-left">Request for Comments: 9113</td><td class="text-right">Mozilla</td></tr><tr><td class="text-left">Obsoletes: <a href="#RFC7540">7540</a>, <a href="#RFC8740">8740</a></td><td class="text-right">C. Benfield, Editor</td></tr><tr><td class="text-left">Category: Standards Track</td><td class="text-right">Apple Inc.</td></tr><tr><td class="text-left">ISSN: 2070-1721</td><td class="text-right">June 2022</td></tr></tbody></table><div id="rfc.title"><h1>HTTP/2</h1></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.</p></div><div id="rfc.abstract.p.2"><p>This document obsoletes RFCs 7540 and 8740.</p></div></div><aside id="rfc.meta" class="alert alert-info"></aside><section id="rfc.status"><h2><a href="#rfc.status">Status of This Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This is an Internet Standards Track document.</p></div><div id="rfc.boilerplate.1.p.2"><p>This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in <a href="https://www.rfc-editor.org/rfc/rfc7841.html#section-2">Section 2 of RFC 7841</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at <a href="https://www.rfc-editor.org/info/rfc9113">https://www.rfc-editor.org/info/rfc9113</a>.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.</p></div></section><div class="toc d-lg-none"><ul><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#Overview">HTTP/2 Protocol Overview</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.1">Document Organization</a></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.2">Conventions and Terminology</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#starting">Starting HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#versioning">HTTP/2 Version Identification</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#discover-https">Starting HTTP/2 for "<span class="tt">https</span>" URIs</a></li><li><a href="#rfc.section.3.3">3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#known-http">Starting HTTP/2 with Prior Knowledge</a></li><li><a href="#rfc.section.3.4">3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#preface">HTTP/2 Connection Preface</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#FramingLayer">HTTP Frames</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameHeader">Frame Format</a></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameSize">Frame Size</a></li><li><a href="#rfc.section.4.3">4.3.</a>&nbsp;&nbsp;&nbsp;<a href="#FieldBlock">Field Section Compression and Decompression</a><ul><li><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#dynamic-table">Compression State</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamsLayer">Streams and Multiplexing</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamStates">Stream States</a><ul><li><a href="#rfc.section.5.1.1">5.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamIdentifiers">Stream Identifiers</a></li><li><a href="#rfc.section.5.1.2">5.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.1.2">Stream Concurrency</a></li></ul></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#FlowControl">Flow Control</a><ul><li><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#fc-principles">Flow-Control Principles</a></li><li><a href="#rfc.section.5.2.2">5.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#DisableFlowControl">Appropriate Use of Flow Control</a></li><li><a href="#rfc.section.5.2.3">5.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#FlowControlPerformance">Flow-Control Performance</a></li></ul></li><li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamPriority">Prioritization</a><ul><li><a href="#rfc.section.5.3.1">5.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#PriorityHistory">Background on Priority in RFC 7540</a></li><li><a href="#rfc.section.5.3.2">5.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#PriorityHere">Priority Signaling in This Document</a></li></ul></li><li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorHandler">Error Handling</a><ul><li><a href="#rfc.section.5.4.1">5.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionErrorHandler">Connection Error Handling</a></li><li><a href="#rfc.section.5.4.2">5.4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></li><li><a href="#rfc.section.5.4.3">5.4.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4.3">Connection Termination</a></li></ul></li><li><a href="#rfc.section.5.5">5.5.</a>&nbsp;&nbsp;&nbsp;<a href="#extensibility">Extending HTTP/2</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameTypes">Frame Definitions</a><ul><li><a href="#rfc.section.6.1">6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#DATA">DATA</a></li><li><a href="#rfc.section.6.2">6.2.</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS">HEADERS</a></li><li><a href="#rfc.section.6.3">6.3.</a>&nbsp;&nbsp;&nbsp;<a href="#PRIORITY">PRIORITY</a></li><li><a href="#rfc.section.6.4">6.4.</a>&nbsp;&nbsp;&nbsp;<a href="#RST_STREAM">RST_STREAM</a></li><li><a href="#rfc.section.6.5">6.5.</a>&nbsp;&nbsp;&nbsp;<a href="#SETTINGS">SETTINGS</a><ul><li><a href="#rfc.section.6.5.1">6.5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#SettingFormat">SETTINGS Format</a></li><li><a href="#rfc.section.6.5.2">6.5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#SettingValues">Defined Settings</a></li><li><a href="#rfc.section.6.5.3">6.5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#SettingsSync">Settings Synchronization</a></li></ul></li><li><a href="#rfc.section.6.6">6.6.</a>&nbsp;&nbsp;&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></li><li><a href="#rfc.section.6.7">6.7.</a>&nbsp;&nbsp;&nbsp;<a href="#PING">PING</a></li><li><a href="#rfc.section.6.8">6.8.</a>&nbsp;&nbsp;&nbsp;<a href="#GOAWAY">GOAWAY</a></li><li><a href="#rfc.section.6.9">6.9.</a>&nbsp;&nbsp;&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a><ul><li><a href="#rfc.section.6.9.1">6.9.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.9.1">The Flow-Control Window</a></li><li><a href="#rfc.section.6.9.2">6.9.2.</a>&nbsp;&nbsp;&nbsp;<a href="#InitialWindowSize">Initial Flow-Control Window Size</a></li><li><a href="#rfc.section.6.9.3">6.9.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.9.3">Reducing the Stream Window Size</a></li></ul></li><li><a href="#rfc.section.6.10">6.10.</a>&nbsp;&nbsp;&nbsp;<a href="#CONTINUATION">CONTINUATION</a></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorCodes">Error Codes</a></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpLayer">Expressing HTTP Semantics in HTTP/2</a><ul><li><a href="#rfc.section.8.1">8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpFraming">HTTP Message Framing</a><ul><li><a href="#rfc.section.8.1.1">8.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#malformed">Malformed Messages</a></li></ul></li><li><a href="#rfc.section.8.2">8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpHeaders">HTTP Fields</a><ul><li><a href="#rfc.section.8.2.1">8.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.2.1">Field Validity</a></li><li><a href="#rfc.section.8.2.2">8.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionSpecific">Connection-Specific Header Fields</a></li><li><a href="#rfc.section.8.2.3">8.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#CompressCookie">Compressing the Cookie Header Field</a></li></ul></li><li><a href="#rfc.section.8.3">8.3.</a>&nbsp;&nbsp;&nbsp;<a href="#PseudoHeaderFields">HTTP Control Data</a><ul><li><a href="#rfc.section.8.3.1">8.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpRequest">Request Pseudo-Header Fields</a></li><li><a href="#rfc.section.8.3.2">8.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpResponse">Response Pseudo-Header Fields</a></li></ul></li><li><a href="#rfc.section.8.4">8.4.</a>&nbsp;&nbsp;&nbsp;<a href="#PushResources">Server Push</a><ul><li><a href="#rfc.section.8.4.1">8.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#PushRequests">Push Requests</a></li><li><a href="#rfc.section.8.4.2">8.4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#PushResponses">Push Responses</a></li></ul></li><li><a href="#rfc.section.8.5">8.5.</a>&nbsp;&nbsp;&nbsp;<a href="#CONNECT">The CONNECT Method</a></li><li><a href="#rfc.section.8.6">8.6.</a>&nbsp;&nbsp;&nbsp;<a href="#informational-responses">The Upgrade Header Field</a></li><li><a href="#rfc.section.8.7">8.7.</a>&nbsp;&nbsp;&nbsp;<a href="#Reliability">Request Reliability</a></li><li><a href="#rfc.section.8.8">8.8.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExamples">Examples</a><ul><li><a href="#rfc.section.8.8.1">8.8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.1">Simple Request</a></li><li><a href="#rfc.section.8.8.2">8.8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.2">Simple Response</a></li><li><a href="#rfc.section.8.8.3">8.8.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.3">Complex Request</a></li><li><a href="#rfc.section.8.8.4">8.8.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.4">Response with Body</a></li><li><a href="#rfc.section.8.8.5">8.8.5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.8.5">Informational Responses</a></li></ul></li></ul></li><li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExtra">HTTP/2 Connections</a><ul><li><a href="#rfc.section.9.1">9.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.1">Connection Management</a><ul><li><a href="#rfc.section.9.1.1">9.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#reuse">Connection Reuse</a></li></ul></li><li><a href="#rfc.section.9.2">9.2.</a>&nbsp;&nbsp;&nbsp;<a href="#TLSUsage">Use of TLS Features</a><ul><li><a href="#rfc.section.9.2.1">9.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#tls12features">TLS 1.2 Features</a></li><li><a href="#rfc.section.9.2.2">9.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#tls12ciphers">TLS 1.2 Cipher Suites</a></li><li><a href="#rfc.section.9.2.3">9.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#tls13features">TLS 1.3 Features</a></li></ul></li></ul></li><li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#security">Security Considerations</a><ul><li><a href="#rfc.section.10.1">10.1.</a>&nbsp;&nbsp;&nbsp;<a href="#authority">Server Authority</a></li><li><a href="#rfc.section.10.2">10.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.2">Cross-Protocol Attacks</a></li><li><a href="#rfc.section.10.3">10.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.3">Intermediary Encapsulation Attacks</a></li><li><a href="#rfc.section.10.4">10.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.4">Cacheability of Pushed Responses</a></li><li><a href="#rfc.section.10.5">10.5.</a>&nbsp;&nbsp;&nbsp;<a href="#dos">Denial-of-Service Considerations</a><ul><li><a href="#rfc.section.10.5.1">10.5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#MaxFieldBlock">Limits on Field Block Size</a></li><li><a href="#rfc.section.10.5.2">10.5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#connectDos">CONNECT Issues</a></li></ul></li><li><a href="#rfc.section.10.6">10.6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.6">Use of Compression</a></li><li><a href="#rfc.section.10.7">10.7.</a>&nbsp;&nbsp;&nbsp;<a href="#padding">Use of Padding</a></li><li><a href="#rfc.section.10.8">10.8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.8">Privacy Considerations</a></li><li><a href="#rfc.section.10.9">10.9.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.9">Remote Timing Attacks</a></li></ul></li><li><a href="#rfc.section.11">11.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a><ul><li><a href="#rfc.section.11.1">11.1.</a>&nbsp;&nbsp;&nbsp;<a href="#HTTP2-Settings">HTTP2-Settings Header Field Registration</a></li><li><a href="#rfc.section.11.2">11.2.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-h2c">The h2c Upgrade Token</a></li></ul></li><li><a href="#rfc.section.12">12.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.12.1">12.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Normative References</a></li><li><a href="#rfc.section.12.2">12.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.3">Informative References</a></li></ul></li><li><a href="#rfc.section.A">Appendix A.</a>&nbsp;&nbsp;&nbsp;<a href="#BadCipherSuites">Prohibited TLS 1.2 Cipher Suites</a></li><li><a href="#rfc.section.B">Appendix B.</a>&nbsp;&nbsp;&nbsp;<a href="#revision-updates">Changes from RFC 7540</a></li><li><a href="#rfc.section.unnumbered-4">Acknowledgments</a></li><li><a href="#rfc.section.unnumbered-5">Contributors</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div><hr class="hidden-print"><section id="intro"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#intro">Introduction</a></h2><div id="rfc.section.1.p.1"><p>The performance of applications using the Hypertext Transfer Protocol (HTTP, <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>) is linked to how each version of HTTP uses the underlying transport, and the conditions under which the transport operates.</p></div><div id="rfc.section.1.p.2"><p>Making multiple concurrent requests can reduce latency and improve application performance. HTTP/1.0 allowed only one request to be outstanding at a time on a given TCP <a href="#RFC0793"><cite title="Transmission Control Protocol">[TCP]</cite></a> connection. HTTP/1.1 <a href="#RFC9112"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a> added request pipelining, but this only partially addressed request concurrency and still suffers from application-layer head-of-line blocking. Therefore, HTTP/1.0 and HTTP/1.1 clients use multiple connections to a server to make concurrent requests.</p></div><div id="rfc.section.1.p.3"><p>Furthermore, HTTP fields are often repetitive and verbose, causing unnecessary network traffic as well as causing the initial TCP congestion window to quickly fill. This can result in excessive latency when multiple requests are made on a new TCP connection.</p></div><div id="rfc.section.1.p.4"><p>HTTP/2 addresses these issues by defining an optimized mapping of HTTP's semantics to an underlying connection. Specifically, it allows interleaving of messages on the same connection and uses an efficient coding for HTTP fields. It also allows prioritization of requests, letting more important requests complete more quickly, further improving performance.</p></div><div id="rfc.section.1.p.5"><p>The resulting protocol is more friendly to the network because fewer TCP connections can be used in comparison to HTTP/1.x. This means less competition with other flows and longer-lived connections, which in turn lead to better utilization of available network capacity. Note, however, that TCP head-of-line blocking is not addressed by this protocol.</p></div><div id="rfc.section.1.p.6"><p>Finally, HTTP/2 also enables more efficient processing of messages through use of binary message framing.</p></div><div id="rfc.section.1.p.7"><p>This document obsoletes RFCs 7540 and 8740. <a href="#revision-updates" title="Changes from RFC 7540">Appendix B</a> lists notable changes.</p></div></section><hr class="hidden-print"><section id="Overview"><h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#Overview">HTTP/2 Protocol Overview</a></h2><div id="rfc.section.2.p.1"><p>HTTP/2 provides an optimized transport for HTTP semantics. HTTP/2 supports all of the core features of HTTP but aims to be more efficient than HTTP/1.1.</p></div><div id="rfc.section.2.p.2"><p>HTTP/2 is a connection-oriented application-layer protocol that runs over a TCP connection (<a href="#RFC0793"><cite title="Transmission Control Protocol">[TCP]</cite></a>). The client is the TCP connection initiator.</p></div><div id="rfc.section.2.p.3"><p>The basic protocol unit in HTTP/2 is a frame (<a href="#FrameHeader" title="Frame Format">Section 4.1</a>). Each frame type serves a different purpose. For example, <a href="#HEADERS" title="HEADERS">HEADERS</a> and <a href="#DATA" title="DATA">DATA</a> frames form the basis of HTTP requests and responses (<a href="#HttpFraming" title="HTTP Message Framing">Section 8.1</a>); other frame types like <a href="#SETTINGS" title="SETTINGS">SETTINGS</a>, <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>, and <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> are used in support of other HTTP/2 features.</p></div><div id="rfc.section.2.p.4"><p>Multiplexing of requests is achieved by having each HTTP request/response exchange associated with its own stream (<a href="#StreamsLayer" title="Streams and Multiplexing">Section 5</a>). Streams are largely independent of each other, so a blocked or stalled request or response does not prevent progress on other streams.</p></div><div id="rfc.section.2.p.5"><p>Effective use of multiplexing depends on flow control and prioritization. Flow control (<a href="#FlowControl" title="Flow Control">Section 5.2</a>) ensures that it is possible to efficiently use multiplexed streams by restricting data that is transmitted to what the receiver is able to handle. Prioritization (<a href="#StreamPriority" title="Prioritization">Section 5.3</a>) ensures that limited resources are used most effectively. This revision of HTTP/2 deprecates the priority signaling scheme from <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>.</p></div><div id="rfc.section.2.p.6"><p>Because HTTP fields used in a connection can contain large amounts of redundant data, frames that contain them are compressed (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>). This has especially advantageous impact upon request sizes in the common case, allowing many requests to be compressed into one packet.</p></div><div id="rfc.section.2.p.7"><p>Finally, HTTP/2 adds a new, optional interaction mode whereby a server can push responses to a client (<a href="#PushResources" title="Server Push">Section 8.4</a>). This is intended to allow a server to speculatively send data to a client that the server anticipates the client will need, trading off some network usage against a potential latency gain. The server does this by synthesizing a request, which it sends as a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame. The server is then able to send a response to the synthetic request on a separate stream.</p></div><section id="n-document-organization"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#n-document-organization">Document Organization</a></h3><div id="rfc.section.2.1.p.1" class="avoidbreakafter"><p>The HTTP/2 specification is split into four parts:</p></div><div id="rfc.section.2.1.p.2"><ul><li>Starting HTTP/2 (<a href="#starting" title="Starting HTTP/2">Section 3</a>) covers how an HTTP/2 connection is initiated.</li><li>The frame (<a href="#FramingLayer" title="HTTP Frames">Section 4</a>) and stream (<a href="#StreamsLayer" title="Streams and Multiplexing">Section 5</a>) layers describe the way HTTP/2 frames are structured and formed into multiplexed streams.</li><li>Frame (<a href="#FrameTypes" title="Frame Definitions">Section 6</a>) and error (<a href="#ErrorCodes" title="Error Codes">Section 7</a>) definitions include details of the frame and error types used in HTTP/2.</li><li>HTTP mappings (<a href="#HttpLayer" title="Expressing HTTP Semantics in HTTP/2">Section 8</a>) and additional requirements (<a href="#HttpExtra" title="HTTP/2 Connections">Section 9</a>) describe how HTTP semantics are expressed using frames and streams.</li></ul></div><div id="rfc.section.2.1.p.3"><p>While some of the frame- and stream-layer concepts are isolated from HTTP, this specification does not define a completely generic frame layer. The frame and stream layers are tailored to the needs of HTTP.</p></div></section><section id="n-conventions-and-terminology"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#n-conventions-and-terminology">Conventions and Terminology</a></h3><div id="rfc.section.2.2.p.1"><p>The key words "<em class="bcp14">MUST</em>", "<em class="bcp14">MUST NOT</em>", "<em class="bcp14">REQUIRED</em>", "<em class="bcp14">SHALL</em>", "<em class="bcp14">SHALL NOT</em>", "<em class="bcp14">SHOULD</em>", "<em class="bcp14">SHOULD NOT</em>", "<em class="bcp14">RECOMMENDED</em>", "<em class="bcp14">NOT RECOMMENDED</em>", "<em class="bcp14">MAY</em>", and "<em class="bcp14">OPTIONAL</em>" in this document are to be interpreted as described in BCP&nbsp;14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div><div id="rfc.section.2.2.p.2"><p>All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided in decimal or hexadecimal as appropriate. Hexadecimal literals are prefixed with "<span class="tt">0x</span>" to distinguish them from decimal literals.</p></div><div id="rfc.section.2.2.p.3"><p>This specification describes binary formats using the conventions described in <a href="https://www.rfc-editor.org/rfc/rfc9000.html#section-1.3">Section 1.3</a> of <a href="#RFC9000"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">RFC 9000</cite></a> <cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[QUIC]</cite>. Note that this format uses network byte order and that high-valued bits are listed before low-valued bits.</p></div><div id="rfc.section.2.2.p.4" class="avoidbreakafter"><p>The following terms are used:</p></div><div id="rfc.section.2.2.p.5"><dl><dt>client:</dt><dd style="margin-left: 1.5em">The endpoint that initiates an HTTP/2 connection. Clients send HTTP requests and receive HTTP responses.</dd><dt>connection:</dt><dd style="margin-left: 1.5em">A transport-layer connection between two endpoints.</dd><dt>connection error:</dt><dd style="margin-left: 1.5em">An error that affects the entire HTTP/2 connection.</dd><dt>endpoint:</dt><dd style="margin-left: 1.5em">Either the client or server of the connection.</dd><dt>frame:</dt><dd style="margin-left: 1.5em">The smallest unit of communication within an HTTP/2 connection, consisting of a header and a variable-length sequence of octets structured according to the frame type.</dd><dt>peer:</dt><dd style="margin-left: 1.5em">An endpoint. When discussing a particular endpoint, "peer" refers to the endpoint that is remote to the primary subject of discussion.</dd><dt>receiver:</dt><dd style="margin-left: 1.5em">An endpoint that is receiving frames.</dd><dt>sender:</dt><dd style="margin-left: 1.5em">An endpoint that is transmitting frames.</dd><dt>server:</dt><dd style="margin-left: 1.5em">The endpoint that accepts an HTTP/2 connection. Servers receive HTTP requests and send HTTP responses.</dd><dt>stream:</dt><dd style="margin-left: 1.5em">A bidirectional flow of frames within the HTTP/2 connection.</dd><dt>stream error:</dt><dd style="margin-left: 1.5em">An error on the individual HTTP/2 stream.</dd></dl></div><div id="rfc.section.2.2.p.6"><p>Finally, the terms "gateway", "intermediary", "proxy", and "tunnel" are defined in <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-3.7">Section 3.7</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>. Intermediaries act as both client and server at different times.</p></div><div id="rfc.section.2.2.p.7"><p>The term "content" as it applies to message bodies is defined in <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.4">Section 6.4</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>.</p></div></section></section><hr class="hidden-print"><section id="starting"><h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#starting">Starting HTTP/2</a></h2><div id="rfc.section.3.p.1"><p>Implementations that generate HTTP requests need to discover whether a server supports HTTP/2.</p></div><div id="rfc.section.3.p.2"><p>HTTP/2 uses the "<span class="tt">http</span>" and "<span class="tt">https</span>" URI schemes defined in <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-4.2">Section 4.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>, with the same default port numbers as HTTP/1.1 <a href="#RFC9112"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>. These URIs do not include any indication about what HTTP versions an upstream server (the immediate peer to which the client wishes to establish a connection) supports.</p></div><div id="rfc.section.3.p.3"><p>The means by which support for HTTP/2 is determined is different for "<span class="tt">http</span>" and "<span class="tt">https</span>" URIs. Discovery for "<span class="tt">https</span>" URIs is described in <a href="#discover-https" title="Starting HTTP/2 for &#34;https&#34; URIs">Section 3.2</a>. HTTP/2 support for "<span class="tt">http</span>" URIs can only be discovered by out-of-band means and requires prior knowledge of the support as described in <a href="#known-http" title="Starting HTTP/2 with Prior Knowledge">Section 3.3</a>.</p></div><section id="versioning"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#versioning">HTTP/2 Version Identification</a></h3><div id="rfc.section.3.1.p.1"><p>The protocol defined in this document has two identifiers. Creating a connection based on either implies the use of the transport, framing, and message semantics described in this document.</p></div><div id="rfc.section.3.1.p.2"><ul><li><div><p>The string "h2" identifies the protocol where HTTP/2 uses Transport Layer Security (TLS); see <a href="#TLSUsage" title="Use of TLS Features">Section 9.2</a>. This identifier is used in the <a href="#RFC7301"><cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">TLS Application-Layer Protocol Negotiation (ALPN) extension</cite></a> <cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite> field and in any place where HTTP/2 over TLS is identified.</p></div> <div><p>The "h2" string is serialized into an ALPN protocol identifier as the two-octet sequence: 0x68, 0x32.</p></div> </li><li><div><p>The "h2c" string was previously used as a token for use in the HTTP Upgrade mechanism's Upgrade header field (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.8">Section 7.8</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). This usage was never widely deployed and is deprecated by this document. The same applies to the HTTP2-Settings header field, which was used with the upgrade to "h2c".</p></div> </li></ul></div></section><section id="discover-https"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a href="#discover-https">Starting HTTP/2 for "<span class="tt">https</span>" URIs</a></h3><div id="rfc.section.3.2.p.1"><p>A client that makes a request to an "<span class="tt">https</span>" URI uses <a href="#RFC8446"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">TLS</cite></a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[TLS13]</cite> with the <a href="#RFC7301"><cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">ALPN extension</cite></a> <cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite>.</p></div><div id="rfc.section.3.2.p.2"><p>HTTP/2 over TLS uses the "h2" protocol identifier. The "h2c" protocol identifier <em class="bcp14">MUST NOT</em> be sent by a client or selected by a server; the "h2c" protocol identifier describes a protocol that does not use TLS.</p></div><div id="rfc.section.3.2.p.3"><p>Once TLS negotiation is complete, both the client and the server <em class="bcp14">MUST</em> send a connection preface (<a href="#preface" title="HTTP/2 Connection Preface">Section 3.4</a>).</p></div></section><section id="known-http"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a>&nbsp;<a href="#known-http">Starting HTTP/2 with Prior Knowledge</a></h3><div id="rfc.section.3.3.p.1"><p>A client can learn that a particular server supports HTTP/2 by other means. For example, a client could be configured with knowledge that a server supports HTTP/2.</p></div><div id="rfc.section.3.3.p.2"><p>A client that knows that a server supports HTTP/2 can establish a TCP connection and send the connection preface (<a href="#preface" title="HTTP/2 Connection Preface">Section 3.4</a>) followed by HTTP/2 frames. Servers can identify these connections by the presence of the connection preface. This only affects the establishment of HTTP/2 connections over cleartext TCP; HTTP/2 connections over TLS <em class="bcp14">MUST</em> use <a href="#RFC7301"><cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">protocol negotiation in TLS</cite></a> <cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite>.</p></div><div id="rfc.section.3.3.p.3"><p>Likewise, the server <em class="bcp14">MUST</em> send a connection preface (<a href="#preface" title="HTTP/2 Connection Preface">Section 3.4</a>).</p></div><div id="rfc.section.3.3.p.4"><p>Without additional information, prior support for HTTP/2 is not a strong signal that a given server will support HTTP/2 for future connections. For example, it is possible for server configurations to change, for configurations to differ between instances in clustered servers, or for network conditions to change.</p></div></section><section id="preface"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a>&nbsp;<a href="#preface">HTTP/2 Connection Preface</a></h3><div id="rfc.section.3.4.p.1"><p>In HTTP/2, each endpoint is required to send a connection preface as a final confirmation of the protocol in use and to establish the initial settings for the HTTP/2 connection. The client and server each send a different connection preface.</p></div><div id="rfc.section.3.4.p.2" class="avoidbreakafter"><p>The client connection preface starts with a sequence of 24 octets, which in hex notation is:</p></div><div id="rfc.section.3.4.p.3"><pre class="inline">
  0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
</pre></div><div id="rfc.section.3.4.p.4"><p>That is, the connection preface starts with the string "<span class="tt">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</span>". This sequence <em class="bcp14">MUST</em> be followed by a <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section 6.5</a>), which <em class="bcp14">MAY</em> be empty. The client sends the client connection preface as the first application data octets of a connection.</p></div><div id="rfc.section.3.4.p.5"><aside><div id="rfc.section.3.4.p.5.1"><p>Note: The client connection preface is selected so that a large proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do not attempt to process further frames. Note that this does not address the concerns raised in <a href="#TALKING"><cite title="Talking to Yourself for Fun and Profit">[TALKING]</cite></a>.</p></div></aside></div><div id="rfc.section.3.4.p.6"><p>The server connection preface consists of a potentially empty <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section 6.5</a>) that <em class="bcp14">MUST</em> be the first frame the server sends in the HTTP/2 connection.</p></div><div id="rfc.section.3.4.p.7"><p>The <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frames received from a peer as part of the connection preface <em class="bcp14">MUST</em> be acknowledged (see <a href="#SettingsSync" title="Settings Synchronization">Section 6.5.3</a>) after sending the connection preface.</p></div><div id="rfc.section.3.4.p.8"><p>To avoid unnecessary latency, clients are permitted to send additional frames to the server immediately after sending the client connection preface, without waiting to receive the server connection preface. It is important to note, however, that the server connection preface <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame might include settings that necessarily alter how a client is expected to communicate with the server. Upon receiving the <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame, the client is expected to honor any settings established. In some configurations, it is possible for the server to transmit <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> before the client sends additional frames, providing an opportunity to avoid this issue.</p></div><div id="rfc.section.3.4.p.9"><p>Clients and servers <em class="bcp14">MUST</em> treat an invalid connection preface as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. A <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame (<a href="#GOAWAY" title="GOAWAY">Section 6.8</a>) <em class="bcp14">MAY</em> be omitted in this case, since an invalid preface indicates that the peer is not using HTTP/2.</p></div></section></section><hr class="hidden-print"><section id="FramingLayer"><h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#FramingLayer">HTTP Frames</a></h2><div id="rfc.section.4.p.1"><p>Once the HTTP/2 connection is established, endpoints can begin exchanging frames.</p></div><section id="FrameHeader"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a>&nbsp;<a href="#FrameHeader">Frame Format</a></h3><div id="rfc.section.4.1.p.1"><p>All frames begin with a fixed 9-octet header followed by a variable-length frame payload.</p></div><div id="FrameLayout"></div><div id="rfc.figure.1"><div><pre class="inline">
HTTP Frame {
  Length (24),
  Type (8),

  Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Frame Payload (..),
}
</pre></div></div><p class="figure">Figure 1: Frame Layout</p><div id="rfc.section.4.1.p.2" class="avoidbreakafter"><p>The fields of the frame header are defined as:</p></div><div id="rfc.section.4.1.p.3"><dl><dt>Length:</dt><dd style="margin-left: 1.5em"><div>The length of the frame payload expressed as an unsigned 24-bit integer in units of octets. Values greater than 2<sup>14</sup> (16,384) <em class="bcp14">MUST NOT</em> be sent unless the receiver has set a larger value for <a href="#SETTINGS_MAX_FRAME_SIZE">SETTINGS_MAX_FRAME_SIZE</a>.</div><div>The 9 octets of the frame header are not included in this value.</div></dd><dt>Type:</dt><dd style="margin-left: 1.5em"><div>The 8-bit type of the frame. The frame type determines the format and semantics of the frame. Frames defined in this document are listed in <a href="#FrameTypes" title="Frame Definitions">Section 6</a>. Implementations <em class="bcp14">MUST</em> ignore and discard frames of unknown types.</div></dd><dt>Flags:</dt><dd style="margin-left: 1.5em"><div>An 8-bit field reserved for boolean flags specific to the frame type.</div><div>Flags are assigned semantics specific to the indicated frame type. Unused flags are those that have no defined semantics for a particular frame type. Unused flags <em class="bcp14">MUST</em> be ignored on receipt and <em class="bcp14">MUST</em> be left unset (0x00) when sending.</div></dd><dt>Reserved:</dt><dd style="margin-left: 1.5em"><div>A reserved 1-bit field. The semantics of this bit are undefined, and the bit <em class="bcp14">MUST</em> remain unset (0x00) when sending and <em class="bcp14">MUST</em> be ignored when receiving.</div></dd><dt>Stream Identifier:</dt><dd style="margin-left: 1.5em"><div>A stream identifier (see <a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>) expressed as an unsigned 31-bit integer. The value 0x00 is reserved for frames that are associated with the connection as a whole as opposed to an individual stream.</div></dd></dl></div><div id="rfc.section.4.1.p.4"><p>The structure and content of the frame payload are dependent entirely on the frame type.</p></div></section><section id="FrameSize"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a>&nbsp;<a href="#FrameSize">Frame Size</a></h3><div id="rfc.section.4.2.p.1"><p>The size of a frame payload is limited by the maximum size that a receiver advertises in the <a href="#SETTINGS_MAX_FRAME_SIZE">SETTINGS_MAX_FRAME_SIZE</a> setting. This setting can have any value between 2<sup>14</sup> (16,384) and 2<sup>24</sup>-1 (16,777,215) octets, inclusive.</p></div><div id="rfc.section.4.2.p.2"><p>All implementations <em class="bcp14">MUST</em> be capable of receiving and minimally processing frames up to 2<sup>14</sup> octets in length, plus the 9-octet frame header (<a href="#FrameHeader" title="Frame Format">Section 4.1</a>). The size of the frame header is not included when describing frame sizes.</p></div><div id="rfc.section.4.2.p.3"><aside><div id="rfc.section.4.2.p.3.1"><p>Note: Certain frame types, such as PING (<a href="#PING" title="PING">Section 6.7</a>), impose additional limits on the amount of frame payload data allowed.</p></div></aside></div><div id="rfc.section.4.2.p.4"><p>An endpoint <em class="bcp14">MUST</em> send an error code of <a href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a> if a frame exceeds the size defined in <a href="#SETTINGS_MAX_FRAME_SIZE">SETTINGS_MAX_FRAME_SIZE</a>, exceeds any limit defined for the frame type, or is too small to contain mandatory frame data. A frame size error in a frame that could alter the state of the entire connection <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>); this includes any frame carrying a field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) (that is, <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>, and <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>), a <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame, and any frame with a stream identifier of 0.</p></div><div id="rfc.section.4.2.p.5"><p>Endpoints are not obligated to use all available space in a frame. Responsiveness can be improved by using frames that are smaller than the permitted maximum size. Sending large frames can result in delays in sending time-sensitive frames (such as <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>, or <a href="#PRIORITY" title="PRIORITY">PRIORITY</a>), which, if blocked by the transmission of a large frame, could affect performance.</p></div></section><section id="FieldBlock"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a>&nbsp;<a href="#FieldBlock">Field Section Compression and Decompression</a></h3><div id="rfc.section.4.3.p.1"><p>Field section compression is the process of compressing a set of field lines (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.2">Section 5.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>) to form a field block. Field section decompression is the process of decoding a field block into a set of field lines. Details of HTTP/2 field section compression and decompression are defined in <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>, which, for historical reasons, refers to these processes as header compression and decompression.</p></div><div id="rfc.section.4.3.p.2"><p>Each field block carries all of the compressed field lines of a single field section. Header sections also include control data associated with the message in the form of pseudo-header fields (<a href="#PseudoHeaderFields" title="HTTP Control Data">Section 8.3</a>) that use the same format as a field line.</p></div><div id="rfc.section.4.3.p.3"><aside><div id="rfc.section.4.3.p.3.1"><p>Note: <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">RFC 7540</cite></a> <cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite> used the term "header block" in place of the more generic "field block".</p></div></aside></div><div id="rfc.section.4.3.p.4"><p>Field blocks carry control data and header sections for requests, responses, promised requests, and pushed responses (see <a href="#PushResources" title="Server Push">Section 8.4</a>). All these messages, except for interim responses and requests contained in PUSH_PROMISE (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section 6.6</a>) frames, can optionally include a field block that carries a trailer section.</p></div><div id="rfc.section.4.3.p.5"><p>A field section is a collection of field lines. Each of the field lines in a field block carries a single value. The serialized field block is then divided into one or more octet sequences, called field block fragments. The first field block fragment is transmitted within the frame payload of HEADERS (<a href="#HEADERS" title="HEADERS">Section 6.2</a>) or PUSH_PROMISE (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section 6.6</a>), each of which could be followed by CONTINUATION (<a href="#CONTINUATION" title="CONTINUATION">Section 6.10</a>) frames to carry subsequent field block fragments.</p></div><div id="rfc.section.4.3.p.6"><p>The <a href="#RFC6265"><cite title="HTTP State Management Mechanism">Cookie header field</cite></a> <cite title="HTTP State Management Mechanism">[COOKIE]</cite> is treated specially by the HTTP mapping (see <a href="#CompressCookie" title="Compressing the Cookie Header Field">Section 8.2.3</a>).</p></div><div id="rfc.section.4.3.p.7"><p>A receiving endpoint reassembles the field block by concatenating its fragments and then decompresses the block to reconstruct the field section.</p></div><div id="rfc.section.4.3.p.8" class="avoidbreakafter"><p>A complete field section consists of either:</p></div><div id="rfc.section.4.3.p.9"><ul><li>a single <a href="#HEADERS" title="HEADERS">HEADERS</a> or <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame, with the END_HEADERS flag set, or</li><li>a <a href="#HEADERS" title="HEADERS">HEADERS</a> or <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame with the END_HEADERS flag unset and one or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames, where the last <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frame has the END_HEADERS flag set.</li></ul></div><div id="rfc.section.4.3.p.10"><p>Each field block is processed as a discrete unit. Field blocks <em class="bcp14">MUST</em> be transmitted as a contiguous sequence of frames, with no interleaved frames of any other type or from any other stream. The last frame in a sequence of <a href="#HEADERS" title="HEADERS">HEADERS</a> or <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames has the END_HEADERS flag set. The last frame in a sequence of <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> or <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames has the END_HEADERS flag set. This allows a field block to be logically equivalent to a single frame.</p></div><div id="rfc.section.4.3.p.11"><p>Field block fragments can only be sent as the frame payload of <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>, or <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames because these frames carry data that can modify the compression context maintained by a receiver. An endpoint receiving <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>, or <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames needs to reassemble field blocks and perform decompression even if the frames are to be discarded. A receiver <em class="bcp14">MUST</em> terminate the connection with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#COMPRESSION_ERROR">COMPRESSION_ERROR</a> if it does not decompress a field block.</p></div><div id="rfc.section.4.3.p.12"><p>A decoding error in a field block <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#COMPRESSION_ERROR">COMPRESSION_ERROR</a>.</p></div><section id="dynamic-table"><h4 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;<a href="#dynamic-table">Compression State</a></h4><div id="rfc.section.4.3.1.p.1"><p>Field compression is stateful. Each endpoint has an HPACK encoder context and an HPACK decoder context that are used for encoding and decoding all field blocks on a connection. <a href="https://www.rfc-editor.org/rfc/rfc7541.html#section-4">Section 4</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a> defines the dynamic table, which is the primary state for each context.</p></div><div id="rfc.section.4.3.1.p.2"><p>The dynamic table has a maximum size that is set by an HPACK decoder. An endpoint communicates the size chosen by its HPACK decoder context using the SETTINGS_HEADER_TABLE_SIZE setting; see <a href="#SettingValues" title="Defined Settings">Section 6.5.2</a>. When a connection is established, the dynamic table size for the HPACK decoder and encoder at both endpoints starts at 4,096 bytes, the initial value of the SETTINGS_HEADER_TABLE_SIZE setting.</p></div><div id="rfc.section.4.3.1.p.3"><p>Any change to the maximum value set using SETTINGS_HEADER_TABLE_SIZE takes effect when the endpoint acknowledges settings (<a href="#SettingsSync" title="Settings Synchronization">Section 6.5.3</a>). The HPACK encoder at that endpoint can set the dynamic table to any size up to the maximum value set by the decoder. An HPACK encoder declares the size of the dynamic table with a Dynamic Table Size Update instruction (<a href="https://www.rfc-editor.org/rfc/rfc7541.html#section-6.3">Section 6.3</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>).</p></div><div id="rfc.section.4.3.1.p.4"><p>Once an endpoint acknowledges a change to SETTINGS_HEADER_TABLE_SIZE that reduces the maximum below the current size of the dynamic table, its HPACK encoder <em class="bcp14">MUST</em> start the next field block with a Dynamic Table Size Update instruction that sets the dynamic table to a size that is less than or equal to the reduced maximum; see <a href="https://www.rfc-editor.org/rfc/rfc7541.html#section-4.2">Section 4.2</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>. An endpoint <em class="bcp14">MUST</em> treat a field block that follows an acknowledgment of the reduction to the maximum dynamic table size as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#COMPRESSION_ERROR">COMPRESSION_ERROR</a> if it does not start with a conformant Dynamic Table Size Update instruction.</p></div><div id="rfc.section.4.3.1.p.5"><aside><div id="rfc.section.4.3.1.p.5.1"><p>Implementers are advised that reducing the value of SETTINGS_HEADER_TABLE_SIZE is not widely interoperable. Use of the connection preface to reduce the value below the initial value of 4,096 is somewhat better supported, but this might fail with some implementations.</p></div></aside></div></section></section></section><hr class="hidden-print"><section id="StreamsLayer"><h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#StreamsLayer">Streams and Multiplexing</a></h2><div id="rfc.section.5.p.1" class="avoidbreakafter"><p>A "stream" is an independent, bidirectional sequence of frames exchanged between the client and server within an HTTP/2 connection. Streams have several important characteristics:</p></div><div id="rfc.section.5.p.2"><ul><li>A single HTTP/2 connection can contain multiple concurrently open streams, with either endpoint interleaving frames from multiple streams.</li><li>Streams can be established and used unilaterally or shared by either endpoint.</li><li>Streams can be closed by either endpoint.</li><li>The order in which frames are sent is significant. Recipients process frames in the order they are received. In particular, the order of <a href="#HEADERS" title="HEADERS">HEADERS</a> and <a href="#DATA" title="DATA">DATA</a> frames is semantically significant.</li><li>Streams are identified by an integer. Stream identifiers are assigned to streams by the endpoint initiating the stream.</li></ul></div><section id="StreamStates"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a>&nbsp;<a href="#StreamStates">Stream States</a></h3><div id="rfc.section.5.1.p.1"><p>The lifecycle of a stream is shown in <a href="#StreamStatesFigure" title="Stream States">Figure 2</a>.</p></div><div id="StreamStatesFigure"></div><div id="rfc.figure.2"><div class="artwork art-svg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xi="http://www.w3.org/2001/XInclude" version="1.1" height="480" width="488" viewBox="0 0 488 480" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px"><g transform="translate(8,16)">
                  <path d="M 0,112 L 0,416" fill="none" stroke="black"/>
                  <path d="M 56,80 L 56,144" fill="none" stroke="black"/>
                  <path d="M 56,240 L 56,304" fill="none" stroke="black"/>
                  <path d="M 88,144 L 88,232" fill="none" stroke="black"/>
                  <path d="M 96,304 L 96,384" fill="none" stroke="black"/>
                  <path d="M 144,80 L 144,144" fill="none" stroke="black"/>
                  <path d="M 144,240 L 144,304" fill="none" stroke="black"/>
                  <path d="M 200,0 L 200,64" fill="none" stroke="black"/>
                  <path d="M 200,160 L 200,224" fill="none" stroke="black"/>
                  <path d="M 200,368 L 200,432" fill="none" stroke="black"/>
                  <path d="M 232,64 L 232,152" fill="none" stroke="black"/>
                  <path d="M 232,224 L 232,360" fill="none" stroke="black"/>
                  <path d="M 272,0 L 272,64" fill="none" stroke="black"/>
                  <path d="M 272,160 L 272,224" fill="none" stroke="black"/>
                  <path d="M 272,368 L 272,432" fill="none" stroke="black"/>
                  <path d="M 328,80 L 328,144" fill="none" stroke="black"/>
                  <path d="M 328,240 L 328,304" fill="none" stroke="black"/>
                  <path d="M 376,304 L 376,384" fill="none" stroke="black"/>
                  <path d="M 384,144 L 384,232" fill="none" stroke="black"/>
                  <path d="M 416,80 L 416,144" fill="none" stroke="black"/>
                  <path d="M 416,240 L 416,304" fill="none" stroke="black"/>
                  <path d="M 472,112 L 472,416" fill="none" stroke="black"/>
                  <path d="M 200,0 L 272,0" fill="none" stroke="black"/>
                  <path d="M 128,32 L 200,32" fill="none" stroke="black"/>
                  <path d="M 272,32 L 344,32" fill="none" stroke="black"/>
                  <path d="M 200,64 L 272,64" fill="none" stroke="black"/>
                  <path d="M 56,80 L 144,80" fill="none" stroke="black"/>
                  <path d="M 328,80 L 416,80" fill="none" stroke="black"/>
                  <path d="M 0,112 L 56,112" fill="none" stroke="black"/>
                  <path d="M 416,112 L 472,112" fill="none" stroke="black"/>
                  <path d="M 56,144 L 144,144" fill="none" stroke="black"/>
                  <path d="M 328,144 L 416,144" fill="none" stroke="black"/>
                  <path d="M 200,160 L 272,160" fill="none" stroke="black"/>
                  <path d="M 136,192 L 200,192" fill="none" stroke="black"/>
                  <path d="M 272,192 L 336,192" fill="none" stroke="black"/>
                  <path d="M 200,224 L 272,224" fill="none" stroke="black"/>
                  <path d="M 56,240 L 144,240" fill="none" stroke="black"/>
                  <path d="M 328,240 L 416,240" fill="none" stroke="black"/>
                  <path d="M 56,304 L 144,304" fill="none" stroke="black"/>
                  <path d="M 328,304 L 416,304" fill="none" stroke="black"/>
                  <path d="M 200,368 L 272,368" fill="none" stroke="black"/>
                  <path d="M 96,384 L 192,384" fill="none" stroke="black"/>
                  <path d="M 280,384 L 376,384" fill="none" stroke="black"/>
                  <path d="M 0,416 L 192,416" fill="none" stroke="black"/>
                  <path d="M 280,416 L 472,416" fill="none" stroke="black"/>
                  <path d="M 200,432 L 272,432" fill="none" stroke="black"/>
                  <path d="M 336,192 L 356,232" fill="none" stroke="black"/>
                  <path d="M 344,32 L 364,72" fill="none" stroke="black"/>
                  <path d="M 108,72 L 128,32" fill="none" stroke="black"/>
                  <path d="M 116,232 L 136,192" fill="none" stroke="black"/>
                  <polygon class="arrowhead" points="392,232 380,226.4 380,237.6" fill="black" transform="rotate(90,384,232)"/>
                  <polygon class="arrowhead" points="372,72 360,66.4 360,77.6" fill="black" transform="rotate(63.43494882292201,364,72)"/>
                  <polygon class="arrowhead" points="364,232 352,226.4 352,237.6" fill="black" transform="rotate(63.43494882292201,356,232)"/>
                  <polygon class="arrowhead" points="288,416 276,410.4 276,421.6" fill="black" transform="rotate(180,280,416)"/>
                  <polygon class="arrowhead" points="288,384 276,378.4 276,389.6" fill="black" transform="rotate(180,280,384)"/>
                  <polygon class="arrowhead" points="240,360 228,354.4 228,365.6" fill="black" transform="rotate(90,232,360)"/>
                  <polygon class="arrowhead" points="240,152 228,146.4 228,157.6" fill="black" transform="rotate(90,232,152)"/>
                  <polygon class="arrowhead" points="200,416 188,410.4 188,421.6" fill="black" transform="rotate(0,192,416)"/>
                  <polygon class="arrowhead" points="200,384 188,378.4 188,389.6" fill="black" transform="rotate(0,192,384)"/>
                  <polygon class="arrowhead" points="124,232 112,226.4 112,237.6" fill="black" transform="rotate(116.56505117707799,116,232)"/>
                  <polygon class="arrowhead" points="116,72 104,66.4 104,77.6" fill="black" transform="rotate(116.56505117707799,108,72)"/>
                  <polygon class="arrowhead" points="96,232 84,226.4 84,237.6" fill="black" transform="rotate(90,88,232)"/>
                  <g class="text">
                    <text x="160" y="20">send PP</text>
                    <text x="312" y="20">recv PP</text>
                    <text x="236" y="36">idle</text>
                    <text x="276" y="100">send H /</text>
                    <text x="100" y="116">reserved</text>
                    <text x="268" y="116">recv H</text>
                    <text x="372" y="116">reserved</text>
                    <text x="96" y="132">(local)</text>
                    <text x="372" y="132">(remote)</text>
                    <text x="160" y="180">recv ES</text>
                    <text x="312" y="180">send ES</text>
                    <text x="52" y="196">send H</text>
                    <text x="236" y="196">open</text>
                    <text x="420" y="196">recv H</text>
                    <text x="100" y="260">half-</text>
                    <text x="372" y="260">half-</text>
                    <text x="100" y="276">closed</text>
                    <text x="276" y="276">send R /</text>
                    <text x="372" y="276">closed</text>
                    <text x="100" y="292">(remote)</text>
                    <text x="268" y="292">recv R</text>
                    <text x="368" y="292">(local)</text>
                    <text x="144" y="340">send ES /</text>
                    <text x="328" y="340">recv ES /</text>
                    <text x="148" y="356">send R /</text>
                    <text x="332" y="356">send R /</text>
                    <text x="140" y="372">recv R</text>
                    <text x="324" y="372">recv R</text>
                    <text x="44" y="388">send R /</text>
                    <text x="428" y="388">send R /</text>
                    <text x="36" y="404">recv R</text>
                    <text x="236" y="404">closed</text>
                    <text x="420" y="404">recv R</text>
                  </g>
                </g></svg></div></div><p class="figure">Figure 2: Stream States</p><div id="rfc.section.5.1.p.2"><dl class="compact"><dt><span class="tt">send</span>:</dt><dd style="margin-left: 1.5em">endpoint sends this frame</dd><dt><span class="tt">recv</span>:</dt><dd style="margin-left: 1.5em">endpoint receives this frame</dd><dt><span class="tt">H</span>:</dt><dd style="margin-left: 1.5em"><a href="#HEADERS" title="HEADERS">HEADERS</a> frame (with implied <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames)</dd><dt><span class="tt">ES</span>:</dt><dd style="margin-left: 1.5em">END_STREAM flag</dd><dt><span class="tt">R</span>:</dt><dd style="margin-left: 1.5em"><a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame</dd><dt><span class="tt">PP</span>:</dt><dd style="margin-left: 1.5em"><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame (with implied <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames); state transitions are for the promised stream</dd></dl></div><div id="rfc.section.5.1.p.3"><p>Note that this diagram shows stream state transitions and the frames and flags that affect those transitions only. In this regard, <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames do not result in state transitions; they are effectively part of the <a href="#HEADERS" title="HEADERS">HEADERS</a> or <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> that they follow. For the purpose of state transitions, the END_STREAM flag is processed as a separate event to the frame that bears it; a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame with the END_STREAM flag set can cause two state transitions.</p></div><div id="rfc.section.5.1.p.4"><p>Both endpoints have a subjective view of the state of a stream that could be different when frames are in transit. Endpoints do not coordinate the creation of streams; they are created unilaterally by either endpoint. The negative consequences of a mismatch in states are limited to the "closed" state after sending <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, where frames might be received for some time after closing.</p></div><div id="rfc.section.5.1.p.5" class="avoidbreakafter"><p>Streams have the following states:</p></div><div id="rfc.section.5.1.p.6"><dl><dt>idle:</dt><dd style="margin-left: 1.5em"><div>All streams start in the "idle" state.</div><div>The following transitions are valid from this state:</div><div><ul><li>Sending a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame as a client, or receiving a HEADERS frame as a server, causes the stream to become "open". The stream identifier is selected as described in <a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>. The same <a href="#HEADERS" title="HEADERS">HEADERS</a> frame can also cause a stream to immediately become "half-closed".</li><li>Sending a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame on another stream reserves the idle stream that is identified for later use. The stream state for the reserved stream transitions to "reserved (local)". Only a server may send <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames.</li><li>Receiving a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame on another stream reserves an idle stream that is identified for later use. The stream state for the reserved stream transitions to "reserved (remote)". Only a client may receive <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames.</li><li>Note that the <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame is not sent on the idle stream but references the newly reserved stream in the Promised Stream ID field.</li><li>Opening a stream with a higher-valued stream identifier causes the stream to transition immediately to a "closed" state; note that this transition is not shown in the diagram.</li></ul></div><div>Receiving any frame other than <a href="#HEADERS" title="HEADERS">HEADERS</a> or <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> on a stream in this state <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. If this stream is initiated by the server, as described in <a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>, then receiving a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame <em class="bcp14">MUST</em> also be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div></dd><dt>reserved (local):</dt><dd style="margin-left: 1.5em"><div>A stream in the "reserved (local)" state is one that has been promised by sending a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame. A <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame reserves an idle stream by associating the stream with an open stream that was initiated by the remote peer (see <a href="#PushResources" title="Server Push">Section 8.4</a>).</div><div>In this state, only the following transitions are possible:</div><div><ul><li>The endpoint can send a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame. This causes the stream to open in a "half-closed (remote)" state.</li><li>Either endpoint can send a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame to cause the stream to become "closed". This releases the stream reservation.</li></ul></div><div>An endpoint <em class="bcp14">MUST NOT</em> send any type of frame other than <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, or <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> in this state.</div><div>A <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> or <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frame <em class="bcp14">MAY</em> be received in this state. Receiving any type of frame other than <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, <a href="#PRIORITY" title="PRIORITY">PRIORITY</a>, or <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> on a stream in this state <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div></dd><dt>reserved (remote):</dt><dd style="margin-left: 1.5em"><div>A stream in the "reserved (remote)" state has been reserved by a remote peer.</div><div>In this state, only the following transitions are possible:</div><div><ul><li>Receiving a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame causes the stream to transition to "half-closed (local)".</li><li>Either endpoint can send a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame to cause the stream to become "closed". This releases the stream reservation.</li></ul></div><div>An endpoint <em class="bcp14">MUST NOT</em> send any type of frame other than <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>, or <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> in this state.</div><div>Receiving any type of frame other than <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, or <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> on a stream in this state <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div></dd><dt>open:</dt><dd style="margin-left: 1.5em"><div>A stream in the "open" state may be used by both peers to send frames of any type. In this state, sending peers observe advertised stream-level flow-control limits (<a href="#FlowControl" title="Flow Control">Section 5.2</a>).</div><div>From this state, either endpoint can send a frame with an END_STREAM flag set, which causes the stream to transition into one of the "half-closed" states. An endpoint sending an END_STREAM flag causes the stream state to become "half-closed (local)"; an endpoint receiving an END_STREAM flag causes the stream state to become "half-closed (remote)".</div><div>Either endpoint can send a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame from this state, causing it to transition immediately to "closed".</div></dd><dt>half-closed (local):</dt><dd style="margin-left: 1.5em"><div>A stream that is in the "half-closed (local)" state cannot be used for sending frames other than <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>, <a href="#PRIORITY" title="PRIORITY">PRIORITY</a>, and <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>.</div><div>A stream transitions from this state to "closed" when a frame is received with the END_STREAM flag set or when either peer sends a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame.</div><div>An endpoint can receive any type of frame in this state. Providing flow-control credit using <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frames is necessary to continue receiving flow-controlled frames. In this state, a receiver can ignore <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frames, which might arrive for a short period after a frame with the END_STREAM flag set is sent.</div><div><a href="#PRIORITY" title="PRIORITY">PRIORITY</a> frames can be received in this state.</div></dd><dt>half-closed (remote):</dt><dd style="margin-left: 1.5em"><div>A stream that is "half-closed (remote)" is no longer being used by the peer to send frames. In this state, an endpoint is no longer obligated to maintain a receiver flow-control window.</div><div>If an endpoint receives additional frames, other than <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>, <a href="#PRIORITY" title="PRIORITY">PRIORITY</a>, or <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, for a stream that is in this state, it <em class="bcp14">MUST</em> respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#STREAM_CLOSED">STREAM_CLOSED</a>.</div><div>A stream that is "half-closed (remote)" can be used by the endpoint to send frames of any type. In this state, the endpoint continues to observe advertised stream-level flow-control limits (<a href="#FlowControl" title="Flow Control">Section 5.2</a>).</div><div>A stream can transition from this state to "closed" by sending a frame with the END_STREAM flag set or when either peer sends a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame.</div></dd><dt>closed:</dt><dd style="margin-left: 1.5em"><div>The "closed" state is the terminal state.</div><div>A stream enters the "closed" state after an endpoint both sends and receives a frame with an END_STREAM flag set. A stream also enters the "closed" state after an endpoint either sends or receives a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame.</div><div>An endpoint <em class="bcp14">MUST NOT</em> send frames other than <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> on a closed stream. An endpoint <em class="bcp14">MAY</em> treat receipt of any other type of frame on a closed stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#STREAM_CLOSED">STREAM_CLOSED</a>, except as noted below.</div><div>An endpoint that sends a frame with the END_STREAM flag set or a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame might receive a <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> or <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame from its peer in the time before the peer receives and processes the frame that closes the stream.</div><div>An endpoint that sends a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame on a stream that is in the "open" or "half-closed (local)" state could receive any type of frame. The peer might have sent or enqueued for sending these frames before processing the <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame. An endpoint <em class="bcp14">MUST</em> minimally process and then discard any frames it receives in this state. This means updating header compression state for <a href="#HEADERS" title="HEADERS">HEADERS</a> and <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames. Receiving a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame also causes the promised stream to become "reserved (remote)", even when the <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame is received on a closed stream. Additionally, the content of <a href="#DATA" title="DATA">DATA</a> frames counts toward the connection flow-control window.</div><div>An endpoint can perform this minimal processing for all streams that are in the "closed" state. Endpoints <em class="bcp14">MAY</em> use other signals to detect that a peer has received the frames that caused the stream to enter the "closed" state and treat receipt of any frame other than <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. Endpoints can use frames that indicate that the peer has received the closing signal to drive this. Endpoints <em class="bcp14">SHOULD NOT</em> use timers for this purpose. For example, an endpoint that sends a <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame after closing a stream can safely treat receipt of a <a href="#DATA" title="DATA">DATA</a> frame on that stream as an error after receiving an acknowledgment of the settings. Other things that might be used are <a href="#PING" title="PING">PING</a> frames, receiving data on streams that were created after closing the stream, or responses to requests created after closing the stream.</div></dd></dl></div><div id="rfc.section.5.1.p.7"><p>In the absence of more specific rules, implementations <em class="bcp14">SHOULD</em> treat the receipt of a frame that is not expressly permitted in the description of a state as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. Note that <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> can be sent and received in any stream state.</p></div><div id="rfc.section.5.1.p.8"><p>The rules in this section only apply to frames defined in this document. Receipt of frames for which the semantics are unknown cannot be treated as an error, as the conditions for sending and receiving those frames are also unknown; see <a href="#extensibility" title="Extending HTTP/2">Section 5.5</a>.</p></div><div id="rfc.section.5.1.p.9"><p>An example of the state transitions for an HTTP request/response exchange can be found in <a href="#HttpExamples" title="Examples">Section 8.8</a>. An example of the state transitions for server push can be found in Sections&nbsp;<a href="#PushRequests" title="Push Requests">8.4.1</a> and <a href="#PushResponses" title="Push Responses">8.4.2</a>.</p></div><section id="StreamIdentifiers"><h4 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a>&nbsp;<a href="#StreamIdentifiers">Stream Identifiers</a></h4><div id="rfc.section.5.1.1.p.1"><p>Streams are identified by an unsigned 31-bit integer. Streams initiated by a client <em class="bcp14">MUST</em> use odd-numbered stream identifiers; those initiated by the server <em class="bcp14">MUST</em> use even-numbered stream identifiers. A stream identifier of zero (0x00) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.</p></div><div id="rfc.section.5.1.1.p.2"><p>The identifier of a newly established stream <em class="bcp14">MUST</em> be numerically greater than all streams that the initiating endpoint has opened or reserved. This governs streams that are opened using a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame and streams that are reserved using <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>. An endpoint that receives an unexpected stream identifier <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.5.1.1.p.3"><p>A <a href="#HEADERS" title="HEADERS">HEADERS</a> frame will transition the client-initiated stream identified by the stream identifier in the frame header from "idle" to "open". A <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame will transition the server-initiated stream identified by the Promised Stream ID field in the frame payload from "idle" to "reserved (local)" or "reserved (remote)". When a stream transitions out of the "idle" state, all streams in the "idle" state that might have been opened by the peer with a lower-valued stream identifier immediately transition to "closed". That is, an endpoint may skip a stream identifier, with the effect being that the skipped stream is immediately closed.</p></div><div id="rfc.section.5.1.1.p.4"><p>Stream identifiers cannot be reused. Long-lived connections can result in an endpoint exhausting the available range of stream identifiers. A client that is unable to establish a new stream identifier can establish a new connection for new streams. A server that is unable to establish a new stream identifier can send a <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame so that the client is forced to open a new connection for new streams.</p></div></section><section id="n-stream-concurrency"><h4 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a>&nbsp;<a href="#n-stream-concurrency">Stream Concurrency</a></h4><div id="rfc.section.5.1.2.p.1"><p>A peer can limit the number of concurrently active streams using the <a href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a> parameter (see <a href="#SettingValues" title="Defined Settings">Section 6.5.2</a>) within a <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame. The maximum concurrent streams setting is specific to each endpoint and applies only to the peer that receives the setting. That is, clients specify the maximum number of concurrent streams the server can initiate, and servers specify the maximum number of concurrent streams the client can initiate.</p></div><div id="rfc.section.5.1.2.p.2"><p>Streams that are in the "open" state or in either of the "half-closed" states count toward the maximum number of streams that an endpoint is permitted to open. Streams in any of these three states count toward the limit advertised in the <a href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a> setting. Streams in either of the "reserved" states do not count toward the stream limit.</p></div><div id="rfc.section.5.1.2.p.3"><p>Endpoints <em class="bcp14">MUST NOT</em> exceed the limit set by their peer. An endpoint that receives a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame that causes its advertised concurrent stream limit to be exceeded <em class="bcp14">MUST</em> treat this as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> or <a href="#REFUSED_STREAM">REFUSED_STREAM</a>. The choice of error code determines whether the endpoint wishes to enable automatic retry (see <a href="#Reliability" title="Request Reliability">Section 8.7</a> for details).</p></div><div id="rfc.section.5.1.2.p.4"><p>An endpoint that wishes to reduce the value of <a href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a> to a value that is below the current number of open streams can either close streams that exceed the new value or allow streams to complete.</p></div></section></section><section id="FlowControl"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a>&nbsp;<a href="#FlowControl">Flow Control</a></h3><div id="rfc.section.5.2.p.1"><p>Using streams for multiplexing introduces contention over use of the TCP connection, resulting in blocked streams. A flow-control scheme ensures that streams on the same connection do not destructively interfere with each other. Flow control is used for both individual streams and the connection as a whole.</p></div><div id="rfc.section.5.2.p.2"><p>HTTP/2 provides for flow control through use of the WINDOW_UPDATE frame (<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section 6.9</a>).</p></div><section id="fc-principles"><h4 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;<a href="#fc-principles">Flow-Control Principles</a></h4><div id="rfc.section.5.2.1.p.1" class="avoidbreakafter"><p>HTTP/2 stream flow control aims to allow a variety of flow-control algorithms to be used without requiring protocol changes. Flow control in HTTP/2 has the following characteristics:</p></div><div id="rfc.section.5.2.1.p.2"><ol type="1"><li>Flow control is specific to a connection. HTTP/2 flow control operates between the endpoints of a single hop and not over the entire end-to-end path.</li><li>Flow control is based on <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frames. Receivers advertise how many octets they are prepared to receive on a stream and for the entire connection. This is a credit-based scheme.</li><li>Flow control is directional with overall control provided by the receiver. A receiver <em class="bcp14">MAY</em> choose to set any window size that it desires for each stream and for the entire connection. A sender <em class="bcp14">MUST</em> respect flow-control limits imposed by a receiver. Clients, servers, and intermediaries all independently advertise their flow-control window as a receiver and abide by the flow-control limits set by their peer when sending.</li><li>The initial value for the flow-control window is 65,535 octets for both new streams and the overall connection.</li><li>The frame type determines whether flow control applies to a frame. Of the frames specified in this document, only <a href="#DATA" title="DATA">DATA</a> frames are subject to flow control; all other frame types do not consume space in the advertised flow-control window. This ensures that important control frames are not blocked by flow control.</li><li>An endpoint can choose to disable its own flow control, but an endpoint cannot ignore flow-control signals from its peer.</li><li>HTTP/2 defines only the format and semantics of the <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frame (<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section 6.9</a>). This document does not stipulate how a receiver decides when to send this frame or the value that it sends, nor does it specify how a sender chooses to send packets. Implementations are able to select any algorithm that suits their needs.</li></ol></div><div id="rfc.section.5.2.1.p.3"><p>Implementations are also responsible for prioritizing the sending of requests and responses, choosing how to avoid head-of-line blocking for requests, and managing the creation of new streams. Algorithm choices for these could interact with any flow-control algorithm.</p></div></section><section id="DisableFlowControl"><h4 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2.</a>&nbsp;<a href="#DisableFlowControl">Appropriate Use of Flow Control</a></h4><div id="rfc.section.5.2.2.p.1"><p>Flow control is defined to protect endpoints that are operating under resource constraints. For example, a proxy needs to share memory between many connections and also might have a slow upstream connection and a fast downstream one. Flow control addresses cases where the receiver is unable to process data on one stream yet wants to continue to process other streams in the same connection.</p></div><div id="rfc.section.5.2.2.p.2"><p>Deployments that do not require this capability can advertise a flow-control window of the maximum size (2<sup>31</sup>-1) and can maintain this window by sending a <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frame when any data is received. This effectively disables flow control for that receiver. Conversely, a sender is always subject to the flow-control window advertised by the receiver.</p></div><div id="rfc.section.5.2.2.p.3"><p>Deployments with constrained resources (for example, memory) can employ flow control to limit the amount of memory a peer can consume. Note, however, that this can lead to suboptimal use of available network resources if flow control is enabled without knowledge of the bandwidth * delay product (see <a href="#RFC7323"><cite title="TCP Extensions for High Performance">[RFC7323]</cite></a>).</p></div><div id="rfc.section.5.2.2.p.4"><p>Even with full awareness of the current bandwidth * delay product, implementation of flow control can be difficult. Endpoints <em class="bcp14">MUST</em> read and process HTTP/2 frames from the TCP receive buffer as soon as data is available. Failure to read promptly could lead to a deadlock when critical frames, such as <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>, are not read and acted upon. Reading frames promptly does not expose endpoints to resource exhaustion attacks, as HTTP/2 flow control limits resource commitments.</p></div></section><section id="FlowControlPerformance"><h4 id="rfc.section.5.2.3"><a href="#rfc.section.5.2.3">5.2.3.</a>&nbsp;<a href="#FlowControlPerformance">Flow-Control Performance</a></h4><div id="rfc.section.5.2.3.p.1"><p>If an endpoint cannot ensure that its peer always has available flow-control window space that is greater than the peer's bandwidth * delay product on this connection, its receive throughput will be limited by HTTP/2 flow control. This will result in degraded performance.</p></div><div id="rfc.section.5.2.3.p.2"><p>Sending timely <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frames can improve performance. Endpoints will want to balance the need to improve receive throughput with the need to manage resource exhaustion risks and should take careful note of <a href="#dos" title="Denial-of-Service Considerations">Section 10.5</a> in defining their strategy to manage window sizes.</p></div></section></section><section id="StreamPriority"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a>&nbsp;<a href="#StreamPriority">Prioritization</a></h3><div id="rfc.section.5.3.p.1"><p>In a multiplexed protocol like HTTP/2, prioritizing allocation of bandwidth and computation resources to streams can be critical to attaining good performance. A poor prioritization scheme can result in HTTP/2 providing poor performance. With no parallelism at the TCP layer, performance could be significantly worse than HTTP/1.1.</p></div><div id="rfc.section.5.3.p.2"><p>A good prioritization scheme benefits from the application of contextual knowledge such as the content of resources, how resources are interrelated, and how those resources will be used by a peer. In particular, clients can possess knowledge about the priority of requests that is relevant to server prioritization. In those cases, having clients provide priority information can improve performance.</p></div><section id="PriorityHistory"><h4 id="rfc.section.5.3.1"><a href="#rfc.section.5.3.1">5.3.1.</a>&nbsp;<a href="#PriorityHistory">Background on Priority in RFC 7540</a></h4><div id="rfc.section.5.3.1.p.1"><p>RFC 7540 defined a rich system for signaling priority of requests. However, this system proved to be complex, and it was not uniformly implemented.</p></div><div id="rfc.section.5.3.1.p.2"><p>The flexible scheme meant that it was possible for clients to express priorities in very different ways, with little consistency in the approaches that were adopted. For servers, implementing generic support for the scheme was complex. Implementation of priorities was uneven in both clients and servers. Many server deployments ignored client signals when prioritizing their handling of requests.</p></div><div id="rfc.section.5.3.1.p.3"><p>In short, the prioritization signaling in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">RFC 7540</cite></a> <cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite> was not successful.</p></div></section><section id="PriorityHere"><h4 id="rfc.section.5.3.2"><a href="#rfc.section.5.3.2">5.3.2.</a>&nbsp;<a href="#PriorityHere">Priority Signaling in This Document</a></h4><div id="rfc.section.5.3.2.p.1"><p>This update to HTTP/2 deprecates the priority signaling defined in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">RFC 7540</cite></a> <cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite>. The bulk of the text related to priority signals is not included in this document. The description of frame fields and some of the mandatory handling is retained to ensure that implementations of this document remain interoperable with implementations that use the priority signaling described in RFC 7540.</p></div><div id="rfc.section.5.3.2.p.2"><p>A thorough description of the RFC 7540 priority scheme remains in <a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-5.3">Section 5.3</a> of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>.</p></div><div id="rfc.section.5.3.2.p.3"><p>Signaling priority information is necessary to attain good performance in many cases. Where signaling priority information is important, endpoints are encouraged to use an alternative scheme, such as the scheme described in <a href="#RFC9218"><cite title="Extensible Prioritization Scheme for HTTP">[HTTP-PRIORITY]</cite></a>.</p></div><div id="rfc.section.5.3.2.p.4"><p>Though the priority signaling from RFC 7540 was not widely adopted, the information it provides can still be useful in the absence of better information. Endpoints that receive priority signals in <a href="#HEADERS" title="HEADERS">HEADERS</a> or <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> frames can benefit from applying that information. In particular, implementations that consume these signals would not benefit from discarding these priority signals in the absence of alternatives.</p></div><div id="rfc.section.5.3.2.p.5"><p>Servers <em class="bcp14">SHOULD</em> use other contextual information in determining priority of requests in the absence of any priority signals. Servers <em class="bcp14">MAY</em> interpret the complete absence of signals as an indication that the client has not implemented the feature. The defaults described in <a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-5.3.5">Section 5.3.5</a> of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> are known to have poor performance under most conditions, and their use is unlikely to be deliberate.</p></div></section></section><section id="ErrorHandler"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a>&nbsp;<a href="#ErrorHandler">Error Handling</a></h3><div id="rfc.section.5.4.p.1" class="avoidbreakafter"><p>HTTP/2 framing permits two classes of errors:</p></div><div id="rfc.section.5.4.p.2"><ul><li>An error condition that renders the entire connection unusable is a connection error.</li><li>An error in an individual stream is a stream error.</li></ul></div><div id="rfc.section.5.4.p.3"><p>A list of error codes is included in <a href="#ErrorCodes" title="Error Codes">Section 7</a>.</p></div><div id="rfc.section.5.4.p.4"><p>It is possible that an endpoint will encounter frames that would cause multiple errors. Implementations <em class="bcp14">MAY</em> discover multiple errors during processing, but they <em class="bcp14">SHOULD</em> report at most one stream and one connection error as a result.</p></div><div id="rfc.section.5.4.p.5"><p>The first stream error reported for a given stream prevents any other errors on that stream from being reported. In comparison, the protocol permits multiple <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frames, though an endpoint <em class="bcp14">SHOULD</em> report just one type of connection error unless an error is encountered during graceful shutdown. If this occurs, an endpoint <em class="bcp14">MAY</em> send an additional GOAWAY frame with the new error code, in addition to any prior GOAWAY that contained <a href="#NO_ERROR">NO_ERROR</a>.</p></div><div id="rfc.section.5.4.p.6"><p>If an endpoint detects multiple different errors, it <em class="bcp14">MAY</em> choose to report any one of those errors. If a frame causes a connection error, that error <em class="bcp14">MUST</em> be reported. Additionally, an endpoint <em class="bcp14">MAY</em> use any applicable error code when it detects an error condition; a generic error code (such as <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> or <a href="#INTERNAL_ERROR">INTERNAL_ERROR</a>) can always be used in place of more specific error codes.</p></div><section id="ConnectionErrorHandler"><h4 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1.</a>&nbsp;<a href="#ConnectionErrorHandler">Connection Error Handling</a></h4><div id="rfc.section.5.4.1.p.1"><p>A connection error is any error that prevents further processing of the frame layer or corrupts any connection state.</p></div><div id="rfc.section.5.4.1.p.2"><p>An endpoint that encounters a connection error <em class="bcp14">SHOULD</em> first send a <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame (<a href="#GOAWAY" title="GOAWAY">Section 6.8</a>) with the stream identifier of the last stream that it successfully received from its peer. The <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame includes an error code (<a href="#ErrorCodes" title="Error Codes">Section 7</a>) that indicates why the connection is terminating. After sending the <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame for an error condition, the endpoint <em class="bcp14">MUST</em> close the TCP connection.</p></div><div id="rfc.section.5.4.1.p.3"><p>It is possible that the <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> will not be reliably received by the receiving endpoint. In the event of a connection error, <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> only provides a best-effort attempt to communicate with the peer about why the connection is being terminated.</p></div><div id="rfc.section.5.4.1.p.4"><p>An endpoint can end a connection at any time. In particular, an endpoint <em class="bcp14">MAY</em> choose to treat a stream error as a connection error. Endpoints <em class="bcp14">SHOULD</em> send a <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame when ending a connection, providing that circumstances permit it.</p></div></section><section id="StreamErrorHandler"><h4 id="rfc.section.5.4.2"><a href="#rfc.section.5.4.2">5.4.2.</a>&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></h4><div id="rfc.section.5.4.2.p.1"><p>A stream error is an error related to a specific stream that does not affect processing of other streams.</p></div><div id="rfc.section.5.4.2.p.2"><p>An endpoint that detects a stream error sends a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame (<a href="#RST_STREAM" title="RST_STREAM">Section 6.4</a>) that contains the stream identifier of the stream where the error occurred. The <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame includes an error code that indicates the type of error.</p></div><div id="rfc.section.5.4.2.p.3"><p>A <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> is the last frame that an endpoint can send on a stream. The peer that sends the <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame <em class="bcp14">MUST</em> be prepared to receive any frames that were sent or enqueued for sending by the remote peer. These frames can be ignored, except where they modify connection state (such as the state maintained for field section compression (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) or flow control).</p></div><div id="rfc.section.5.4.2.p.4"><p>Normally, an endpoint <em class="bcp14">SHOULD NOT</em> send more than one <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame for any stream. However, an endpoint <em class="bcp14">MAY</em> send additional <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frames if it receives frames on a closed stream after more than a round-trip time. This behavior is permitted to deal with misbehaving implementations.</p></div><div id="rfc.section.5.4.2.p.5"><p>To avoid looping, an endpoint <em class="bcp14">MUST NOT</em> send a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> in response to a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame.</p></div></section><section id="n-connection-termination"><h4 id="rfc.section.5.4.3"><a href="#rfc.section.5.4.3">5.4.3.</a>&nbsp;<a href="#n-connection-termination">Connection Termination</a></h4><div id="rfc.section.5.4.3.p.1"><p>If the TCP connection is closed or reset while streams remain in the "open" or "half-closed" states, then the affected streams cannot be automatically retried (see <a href="#Reliability" title="Request Reliability">Section 8.7</a> for details).</p></div></section></section><section id="extensibility"><h3 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a>&nbsp;<a href="#extensibility">Extending HTTP/2</a></h3><div id="rfc.section.5.5.p.1"><p>HTTP/2 permits extension of the protocol. Within the limitations described in this section, protocol extensions can be used to provide additional services or alter any aspect of the protocol. Extensions are effective only within the scope of a single HTTP/2 connection.</p></div><div id="rfc.section.5.5.p.2"><p>This applies to the protocol elements defined in this document. This does not affect the existing options for extending HTTP, such as defining new methods, status codes, or fields (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-16">Section 16</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</p></div><div id="rfc.section.5.5.p.3"><p>Extensions are permitted to use new frame types (<a href="#FrameHeader" title="Frame Format">Section 4.1</a>), new settings (<a href="#SETTINGS" title="SETTINGS">Section 6.5</a>), or new error codes (<a href="#ErrorCodes" title="Error Codes">Section 7</a>). Registries for managing these extension points are defined in <a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-11">Section 11</a> of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>.</p></div><div id="rfc.section.5.5.p.4"><p>Implementations <em class="bcp14">MUST</em> ignore unknown or unsupported values in all extensible protocol elements. Implementations <em class="bcp14">MUST</em> discard frames that have unknown or unsupported types. This means that any of these extension points can be safely used by extensions without prior arrangement or negotiation. However, extension frames that appear in the middle of a field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) are not permitted; these <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.5.5.p.5"><p>Extensions <em class="bcp14">SHOULD</em> avoid changing protocol elements defined in this document or elements for which no extension mechanism is defined. This includes changes to the layout of frames, additions or changes to the way that frames are composed into HTTP messages (<a href="#HttpFraming" title="HTTP Message Framing">Section 8.1</a>), the definition of pseudo-header fields, or changes to any protocol element that a compliant endpoint might treat as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>).</p></div><div id="rfc.section.5.5.p.6"><p>An extension that changes existing protocol elements or state <em class="bcp14">MUST</em> be negotiated before being used. For example, an extension that changes the layout of the <a href="#HEADERS" title="HEADERS">HEADERS</a> frame cannot be used until the peer has given a positive signal that this is acceptable. In this case, it could also be necessary to coordinate when the revised layout comes into effect. For example, treating frames other than <a href="#DATA" title="DATA">DATA</a> frames as flow controlled requires a change in semantics that both endpoints need to understand, so this can only be done through negotiation.</p></div><div id="rfc.section.5.5.p.7"><p>This document doesn't mandate a specific method for negotiating the use of an extension but notes that a setting (<a href="#SettingValues" title="Defined Settings">Section 6.5.2</a>) could be used for that purpose. If both peers set a value that indicates willingness to use the extension, then the extension can be used. If a setting is used for extension negotiation, the initial value <em class="bcp14">MUST</em> be defined in such a fashion that the extension is initially disabled.</p></div></section></section><hr class="hidden-print"><section id="FrameTypes"><h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#FrameTypes">Frame Definitions</a></h2><div id="rfc.section.6.p.1"><p>This specification defines a number of frame types, each identified by a unique 8-bit type code. Each frame type serves a distinct purpose in the establishment and management of either the connection as a whole or individual streams.</p></div><div id="rfc.section.6.p.2"><p>The transmission of specific frame types can alter the state of a connection. If endpoints fail to maintain a synchronized view of the connection state, successful communication within the connection will no longer be possible. Therefore, it is important that endpoints have a shared comprehension of how the state is affected by the use of any given frame.</p></div><section id="DATA"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a>&nbsp;<a href="#DATA">DATA</a></h3><div id="rfc.section.6.1.p.1"><p>DATA frames (type=0x00) convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response message contents.</p></div><div id="rfc.section.6.1.p.2"><p>DATA frames <em class="bcp14">MAY</em> also contain padding. Padding can be added to DATA frames to obscure the size of messages. Padding is a security feature; see <a href="#padding" title="Use of Padding">Section 10.7</a>.</p></div><div id="DATAFrameFormat"></div><div id="rfc.figure.3"><div><pre class="inline">
DATA Frame {
  Length (24),
  Type (8) = 0x00,

  Unused Flags (4),
  PADDED Flag (1),
  Unused Flags (2),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Data (..),
  Padding (..2040),
}
</pre></div></div><p class="figure">Figure 3: DATA Frame Format</p><div id="rfc.section.6.1.p.3" class="avoidbreakafter"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>. The DATA frame contains the following additional fields:</p></div><div id="rfc.section.6.1.p.4"><dl><dt>Pad Length:</dt><dd style="margin-left: 1.5em">An 8-bit field containing the length of the frame padding in units of octets. This field is conditional and is only present if the PADDED flag is set.</dd><dt>Data:</dt><dd style="margin-left: 1.5em">Application data. The amount of data is the remainder of the frame payload after subtracting the length of the other fields that are present.</dd><dt>Padding:</dt><dd style="margin-left: 1.5em">Padding octets that contain no application semantic value. Padding octets <em class="bcp14">MUST</em> be set to zero when sending. A receiver is not obligated to verify padding but <em class="bcp14">MAY</em> treat non-zero padding as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</dd></dl></div><div id="rfc.section.6.1.p.5" class="avoidbreakafter"><p>The DATA frame defines the following flags:</p></div><div id="rfc.section.6.1.p.6"><dl><dt>PADDED (0x08):</dt><dd style="margin-left: 1.5em">When set, the PADDED flag indicates that the Pad Length field and any padding that it describes are present.</dd><dt>END_STREAM (0x01):</dt><dd style="margin-left: 1.5em">When set, the END_STREAM flag indicates that this frame is the last that the endpoint will send for the identified stream. Setting this flag causes the stream to enter one of the "half-closed" states or the "closed" state (<a href="#StreamStates" title="Stream States">Section 5.1</a>).</dd></dl></div><div id="rfc.section.6.1.p.7"><aside><div id="rfc.section.6.1.p.7.1"><p>Note: An endpoint that learns of stream closure after sending all data can close a stream by sending a STREAM frame with a zero-length Data field and the END_STREAM flag set. This is only possible if the endpoint does not send trailers, as the END_STREAM flag appears on a HEADERS frame in that case; see <a href="#HttpFraming" title="HTTP Message Framing">Section 8.1</a>.</p></div></aside></div><div id="rfc.section.6.1.p.8"><p>DATA frames <em class="bcp14">MUST</em> be associated with a stream. If a DATA frame is received whose Stream Identifier field is 0x00, the recipient <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.1.p.9"><p>DATA frames are subject to flow control and can only be sent when a stream is in the "open" or "half-closed (remote)" state. The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present. If a DATA frame is received whose stream is not in the "open" or "half-closed (local)" state, the recipient <em class="bcp14">MUST</em> respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#STREAM_CLOSED">STREAM_CLOSED</a>.</p></div><div id="rfc.section.6.1.p.10"><p>The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient <em class="bcp14">MUST</em> treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.1.p.11"><aside><div id="rfc.section.6.1.p.11.1"><p>Note: A frame can be increased in size by one octet by including a Pad Length field with a value of zero.</p></div></aside></div></section><section id="HEADERS"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a>&nbsp;<a href="#HEADERS">HEADERS</a></h3><div id="rfc.section.6.2.p.1"><p>The HEADERS frame (type=0x01) is used to open a stream (<a href="#StreamStates" title="Stream States">Section 5.1</a>), and additionally carries a field block fragment. Despite the name, a HEADERS frame can carry a header section or a trailer section. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.</p></div><div id="HEADERSFrameFormat"></div><div id="rfc.figure.4"><div><pre class="inline">
HEADERS Frame {
  Length (24),
  Type (8) = 0x01,

  Unused Flags (2),
  PRIORITY Flag (1),
  Unused Flag (1),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flag (1),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  [Exclusive (1)],
  [Stream Dependency (31)],
  [Weight (8)],
  Field Block Fragment (..),
  Padding (..2040),
}
</pre></div></div><p class="figure">Figure 4: HEADERS Frame Format</p><div id="rfc.section.6.2.p.2" class="avoidbreakafter"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>. The HEADERS frame payload has the following additional fields:</p></div><div id="rfc.section.6.2.p.3"><dl><dt>Pad Length:</dt><dd style="margin-left: 1.5em">An 8-bit field containing the length of the frame padding in units of octets. This field is only present if the PADDED flag is set.</dd><dt>Exclusive:</dt><dd style="margin-left: 1.5em">A single-bit flag. This field is only present if the PRIORITY flag is set. Priority signals in HEADERS frames are deprecated; see <a href="#PriorityHere" title="Priority Signaling in This Document">Section 5.3.2</a>.</dd><dt>Stream Dependency:</dt><dd style="margin-left: 1.5em">A 31-bit stream identifier. This field is only present if the PRIORITY flag is set.</dd><dt>Weight:</dt><dd style="margin-left: 1.5em">An unsigned 8-bit integer. This field is only present if the PRIORITY flag is set.</dd><dt>Field Block Fragment:</dt><dd style="margin-left: 1.5em">A field block fragment (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>).</dd><dt>Padding:</dt><dd style="margin-left: 1.5em">Padding octets that contain no application semantic value. Padding octets <em class="bcp14">MUST</em> be set to zero when sending. A receiver is not obligated to verify padding but <em class="bcp14">MAY</em> treat non-zero padding as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</dd></dl></div><div id="rfc.section.6.2.p.4" class="avoidbreakafter"><p>The HEADERS frame defines the following flags:</p></div><div id="rfc.section.6.2.p.5"><dl><dt>PRIORITY (0x20):</dt><dd style="margin-left: 1.5em"><div>When set, the PRIORITY flag indicates that the Exclusive, Stream Dependency, and Weight fields are present.</div></dd><dt>PADDED (0x08):</dt><dd style="margin-left: 1.5em"><div>When set, the PADDED flag indicates that the Pad Length field and any padding that it describes are present.</div></dd><dt>END_HEADERS (0x04):</dt><dd style="margin-left: 1.5em"><div>When set, the END_HEADERS flag indicates that this frame contains an entire field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) and is not followed by any <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames.</div><div>A HEADERS frame without the END_HEADERS flag set <em class="bcp14">MUST</em> be followed by a <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frame for the same stream. A receiver <em class="bcp14">MUST</em> treat the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div></dd><dt>END_STREAM (0x01):</dt><dd style="margin-left: 1.5em"><div>When set, the END_STREAM flag indicates that the field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) is the last that the endpoint will send for the identified stream.</div><div>A HEADERS frame with the END_STREAM flag set signals the end of a stream. However, a HEADERS frame with the END_STREAM flag set can be followed by <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames on the same stream. Logically, the <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames are part of the HEADERS frame.</div></dd></dl></div><div id="rfc.section.6.2.p.6"><p>The frame payload of a HEADERS frame contains a field block fragment (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>). A field block that does not fit within a HEADERS frame is continued in a CONTINUATION frame (<a href="#CONTINUATION" title="CONTINUATION">Section 6.10</a>).</p></div><div id="rfc.section.6.2.p.7"><p>HEADERS frames <em class="bcp14">MUST</em> be associated with a stream. If a HEADERS frame is received whose Stream Identifier field is 0x00, the recipient <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.2.p.8"><p>The HEADERS frame changes the connection state as described in <a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>.</p></div><div id="rfc.section.6.2.p.9"><p>The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient <em class="bcp14">MUST</em> treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.2.p.10"><aside><div id="rfc.section.6.2.p.10.1"><p>Note: A frame can be increased in size by one octet by including a Pad Length field with a value of zero.</p></div></aside></div></section><section id="PRIORITY"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a>&nbsp;<a href="#PRIORITY">PRIORITY</a></h3><div id="rfc.section.6.3.p.1"><p>The PRIORITY frame (type=0x02) is deprecated; see <a href="#PriorityHere" title="Priority Signaling in This Document">Section 5.3.2</a>. A PRIORITY frame can be sent in any stream state, including idle or closed streams.</p></div><div id="PRIORITYFrameFormat"></div><div id="rfc.figure.5"><div><pre class="inline">
PRIORITY Frame {
  Length (24) = 0x05,
  Type (8) = 0x02,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Exclusive (1),
  Stream Dependency (31),
  Weight (8),
}
</pre></div></div><p class="figure">Figure 5: PRIORITY Frame Format</p><div id="rfc.section.6.3.p.2" class="avoidbreakafter"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>. The frame payload of a PRIORITY frame contains the following additional fields:</p></div><div id="rfc.section.6.3.p.3"><dl><dt>Exclusive:</dt><dd style="margin-left: 1.5em">A single-bit flag.</dd><dt>Stream Dependency:</dt><dd style="margin-left: 1.5em">A 31-bit stream identifier.</dd><dt>Weight:</dt><dd style="margin-left: 1.5em">An unsigned 8-bit integer.</dd></dl></div><div id="rfc.section.6.3.p.4"><p>The PRIORITY frame does not define any flags.</p></div><div id="rfc.section.6.3.p.5"><p>The PRIORITY frame always identifies a stream. If a PRIORITY frame is received with a stream identifier of 0x00, the recipient <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.3.p.6"><p>Sending or receiving a PRIORITY frame does not affect the state of any stream (<a href="#StreamStates" title="Stream States">Section 5.1</a>). The PRIORITY frame can be sent on a stream in any state, including "idle" or "closed". A PRIORITY frame cannot be sent between consecutive frames that comprise a single field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>).</p></div><div id="rfc.section.6.3.p.7"><p>A PRIORITY frame with a length other than 5 octets <em class="bcp14">MUST</em> be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>.</p></div></section><section id="RST_STREAM"><h3 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a>&nbsp;<a href="#RST_STREAM">RST_STREAM</a></h3><div id="rfc.section.6.4.p.1"><p>The RST_STREAM frame (type=0x03) allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.</p></div><div id="RST_STREAMFrameFormat"></div><div id="rfc.figure.6"><div><pre class="inline">
RST_STREAM Frame {
  Length (24) = 0x04,
  Type (8) = 0x03,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Error Code (32),
}
</pre></div></div><p class="figure">Figure 6: RST_STREAM Frame Format</p><div id="rfc.section.6.4.p.2"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>. Additionally, the RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error code (<a href="#ErrorCodes" title="Error Codes">Section 7</a>). The error code indicates why the stream is being terminated.</p></div><div id="rfc.section.6.4.p.3"><p>The RST_STREAM frame does not define any flags.</p></div><div id="rfc.section.6.4.p.4"><p>The RST_STREAM frame fully terminates the referenced stream and causes it to enter the "closed" state. After receiving a RST_STREAM on a stream, the receiver <em class="bcp14">MUST NOT</em> send additional frames for that stream, except for <a href="#PRIORITY" title="PRIORITY">PRIORITY</a>. However, after sending the RST_STREAM, the sending endpoint <em class="bcp14">MUST</em> be prepared to receive and process additional frames sent on the stream that might have been sent by the peer prior to the arrival of the RST_STREAM.</p></div><div id="rfc.section.6.4.p.5"><p>RST_STREAM frames <em class="bcp14">MUST</em> be associated with a stream. If a RST_STREAM frame is received with a stream identifier of 0x00, the recipient <em class="bcp14">MUST</em> treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.4.p.6"><p>RST_STREAM frames <em class="bcp14">MUST NOT</em> be sent for a stream in the "idle" state. If a RST_STREAM frame identifying an idle stream is received, the recipient <em class="bcp14">MUST</em> treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.4.p.7"><p>A RST_STREAM frame with a length other than 4 octets <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>.</p></div></section><section id="SETTINGS"><h3 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a>&nbsp;<a href="#SETTINGS">SETTINGS</a></h3><div id="rfc.section.6.5.p.1"><p>The SETTINGS frame (type=0x04) conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those settings. Individually, a configuration parameter from a SETTINGS frame is referred to as a "setting".</p></div><div id="rfc.section.6.5.p.2"><p>Settings are not negotiated; they describe characteristics of the sending peer, which are used by the receiving peer. Different values for the same setting can be advertised by each peer. For example, a client might set a high initial flow-control window, whereas a server might set a lower value to conserve resources.</p></div><div id="rfc.section.6.5.p.3"><p>A SETTINGS frame <em class="bcp14">MUST</em> be sent by both endpoints at the start of a connection and <em class="bcp14">MAY</em> be sent at any other time by either endpoint over the lifetime of the connection. Implementations <em class="bcp14">MUST</em> support all of the settings defined by this specification.</p></div><div id="rfc.section.6.5.p.4"><p>Each parameter in a SETTINGS frame replaces any existing value for that parameter. Settings are processed in the order in which they appear, and a receiver of a SETTINGS frame does not need to maintain any state other than the current value of each setting. Therefore, the value of a SETTINGS parameter is the last value that is seen by a receiver.</p></div><div id="rfc.section.6.5.p.5" class="avoidbreakafter"><p>SETTINGS frames are acknowledged by the receiving peer. To enable this, the SETTINGS frame defines the ACK flag:</p></div><div id="rfc.section.6.5.p.6"><dl><dt>ACK (0x01):</dt><dd style="margin-left: 1.5em">When set, the ACK flag indicates that this frame acknowledges receipt and application of the peer's SETTINGS frame. When this bit is set, the frame payload of the SETTINGS frame <em class="bcp14">MUST</em> be empty. Receipt of a SETTINGS frame with the ACK flag set and a length field value other than 0 <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>. For more information, see <a href="#SettingsSync" title="Settings Synchronization">Section 6.5.3</a> ("<a href="#SettingsSync" title="Settings Synchronization">Settings Synchronization</a>").</dd></dl></div><div id="rfc.section.6.5.p.7"><p>SETTINGS frames always apply to a connection, never a single stream. The stream identifier for a SETTINGS frame <em class="bcp14">MUST</em> be zero (0x00). If an endpoint receives a SETTINGS frame whose Stream Identifier field is anything other than 0x00, the endpoint <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.5.p.8"><p>The SETTINGS frame affects connection state. A badly formed or incomplete SETTINGS frame <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.5.p.9"><p>A SETTINGS frame with a length other than a multiple of 6 octets <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>.</p></div><section id="SettingFormat"><h4 id="rfc.section.6.5.1"><a href="#rfc.section.6.5.1">6.5.1.</a>&nbsp;<a href="#SettingFormat">SETTINGS Format</a></h4><div id="rfc.section.6.5.1.p.1"><p>The frame payload of a SETTINGS frame consists of zero or more settings, each consisting of an unsigned 16-bit setting identifier and an unsigned 32-bit value.</p></div><div id="SettingFrameFormat"></div><div id="rfc.figure.7"><div><pre class="inline">
SETTINGS Frame {
  Length (24),
  Type (8) = 0x04,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Setting (48) ...,
}

Setting {
  Identifier (16),
  Value (32),
}
</pre></div></div><p class="figure">Figure 7: SETTINGS Frame Format</p><div id="rfc.section.6.5.1.p.2" class="avoidbreakafter"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>. The frame payload of a SETTINGS frame contains any number of Setting fields, each of which consists of:</p></div><div id="rfc.section.6.5.1.p.3"><dl><dt>Identifier:</dt><dd style="margin-left: 1.5em">A 16-bit setting identifier; see <a href="#SettingValues" title="Defined Settings">Section 6.5.2</a>.</dd><dt>Value:</dt><dd style="margin-left: 1.5em">A 32-bit value for the setting.</dd></dl></div></section><section id="SettingValues"><h4 id="rfc.section.6.5.2"><a href="#rfc.section.6.5.2">6.5.2.</a>&nbsp;<a href="#SettingValues">Defined Settings</a></h4><div id="rfc.section.6.5.2.p.1" class="avoidbreakafter"><p>The following settings are defined:</p></div><div id="rfc.section.6.5.2.p.2"><dl><dt id="SETTINGS_HEADER_TABLE_SIZE">SETTINGS_HEADER_TABLE_SIZE (0x01):</dt><dd style="margin-left: 1.5em"><div>This setting allows the sender to inform the remote endpoint of the maximum size of the compression table used to decode field blocks, in units of octets. The encoder can select any size equal to or less than this value by using signaling specific to the compression format inside a field block (see <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>). The initial value is 4,096 octets.</div></dd><dt id="SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH (0x02):</dt><dd style="margin-left: 1.5em"><div>This setting can be used to enable or disable server push. A server <em class="bcp14">MUST NOT</em> send a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame if it receives this parameter set to a value of 0; see <a href="#PushResources" title="Server Push">Section 8.4</a>. A client that has both set this parameter to 0 and had it acknowledged <em class="bcp14">MUST</em> treat the receipt of a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div><div>The initial value of SETTINGS_ENABLE_PUSH is 1. For a client, this value indicates that it is willing to receive PUSH_PROMISE frames. For a server, this initial value has no effect, and is equivalent to the value 0. Any value other than 0 or 1 <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div><div>A server <em class="bcp14">MUST NOT</em> explicitly set this value to 1. A server <em class="bcp14">MAY</em> choose to omit this setting when it sends a SETTINGS frame, but if a server does include a value, it <em class="bcp14">MUST</em> be 0. A client <em class="bcp14">MUST</em> treat receipt of a SETTINGS frame with SETTINGS_ENABLE_PUSH set to 1 as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div></dd><dt id="SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS (0x03):</dt><dd style="margin-left: 1.5em"><div>This setting indicates the maximum number of concurrent streams that the sender will allow. This limit is directional: it applies to the number of streams that the sender permits the receiver to create. Initially, there is no limit to this value. It is recommended that this value be no smaller than 100, so as to not unnecessarily limit parallelism.</div><div>A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS <em class="bcp14">SHOULD NOT</em> be treated as special by endpoints. A zero value does prevent the creation of new streams; however, this can also happen for any limit that is exhausted with active streams. Servers <em class="bcp14">SHOULD</em> only set a zero value for short durations; if a server does not wish to accept requests, closing the connection is more appropriate.</div></dd><dt id="SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE (0x04):</dt><dd style="margin-left: 1.5em"><div>This setting indicates the sender's initial window size (in units of octets) for stream-level flow control. The initial value is 2<sup>16</sup>-1 (65,535) octets.</div><div>This setting affects the window size of all streams (see <a href="#InitialWindowSize" title="Initial Flow-Control Window Size">Section 6.9.2</a>).</div><div>Values above the maximum flow-control window size of 2<sup>31</sup>-1 <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a>.</div></dd><dt id="SETTINGS_MAX_FRAME_SIZE">SETTINGS_MAX_FRAME_SIZE (0x05):</dt><dd style="margin-left: 1.5em"><div>This setting indicates the size of the largest frame payload that the sender is willing to receive, in units of octets.</div><div>The initial value is 2<sup>14</sup> (16,384) octets. The value advertised by an endpoint <em class="bcp14">MUST</em> be between this initial value and the maximum allowed frame size (2<sup>24</sup>-1 or 16,777,215 octets), inclusive. Values outside this range <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div></dd><dt id="SETTINGS_MAX_HEADER_LIST_SIZE">SETTINGS_MAX_HEADER_LIST_SIZE (0x06):</dt><dd style="margin-left: 1.5em"><div>This advisory setting informs a peer of the maximum field section size that the sender is prepared to accept, in units of octets. The value is based on the uncompressed size of field lines, including the length of the name and value in units of octets plus an overhead of 32 octets for each field line.</div><div>For any given request, a lower limit than what is advertised <em class="bcp14">MAY</em> be enforced. The initial value of this setting is unlimited.</div></dd></dl></div><div id="rfc.section.6.5.2.p.3"><p>An endpoint that receives a SETTINGS frame with any unknown or unsupported identifier <em class="bcp14">MUST</em> ignore that setting.</p></div></section><section id="SettingsSync"><h4 id="rfc.section.6.5.3"><a href="#rfc.section.6.5.3">6.5.3.</a>&nbsp;<a href="#SettingsSync">Settings Synchronization</a></h4><div id="rfc.section.6.5.3.p.1"><p>Most values in SETTINGS benefit from or require an understanding of when the peer has received and applied the changed parameter values. In order to provide such synchronization timepoints, the recipient of a SETTINGS frame in which the ACK flag is not set <em class="bcp14">MUST</em> apply the updated settings as soon as possible upon receipt. SETTINGS frames are acknowledged in the order in which they are received.</p></div><div id="rfc.section.6.5.3.p.2"><p>The values in the SETTINGS frame <em class="bcp14">MUST</em> be processed in the order they appear, with no other frame processing between values. Unsupported settings <em class="bcp14">MUST</em> be ignored. Once all values have been processed, the recipient <em class="bcp14">MUST</em> immediately emit a SETTINGS frame with the ACK flag set. Upon receiving a SETTINGS frame with the ACK flag set, the sender of the altered settings can rely on the values from the oldest unacknowledged SETTINGS frame having been applied.</p></div><div id="rfc.section.6.5.3.p.3"><p>If the sender of a SETTINGS frame does not receive an acknowledgment within a reasonable amount of time, it <em class="bcp14">MAY</em> issue a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#SETTINGS_TIMEOUT">SETTINGS_TIMEOUT</a>. In setting a timeout, some allowance needs to be made for processing delays at the peer; a timeout that is solely based on the round-trip time between endpoints might result in spurious errors.</p></div></section></section><section id="PUSH_PROMISE"><h3 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a>&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></h3><div id="rfc.section.6.6.p.1"><p>The PUSH_PROMISE frame (type=0x05) is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a field section that provides additional context for the stream. <a href="#PushResources" title="Server Push">Section 8.4</a> contains a thorough description of the use of PUSH_PROMISE frames.</p></div><div id="PUSH_PROMISEFrameFormat"></div><div id="rfc.figure.8"><div><pre class="inline">
PUSH_PROMISE Frame {
  Length (24),
  Type (8) = 0x05,

  Unused Flags (4),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Reserved (1),
  Promised Stream ID (31),
  Field Block Fragment (..),
  Padding (..2040),
}
</pre></div></div><p class="figure">Figure 8: PUSH_PROMISE Frame Format</p><div id="rfc.section.6.6.p.2" class="avoidbreakafter"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>. The PUSH_PROMISE frame payload has the following additional fields:</p></div><div id="rfc.section.6.6.p.3"><dl><dt>Pad Length:</dt><dd style="margin-left: 1.5em">An 8-bit field containing the length of the frame padding in units of octets. This field is only present if the PADDED flag is set.</dd><dt>Promised Stream ID:</dt><dd style="margin-left: 1.5em">An unsigned 31-bit integer that identifies the stream that is reserved by the PUSH_PROMISE. The promised stream identifier <em class="bcp14">MUST</em> be a valid choice for the next stream sent by the sender (see "new stream identifier" in <a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>).</dd><dt>Field Block Fragment:</dt><dd style="margin-left: 1.5em">A field block fragment (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) containing the request control data and a header section.</dd><dt>Padding:</dt><dd style="margin-left: 1.5em">Padding octets that contain no application semantic value. Padding octets <em class="bcp14">MUST</em> be set to zero when sending. A receiver is not obligated to verify padding but <em class="bcp14">MAY</em> treat non-zero padding as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</dd></dl></div><div id="rfc.section.6.6.p.4" class="avoidbreakafter"><p>The PUSH_PROMISE frame defines the following flags:</p></div><div id="rfc.section.6.6.p.5"><dl><dt>PADDED (0x08):</dt><dd style="margin-left: 1.5em"><div>When set, the PADDED flag indicates that the Pad Length field and any padding that it describes are present.</div></dd><dt>END_HEADERS (0x04):</dt><dd style="margin-left: 1.5em"><div>When set, the END_HEADERS flag indicates that this frame contains an entire field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) and is not followed by any <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames.</div><div>A PUSH_PROMISE frame without the END_HEADERS flag set <em class="bcp14">MUST</em> be followed by a CONTINUATION frame for the same stream. A receiver <em class="bcp14">MUST</em> treat the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div></dd></dl></div><div id="rfc.section.6.6.p.6"><p>PUSH_PROMISE frames <em class="bcp14">MUST</em> only be sent on a peer-initiated stream that is in either the "open" or "half-closed (remote)" state. The stream identifier of a PUSH_PROMISE frame indicates the stream it is associated with. If the Stream Identifier field specifies the value 0x00, a recipient <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.6.p.7"><p>Promised streams are not required to be used in the order they are promised. The PUSH_PROMISE only reserves stream identifiers for later use.</p></div><div id="rfc.section.6.6.p.8"><p>PUSH_PROMISE <em class="bcp14">MUST NOT</em> be sent if the <a href="#SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH</a> setting of the peer endpoint is set to 0. An endpoint that has set this setting and has received acknowledgment <em class="bcp14">MUST</em> treat the receipt of a PUSH_PROMISE frame as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.6.p.9"><p>Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> referencing the promised stream identifier back to the sender of the PUSH_PROMISE.</p></div><div id="rfc.section.6.6.p.10"><p>A PUSH_PROMISE frame modifies the connection state in two ways. First, the inclusion of a field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) potentially modifies the state maintained for field section compression. Second, PUSH_PROMISE also reserves a stream for later use, causing the promised stream to enter the "reserved (local)" or "reserved (remote)" state. A sender <em class="bcp14">MUST NOT</em> send a PUSH_PROMISE on a stream unless that stream is either "open" or "half-closed (remote)"; the sender <em class="bcp14">MUST</em> ensure that the promised stream is a valid choice for a new stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>) (that is, the promised stream <em class="bcp14">MUST</em> be in the "idle" state).</p></div><div id="rfc.section.6.6.p.11"><p>Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame causes the stream state to become indeterminate. A receiver <em class="bcp14">MUST</em> treat the receipt of a PUSH_PROMISE on a stream that is neither "open" nor "half-closed (local)" as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. However, an endpoint that has sent <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> on the associated stream <em class="bcp14">MUST</em> handle PUSH_PROMISE frames that might have been created before the <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame is received and processed.</p></div><div id="rfc.section.6.6.p.12"><p>A receiver <em class="bcp14">MUST</em> treat the receipt of a PUSH_PROMISE that promises an illegal stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>) as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. Note that an illegal stream identifier is an identifier for a stream that is not currently in the "idle" state.</p></div><div id="rfc.section.6.6.p.13"><p>The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient <em class="bcp14">MUST</em> treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.6.p.14"><aside><div id="rfc.section.6.6.p.14.1"><p>Note: A frame can be increased in size by one octet by including a Pad Length field with a value of zero.</p></div></aside></div></section><section id="PING"><h3 id="rfc.section.6.7"><a href="#rfc.section.6.7">6.7.</a>&nbsp;<a href="#PING">PING</a></h3><div id="rfc.section.6.7.p.1"><p>The PING frame (type=0x06) is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.</p></div><div id="PINGFrameFormat"></div><div id="rfc.figure.9"><div><pre class="inline">
PING Frame {
  Length (24) = 0x08,
  Type (8) = 0x06,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Opaque Data (64),
}
</pre></div></div><p class="figure">Figure 9: PING Frame Format</p><div id="rfc.section.6.7.p.2"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>.</p></div><div id="rfc.section.6.7.p.3"><p>In addition to the frame header, PING frames <em class="bcp14">MUST</em> contain 8 octets of opaque data in the frame payload. A sender can include any value it chooses and use those octets in any fashion.</p></div><div id="rfc.section.6.7.p.4"><p>Receivers of a PING frame that does not include an ACK flag <em class="bcp14">MUST</em> send a PING frame with the ACK flag set in response, with an identical frame payload. PING responses <em class="bcp14">SHOULD</em> be given higher priority than any other frame.</p></div><div id="rfc.section.6.7.p.5" class="avoidbreakafter"><p>The PING frame defines the following flags:</p></div><div id="rfc.section.6.7.p.6"><dl><dt>ACK (0x01):</dt><dd style="margin-left: 1.5em">When set, the ACK flag indicates that this PING frame is a PING response. An endpoint <em class="bcp14">MUST</em> set this flag in PING responses. An endpoint <em class="bcp14">MUST NOT</em> respond to PING frames containing this flag.</dd></dl></div><div id="rfc.section.6.7.p.7"><p>PING frames are not associated with any individual stream. If a PING frame is received with a Stream Identifier field value other than 0x00, the recipient <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.7.p.8"><p>Receipt of a PING frame with a length field value other than 8 <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>.</p></div></section><section id="GOAWAY"><h3 id="rfc.section.6.8"><a href="#rfc.section.6.8">6.8.</a>&nbsp;<a href="#GOAWAY">GOAWAY</a></h3><div id="rfc.section.6.8.p.1"><p>The GOAWAY frame (type=0x07) is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.</p></div><div id="rfc.section.6.8.p.2"><p>There is an inherent race condition between an endpoint starting new streams and the remote peer sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.</p></div><div id="rfc.section.6.8.p.3"><p>Once the GOAWAY is sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame <em class="bcp14">MUST NOT</em> open additional streams on the connection, although a new connection can be established for new streams.</p></div><div id="rfc.section.6.8.p.4"><p>If the receiver of the GOAWAY has sent data on streams with a higher stream identifier than what is indicated in the GOAWAY frame, those streams are not or will not be processed. The receiver of the GOAWAY frame can treat the streams as though they had never been created at all, thereby allowing those streams to be retried later on a new connection.</p></div><div id="rfc.section.6.8.p.5"><p>Endpoints <em class="bcp14">SHOULD</em> always send a GOAWAY frame before closing a connection so that the remote peer can know whether a stream has been partially processed or not. For example, if an HTTP client sends a POST at the same time that a server closes a connection, the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate what streams it might have acted on.</p></div><div id="rfc.section.6.8.p.6"><p>An endpoint might choose to close a connection without sending a GOAWAY for misbehaving peers.</p></div><div id="rfc.section.6.8.p.7"><p>A GOAWAY frame might not immediately precede closing of the connection; a receiver of a GOAWAY that has no more use for the connection <em class="bcp14">SHOULD</em> still send a GOAWAY frame before terminating the connection.</p></div><div id="GOAWAYFrameFormat"></div><div id="rfc.figure.10"><div><pre class="inline">
GOAWAY Frame {
  Length (24),
  Type (8) = 0x07,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31) = 0,

  Reserved (1),
  Last-Stream-ID (31),
  Error Code (32),
  Additional Debug Data (..),
}
</pre></div></div><p class="figure">Figure 10: GOAWAY Frame Format</p><div id="rfc.section.6.8.p.8"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>.</p></div><div id="rfc.section.6.8.p.9"><p>The GOAWAY frame does not define any flags.</p></div><div id="rfc.section.6.8.p.10"><p>The GOAWAY frame applies to the connection, not a specific stream. An endpoint <em class="bcp14">MUST</em> treat a <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame with a stream identifier other than 0x00 as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.8.p.11"><p>The last stream identifier in the GOAWAY frame contains the highest-numbered stream identifier for which the sender of the GOAWAY frame might have taken some action on or might yet take action on. All streams up to and including the identified stream might have been processed in some way. The last stream identifier can be set to 0 if no streams were processed.</p></div><div id="rfc.section.6.8.p.12"><aside><div id="rfc.section.6.8.p.12.1"><p>Note: In this context, "processed" means that some data from the stream was passed to some higher layer of software that might have taken some action as a result.</p></div></aside></div><div id="rfc.section.6.8.p.13"><p>If a connection terminates without a GOAWAY frame, the last stream identifier is effectively the highest possible stream identifier.</p></div><div id="rfc.section.6.8.p.14"><p>On streams with lower- or equal-numbered identifiers that were not closed completely prior to the connection being closed, reattempting requests, transactions, or any protocol activity is not possible, except for idempotent actions like HTTP GET, PUT, or DELETE. Any protocol activity that uses higher-numbered streams can be safely retried using a new connection.</p></div><div id="rfc.section.6.8.p.15"><p>Activity on streams numbered lower than or equal to the last stream identifier might still complete successfully. The sender of a GOAWAY frame might gracefully shut down a connection by sending a GOAWAY frame, maintaining the connection in an "open" state until all in-progress streams complete.</p></div><div id="rfc.section.6.8.p.16"><p>An endpoint <em class="bcp14">MAY</em> send multiple GOAWAY frames if circumstances change. For instance, an endpoint that sends GOAWAY with <a href="#NO_ERROR">NO_ERROR</a> during graceful shutdown could subsequently encounter a condition that requires immediate termination of the connection. The last stream identifier from the last GOAWAY frame received indicates which streams could have been acted upon. Endpoints <em class="bcp14">MUST NOT</em> increase the value they send in the last stream identifier, since the peers might already have retried unprocessed requests on another connection.</p></div><div id="rfc.section.6.8.p.17"><p>A client that is unable to retry requests loses all requests that are in flight when the server closes the connection. This is especially true for intermediaries that might not be serving clients using HTTP/2. A server that is attempting to gracefully shut down a connection <em class="bcp14">SHOULD</em> send an initial GOAWAY frame with the last stream identifier set to 2<sup>31</sup>-1 and a <a href="#NO_ERROR">NO_ERROR</a> code. This signals to the client that a shutdown is imminent and that initiating further requests is prohibited. After allowing time for any in-flight stream creation (at least one round-trip time), the server <em class="bcp14">MAY</em> send another GOAWAY frame with an updated last stream identifier. This ensures that a connection can be cleanly shut down without losing requests.</p></div><div id="rfc.section.6.8.p.18"><p>After sending a GOAWAY frame, the sender can discard frames for streams initiated by the receiver with identifiers higher than the identified last stream. However, any frames that alter connection state cannot be completely ignored. For instance, <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>, and <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames <em class="bcp14">MUST</em> be minimally processed to ensure that the state maintained for field section compression is consistent (see <a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>); similarly, DATA frames <em class="bcp14">MUST</em> be counted toward the connection flow-control window. Failure to process these frames can cause flow control or field section compression state to become unsynchronized.</p></div><div id="rfc.section.6.8.p.19"><p>The GOAWAY frame also contains a 32-bit error code (<a href="#ErrorCodes" title="Error Codes">Section 7</a>) that contains the reason for closing the connection.</p></div><div id="rfc.section.6.8.p.20"><p>Endpoints <em class="bcp14">MAY</em> append opaque data to the frame payload of any GOAWAY frame. Additional debug data is intended for diagnostic purposes only and carries no semantic value. Debug information could contain security- or privacy-sensitive data. Logged or otherwise persistently stored debug data <em class="bcp14">MUST</em> have adequate safeguards to prevent unauthorized access.</p></div></section><section id="WINDOW_UPDATE"><h3 id="rfc.section.6.9"><a href="#rfc.section.6.9">6.9.</a>&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a></h3><div id="rfc.section.6.9.p.1"><p>The WINDOW_UPDATE frame (type=0x08) is used to implement flow control; see <a href="#FlowControl" title="Flow Control">Section 5.2</a> for an overview.</p></div><div id="rfc.section.6.9.p.2"><p>Flow control operates at two levels: on each individual stream and on the entire connection.</p></div><div id="rfc.section.6.9.p.3"><p>Both types of flow control are hop by hop, that is, only between the two endpoints. Intermediaries do not forward WINDOW_UPDATE frames between dependent connections. However, throttling of data transfer by any receiver can indirectly cause the propagation of flow-control information toward the original sender.</p></div><div id="rfc.section.6.9.p.4"><p>Flow control only applies to frames that are identified as being subject to flow control. Of the frame types defined in this document, this includes only <a href="#DATA" title="DATA">DATA</a> frames. Frames that are exempt from flow control <em class="bcp14">MUST</em> be accepted and processed, unless the receiver is unable to assign resources to handling the frame. A receiver <em class="bcp14">MAY</em> respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) or connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a> if it is unable to accept a frame.</p></div><div id="WINDOW_UPDATEFrameFormat"></div><div id="rfc.figure.11"><div><pre class="inline">
WINDOW_UPDATE Frame {
  Length (24) = 0x04,
  Type (8) = 0x08,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Reserved (1),
  Window Size Increment (31),
}
</pre></div></div><p class="figure">Figure 11: WINDOW_UPDATE Frame Format</p><div id="rfc.section.6.9.p.5"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>. The frame payload of a WINDOW_UPDATE frame is one reserved bit plus an unsigned 31-bit integer indicating the number of octets that the sender can transmit in addition to the existing flow-control window. The legal range for the increment to the flow-control window is 1 to 2<sup>31</sup>-1 (2,147,483,647) octets.</p></div><div id="rfc.section.6.9.p.6"><p>The WINDOW_UPDATE frame does not define any flags.</p></div><div id="rfc.section.6.9.p.7"><p>The WINDOW_UPDATE frame can be specific to a stream or to the entire connection. In the former case, the frame's stream identifier indicates the affected stream; in the latter, the value "0" indicates that the entire connection is the subject of the frame.</p></div><div id="rfc.section.6.9.p.8"><p>A receiver <em class="bcp14">MUST</em> treat the receipt of a WINDOW_UPDATE frame with a flow-control window increment of 0 as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>; errors on the connection flow-control window <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>).</p></div><div id="rfc.section.6.9.p.9"><p>WINDOW_UPDATE can be sent by a peer that has sent a frame with the END_STREAM flag set. This means that a receiver could receive a WINDOW_UPDATE frame on a stream in a "half-closed (remote)" or "closed" state. A receiver <em class="bcp14">MUST NOT</em> treat this as an error (see <a href="#StreamStates" title="Stream States">Section 5.1</a>).</p></div><div id="rfc.section.6.9.p.10"><p>A receiver that receives a flow-controlled frame <em class="bcp14">MUST</em> always account for its contribution against the connection flow-control window, unless the receiver treats this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>). This is necessary even if the frame is in error. The sender counts the frame toward the flow-control window, but if the receiver does not, the flow-control window at the sender and receiver can become different.</p></div><div id="rfc.section.6.9.p.11"><p>A WINDOW_UPDATE frame with a length other than 4 octets <em class="bcp14">MUST</em> be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>.</p></div><section id="n-the-flow-control-window"><h4 id="rfc.section.6.9.1"><a href="#rfc.section.6.9.1">6.9.1.</a>&nbsp;<a href="#n-the-flow-control-window">The Flow-Control Window</a></h4><div id="rfc.section.6.9.1.p.1"><p>Flow control in HTTP/2 is implemented using a window kept by each sender on every stream. The flow-control window is a simple integer value that indicates how many octets of data the sender is permitted to transmit; as such, its size is a measure of the buffering capacity of the receiver.</p></div><div id="rfc.section.6.9.1.p.2"><p>Two flow-control windows are applicable: the stream flow-control window and the connection flow-control window. The sender <em class="bcp14">MUST NOT</em> send a flow-controlled frame with a length that exceeds the space available in either of the flow-control windows advertised by the receiver. Frames with zero length with the END_STREAM flag set (that is, an empty <a href="#DATA" title="DATA">DATA</a> frame) <em class="bcp14">MAY</em> be sent if there is no available space in either flow-control window.</p></div><div id="rfc.section.6.9.1.p.3"><p>For flow-control calculations, the 9-octet frame header is not counted.</p></div><div id="rfc.section.6.9.1.p.4"><p>After sending a flow-controlled frame, the sender reduces the space available in both windows by the length of the transmitted frame.</p></div><div id="rfc.section.6.9.1.p.5"><p>The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up space in flow-control windows. Separate WINDOW_UPDATE frames are sent for the stream- and connection-level flow-control windows. Receivers are advised to have mechanisms in place to avoid sending WINDOW_UPDATE frames with very small increments; see <a href="https://www.rfc-editor.org/rfc/rfc1122.html#section-4.2.3.3">Section 4.2.3.3</a> of <a href="#RFC1122"><cite title="Requirements for Internet Hosts - Communication Layers">[RFC1122]</cite></a>.</p></div><div id="rfc.section.6.9.1.p.6"><p>A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the amount specified in the frame.</p></div><div id="rfc.section.6.9.1.p.7"><p>A sender <em class="bcp14">MUST NOT</em> allow a flow-control window to exceed 2<sup>31</sup>-1 octets. If a sender receives a WINDOW_UPDATE that causes a flow-control window to exceed this maximum, it <em class="bcp14">MUST</em> terminate either the stream or the connection, as appropriate. For streams, the sender sends a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> with an error code of <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a>; for the connection, a <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame with an error code of <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a> is sent.</p></div><div id="rfc.section.6.9.1.p.8"><p>Flow-controlled frames from the sender and WINDOW_UPDATE frames from the receiver are completely asynchronous with respect to each other. This property allows a receiver to aggressively update the window size kept by the sender to prevent streams from stalling.</p></div></section><section id="InitialWindowSize"><h4 id="rfc.section.6.9.2"><a href="#rfc.section.6.9.2">6.9.2.</a>&nbsp;<a href="#InitialWindowSize">Initial Flow-Control Window Size</a></h4><div id="rfc.section.6.9.2.p.1"><p>When an HTTP/2 connection is first established, new streams are created with an initial flow-control window size of 65,535 octets. The connection flow-control window is also 65,535 octets. Both endpoints can adjust the initial window size for new streams by including a value for <a href="#SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE</a> in the <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame. The connection flow-control window can only be changed using WINDOW_UPDATE frames.</p></div><div id="rfc.section.6.9.2.p.2"><p>Prior to receiving a <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame that sets a value for <a href="#SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE</a>, an endpoint can only use the default initial window size when sending flow-controlled frames. Similarly, the connection flow-control window is set based on the default initial window size until a WINDOW_UPDATE frame is received.</p></div><div id="rfc.section.6.9.2.p.3"><p>In addition to changing the flow-control window for streams that are not yet active, a <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the "open" or "half-closed (remote)" state). When the value of <a href="#SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE</a> changes, a receiver <em class="bcp14">MUST</em> adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.</p></div><div id="rfc.section.6.9.2.p.4"><p>A change to <a href="#SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE</a> can cause the available space in a flow-control window to become negative. A sender <em class="bcp14">MUST</em> track the negative flow-control window and <em class="bcp14">MUST NOT</em> send new flow-controlled frames until it receives WINDOW_UPDATE frames that cause the flow-control window to become positive.</p></div><div id="rfc.section.6.9.2.p.5"><p>For example, if the client sends 60 KB immediately on connection establishment and the server sets the initial window size to be 16 KB, the client will recalculate the available flow-control window to be -44 KB on receipt of the <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame. The client retains a negative flow-control window until WINDOW_UPDATE frames restore the window to being positive, after which the client can resume sending.</p></div><div id="rfc.section.6.9.2.p.6"><p>A <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame cannot alter the connection flow-control window.</p></div><div id="rfc.section.6.9.2.p.7"><p>An endpoint <em class="bcp14">MUST</em> treat a change to <a href="#SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE</a> that causes any flow-control window to exceed the maximum size as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a>.</p></div></section><section id="n-reducing-the-stream-window-size"><h4 id="rfc.section.6.9.3"><a href="#rfc.section.6.9.3">6.9.3.</a>&nbsp;<a href="#n-reducing-the-stream-window-size">Reducing the Stream Window Size</a></h4><div id="rfc.section.6.9.3.p.1"><p>A receiver that wishes to use a smaller flow-control window than the current size can send a new <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame. However, the receiver <em class="bcp14">MUST</em> be prepared to receive data that exceeds this window size, since the sender might send data that exceeds the lower limit prior to processing the <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame.</p></div><div id="rfc.section.6.9.3.p.2"><p>After sending a SETTINGS frame that reduces the initial flow-control window size, a receiver <em class="bcp14">MAY</em> continue to process streams that exceed flow-control limits. Allowing streams to continue does not allow the receiver to immediately reduce the space it reserves for flow-control windows. Progress on these streams can also stall, since <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frames are needed to allow the sender to resume sending. The receiver <em class="bcp14">MAY</em> instead send a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> with an error code of <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a> for the affected streams.</p></div></section></section><section id="CONTINUATION"><h3 id="rfc.section.6.10"><a href="#rfc.section.6.10">6.10.</a>&nbsp;<a href="#CONTINUATION">CONTINUATION</a></h3><div id="rfc.section.6.10.p.1"><p>The CONTINUATION frame (type=0x09) is used to continue a sequence of field block fragments (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>). Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>, or CONTINUATION frame without the END_HEADERS flag set.</p></div><div id="CONTINUATIONFrameFormat"></div><div id="rfc.figure.12"><div><pre class="inline">
CONTINUATION Frame {
  Length (24),
  Type (8) = 0x09,

  Unused Flags (5),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  Field Block Fragment (..),
}
</pre></div></div><p class="figure">Figure 12: CONTINUATION Frame Format</p><div id="rfc.section.6.10.p.2"><p>The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <a href="#FramingLayer" title="HTTP Frames">Section 4</a>. The CONTINUATION frame payload contains a field block fragment (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>).</p></div><div id="rfc.section.6.10.p.3" class="avoidbreakafter"><p>The CONTINUATION frame defines the following flag:</p></div><div id="rfc.section.6.10.p.4"><dl><dt>END_HEADERS (0x04):</dt><dd style="margin-left: 1.5em"><div>When set, the END_HEADERS flag indicates that this frame ends a field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>).</div><div>If the END_HEADERS flag is not set, this frame <em class="bcp14">MUST</em> be followed by another CONTINUATION frame. A receiver <em class="bcp14">MUST</em> treat the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</div></dd></dl></div><div id="rfc.section.6.10.p.5"><p>The CONTINUATION frame changes the connection state as defined in <a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>.</p></div><div id="rfc.section.6.10.p.6"><p>CONTINUATION frames <em class="bcp14">MUST</em> be associated with a stream. If a CONTINUATION frame is received with a Stream Identifier field of 0x00, the recipient <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type PROTOCOL_ERROR.</p></div><div id="rfc.section.6.10.p.7"><p>A CONTINUATION frame <em class="bcp14">MUST</em> be preceded by a <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> or CONTINUATION frame without the END_HEADERS flag set. A recipient that observes violation of this rule <em class="bcp14">MUST</em> respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div></section></section><hr class="hidden-print"><section id="ErrorCodes"><h2 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#ErrorCodes">Error Codes</a></h2><div id="rfc.section.7.p.1"><p>Error codes are 32-bit fields that are used in <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> and <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frames to convey the reasons for the stream or connection error.</p></div><div id="rfc.section.7.p.2"><p>Error codes share a common code space. Some error codes apply only to either streams or the entire connection and have no defined semantics in the other context.</p></div><div id="rfc.section.7.p.3" class="avoidbreakafter"><p>The following error codes are defined:</p></div><div id="rfc.section.7.p.4"><dl><dt>NO_ERROR (0x00):</dt><dd id="NO_ERROR" style="margin-left: 1.5em">The associated condition is not a result of an error. For example, a <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> might include this code to indicate graceful shutdown of a connection.</dd><dt>PROTOCOL_ERROR (0x01):</dt><dd id="PROTOCOL_ERROR" style="margin-left: 1.5em">The endpoint detected an unspecific protocol error. This error is for use when a more specific error code is not available.</dd><dt>INTERNAL_ERROR (0x02):</dt><dd id="INTERNAL_ERROR" style="margin-left: 1.5em">The endpoint encountered an unexpected internal error.</dd><dt>FLOW_CONTROL_ERROR (0x03):</dt><dd id="FLOW_CONTROL_ERROR" style="margin-left: 1.5em">The endpoint detected that its peer violated the flow-control protocol.</dd><dt>SETTINGS_TIMEOUT (0x04):</dt><dd id="SETTINGS_TIMEOUT" style="margin-left: 1.5em">The endpoint sent a <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame but did not receive a response in a timely manner. See <a href="#SettingsSync" title="Settings Synchronization">Section 6.5.3</a> ("Settings Synchronization").</dd><dt>STREAM_CLOSED (0x05):</dt><dd id="STREAM_CLOSED" style="margin-left: 1.5em">The endpoint received a frame after a stream was half-closed.</dd><dt>FRAME_SIZE_ERROR (0x06):</dt><dd id="FRAME_SIZE_ERROR" style="margin-left: 1.5em">The endpoint received a frame with an invalid size.</dd><dt>REFUSED_STREAM (0x07):</dt><dd id="REFUSED_STREAM" style="margin-left: 1.5em">The endpoint refused the stream prior to performing any application processing (see <a href="#Reliability" title="Request Reliability">Section 8.7</a> for details).</dd><dt>CANCEL (0x08):</dt><dd id="CANCEL" style="margin-left: 1.5em">The endpoint uses this error code to indicate that the stream is no longer needed.</dd><dt>COMPRESSION_ERROR (0x09):</dt><dd id="COMPRESSION_ERROR" style="margin-left: 1.5em">The endpoint is unable to maintain the field section compression context for the connection.</dd><dt>CONNECT_ERROR (0x0a):</dt><dd id="CONNECT_ERROR" style="margin-left: 1.5em">The connection established in response to a CONNECT request (<a href="#CONNECT" title="The CONNECT Method">Section 8.5</a>) was reset or abnormally closed.</dd><dt>ENHANCE_YOUR_CALM (0x0b):</dt><dd id="ENHANCE_YOUR_CALM" style="margin-left: 1.5em">The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.</dd><dt>INADEQUATE_SECURITY (0x0c):</dt><dd id="INADEQUATE_SECURITY" style="margin-left: 1.5em">The underlying transport has properties that do not meet minimum security requirements (see <a href="#TLSUsage" title="Use of TLS Features">Section 9.2</a>).</dd><dt>HTTP_1_1_REQUIRED (0x0d):</dt><dd id="HTTP_1_1_REQUIRED" style="margin-left: 1.5em">The endpoint requires that HTTP/1.1 be used instead of HTTP/2.</dd></dl></div><div id="rfc.section.7.p.5"><p>Unknown or unsupported error codes <em class="bcp14">MUST NOT</em> trigger any special behavior. These <em class="bcp14">MAY</em> be treated by an implementation as being equivalent to <a href="#INTERNAL_ERROR">INTERNAL_ERROR</a>.</p></div></section><hr class="hidden-print"><section id="HttpLayer"><h2 id="rfc.section.8" class="np"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#HttpLayer">Expressing HTTP Semantics in HTTP/2</a></h2><div id="rfc.section.8.p.1"><p>HTTP/2 is an instantiation of the HTTP message abstraction (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6">Section 6</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</p></div><section id="HttpFraming"><h3 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a>&nbsp;<a href="#HttpFraming">HTTP Message Framing</a></h3><div id="rfc.section.8.1.p.1"><p>A client sends an HTTP request on a new stream, using a previously unused stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>). A server sends an HTTP response on the same stream as the request.</p></div><div id="rfc.section.8.1.p.2" class="avoidbreakafter"><p>An HTTP message (request or response) consists of:</p></div><div id="rfc.section.8.1.p.3"><ol type="1"><li>one <a href="#HEADERS" title="HEADERS">HEADERS</a> frame (followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames) containing the header section (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.3">Section 6.3</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>),</li><li>zero or more <a href="#DATA" title="DATA">DATA</a> frames containing the message content (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.4">Section 6.4</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>), and</li><li>optionally, one <a href="#HEADERS" title="HEADERS">HEADERS</a> frame (followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames) containing the trailer section, if present (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.5">Section 6.5</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</li></ol></div><div id="rfc.section.8.1.p.4"><p>For a response only, a server <em class="bcp14">MAY</em> send any number of interim responses before the <a href="#HEADERS" title="HEADERS">HEADERS</a> frame containing a final response. An interim response consists of a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame (which might be followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames) containing the control data and header section of an interim (1xx) HTTP response (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-15">Section 15</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). A <a href="#HEADERS" title="HEADERS">HEADERS</a> frame with the END_STREAM flag set that carries an informational status code is malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.1.p.5"><p>The last frame in the sequence bears an END_STREAM flag, noting that a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame with the END_STREAM flag set can be followed by <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames that carry any remaining fragments of the field block.</p></div><div id="rfc.section.8.1.p.6"><p>Other frames (from any stream) <em class="bcp14">MUST NOT</em> occur between the <a href="#HEADERS" title="HEADERS">HEADERS</a> frame and any <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames that might follow.</p></div><div id="rfc.section.8.1.p.7"><p>HTTP/2 uses DATA frames to carry message content. The <span class="tt">chunked</span> transfer encoding defined in <a href="https://www.rfc-editor.org/rfc/rfc9112.html#section-7.1">Section 7.1</a> of <a href="#RFC9112"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a> cannot be used in HTTP/2; see <a href="#ConnectionSpecific" title="Connection-Specific Header Fields">Section 8.2.2</a>.</p></div><div id="rfc.section.8.1.p.8"><p>Trailer fields are carried in a field block that also terminates the stream. That is, trailer fields comprise a sequence starting with a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames, where the <a href="#HEADERS" title="HEADERS">HEADERS</a> frame bears an END_STREAM flag. Trailers <em class="bcp14">MUST NOT</em> include pseudo-header fields (<a href="#PseudoHeaderFields" title="HTTP Control Data">Section 8.3</a>). An endpoint that receives pseudo-header fields in trailers <em class="bcp14">MUST</em> treat the request or response as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.1.p.9"><p>An endpoint that receives a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame without the END_STREAM flag set after receiving the <a href="#HEADERS" title="HEADERS">HEADERS</a> frame that opens a request or after receiving a final (non-informational) status code <em class="bcp14">MUST</em> treat the corresponding request or response as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.1.p.10"><p>An HTTP request/response exchange fully consumes a single stream. A request starts with the <a href="#HEADERS" title="HEADERS">HEADERS</a> frame that puts the stream into the "open" state. The request ends with a frame with the END_STREAM flag set, which causes the stream to become "half-closed (local)" for the client and "half-closed (remote)" for the server. A response stream starts with zero or more interim responses in <a href="#HEADERS" title="HEADERS">HEADERS</a> frames, followed by a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame containing a final status code.</p></div><div id="rfc.section.8.1.p.11"><p>An HTTP response is complete after the server sends -- or the client receives -- a frame with the END_STREAM flag set (including any <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames needed to complete a field block). A server can send a complete response prior to the client sending an entire request if the response does not depend on any portion of the request that has not been sent and received. When this is true, a server <em class="bcp14">MAY</em> request that the client abort transmission of a request without error by sending a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> with an error code of <a href="#NO_ERROR">NO_ERROR</a> after sending a complete response (i.e., a frame with the END_STREAM flag set). Clients <em class="bcp14">MUST NOT</em> discard responses as a result of receiving such a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, though clients can always discard responses at their discretion for other reasons.</p></div><section id="malformed"><h4 id="rfc.section.8.1.1"><a href="#rfc.section.8.1.1">8.1.1.</a>&nbsp;<a href="#malformed">Malformed Messages</a></h4><div id="rfc.section.8.1.1.p.1"><p>A malformed request or response is one that is an otherwise valid sequence of HTTP/2 frames but is invalid due to the presence of extraneous frames, prohibited fields or pseudo-header fields, the absence of mandatory pseudo-header fields, the inclusion of uppercase field names, or invalid field names and/or values (in certain circumstances; see <a href="#HttpHeaders" title="HTTP Fields">Section 8.2</a>).</p></div><div id="rfc.section.8.1.1.p.2"><p>A request or response that includes message content can include a <span class="tt">content-length</span> header field. A request or response is also malformed if the value of a <span class="tt">content-length</span> header field does not equal the sum of the <a href="#DATA" title="DATA">DATA</a> frame payload lengths that form the content, unless the message is defined as having no content. For example, 204 or 304 responses contain no content, as does the response to a HEAD request. A response that is defined to have no content, as described in <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.4.1">Section 6.4.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>, <em class="bcp14">MAY</em> have a non-zero <span class="tt">content-length</span> header field, even though no content is included in <a href="#DATA" title="DATA">DATA</a> frames.</p></div><div id="rfc.section.8.1.1.p.3"><p>Intermediaries that process HTTP requests or responses (i.e., any intermediary not acting as a tunnel) <em class="bcp14">MUST NOT</em> forward a malformed request or response. Malformed requests or responses that are detected <em class="bcp14">MUST</em> be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.8.1.1.p.4"><p>For malformed requests, a server <em class="bcp14">MAY</em> send an HTTP response prior to closing or resetting the stream. Clients <em class="bcp14">MUST NOT</em> accept a malformed response.</p></div><div id="rfc.section.8.1.1.p.5"><p>Endpoints that progressively process messages might have performed some processing before identifying a request or response as malformed. For instance, it might be possible to generate an informational or 404 status code without having received a complete request. Similarly, intermediaries might forward incomplete messages before detecting errors. A server <em class="bcp14">MAY</em> generate a final response before receiving an entire request when the response does not depend on the remainder of the request being correct.</p></div><div id="rfc.section.8.1.1.p.6"><p>These requirements are intended to protect against several types of common attacks against HTTP; they are deliberately strict because being permissive can expose implementations to these vulnerabilities.</p></div></section></section><section id="HttpHeaders"><h3 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a>&nbsp;<a href="#HttpHeaders">HTTP Fields</a></h3><div id="rfc.section.8.2.p.1"><p>HTTP fields (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5">Section 5</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>) are conveyed by HTTP/2 in the HEADERS, CONTINUATION, and PUSH_PROMISE frames, compressed with <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">HPACK</cite></a> <cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite>.</p></div><div id="rfc.section.8.2.p.2"><p>Field names <em class="bcp14">MUST</em> be converted to lowercase when constructing an HTTP/2 message.</p></div><section id="n-field-validity"><h4 id="rfc.section.8.2.1"><a href="#rfc.section.8.2.1">8.2.1.</a>&nbsp;<a href="#n-field-validity">Field Validity</a></h4><div id="rfc.section.8.2.1.p.1"><p>The definitions of field names and values in HTTP prohibit some characters that HPACK might be able to convey. HTTP/2 implementations <em class="bcp14">SHOULD</em> validate field names and values according to their definitions in Sections <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.1">5.1</a> and <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5">5.5</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>, respectively, and treat messages that contain prohibited characters as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.2.1.p.2" class="avoidbreakafter"><p>Failure to validate fields can be exploited for request smuggling attacks. In particular, unvalidated fields might enable attacks when messages are forwarded using <a href="#RFC9112"><cite title="HTTP/1.1">HTTP/1.1</cite></a> <cite title="HTTP/1.1">[HTTP/1.1]</cite>, where characters such as carriage return (CR), line feed (LF), and COLON are used as delimiters. Implementations <em class="bcp14">MUST</em> perform the following minimal validation of field names and values:</p></div><div id="rfc.section.8.2.1.p.3"><ul><li>A field name <em class="bcp14">MUST NOT</em> contain characters in the ranges 0x00-0x20, 0x41-0x5a, or 0x7f-0xff (all ranges inclusive). This specifically excludes all non-visible ASCII characters, ASCII SP (0x20), and uppercase characters ('A' to 'Z', ASCII 0x41 to 0x5a).</li><li>With the exception of pseudo-header fields (<a href="#PseudoHeaderFields" title="HTTP Control Data">Section 8.3</a>), which have a name that starts with a single colon, field names <em class="bcp14">MUST NOT</em> include a colon (ASCII COLON, 0x3a).</li><li>A field value <em class="bcp14">MUST NOT</em> contain the zero value (ASCII NUL, 0x00), line feed (ASCII LF, 0x0a), or carriage return (ASCII CR, 0x0d) at any position.</li><li>A field value <em class="bcp14">MUST NOT</em> start or end with an ASCII whitespace character (ASCII SP or HTAB, 0x20 or 0x09).</li></ul></div><div id="rfc.section.8.2.1.p.4"><aside><div id="rfc.section.8.2.1.p.4.1"><p>Note: An implementation that validates fields according to the definitions in Sections <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.1">5.1</a> and <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5">5.5</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a> only needs an additional check that field names do not include uppercase characters.</p></div></aside></div><div id="rfc.section.8.2.1.p.5"><p>A request or response that contains a field that violates any of these conditions <em class="bcp14">MUST</em> be treated as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>). In particular, an intermediary that does not process fields when forwarding messages <em class="bcp14">MUST NOT</em> forward fields that contain any of the values that are listed as prohibited above.</p></div><div id="rfc.section.8.2.1.p.6"><p>When a request message violates one of these requirements, an implementation <em class="bcp14">SHOULD</em> generate a 400 (Bad Request) status code (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-15.5.1">Section 15.5.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>), unless a more suitable status code is defined or the status code cannot be sent (e.g., because the error occurs in a trailer field).</p></div><div id="rfc.section.8.2.1.p.7"><aside><div id="rfc.section.8.2.1.p.7.1"><p>Note: Field values that are not valid according to the definition of the corresponding field do not cause a request to be <a href="#malformed" title="Malformed Messages">malformed</a>; the requirements above only apply to the generic syntax for fields as defined in <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5">Section 5</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>.</p></div></aside></div></section><section id="ConnectionSpecific"><h4 id="rfc.section.8.2.2"><a href="#rfc.section.8.2.2">8.2.2.</a>&nbsp;<a href="#ConnectionSpecific">Connection-Specific Header Fields</a></h4><div id="rfc.section.8.2.2.p.1"><p>HTTP/2 does not use the <span class="tt">Connection</span> header field (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.6.1">Section 7.6.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>) to indicate connection-specific header fields; in this protocol, connection-specific metadata is conveyed by other means. An endpoint <em class="bcp14">MUST NOT</em> generate an HTTP/2 message containing connection-specific header fields. This includes the <span class="tt">Connection</span> header field and those listed as having connection-specific semantics in <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.6.1">Section 7.6.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a> (that is, <span class="tt">Proxy-Connection</span>, <span class="tt">Keep-Alive</span>, <span class="tt">Transfer-Encoding</span>, and <span class="tt">Upgrade</span>). Any message containing connection-specific header fields <em class="bcp14">MUST</em> be treated as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.2.2.p.2"><p>The only exception to this is the TE header field, which <em class="bcp14">MAY</em> be present in an HTTP/2 request; when it is, it <em class="bcp14">MUST NOT</em> contain any value other than "trailers".</p></div><div id="rfc.section.8.2.2.p.3"><p>An intermediary transforming an HTTP/1.x message to HTTP/2 <em class="bcp14">MUST</em> remove connection-specific header fields as discussed in <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.6.1">Section 7.6.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>, or their messages will be treated by other HTTP/2 endpoints as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.2.2.p.4"><aside><div id="rfc.section.8.2.2.p.4.1"><p>Note: HTTP/2 purposefully does not support upgrade to another protocol. The handshake methods described in <a href="#starting" title="Starting HTTP/2">Section 3</a> are believed sufficient to negotiate the use of alternative protocols.</p></div></aside></div></section><section id="CompressCookie"><h4 id="rfc.section.8.2.3"><a href="#rfc.section.8.2.3">8.2.3.</a>&nbsp;<a href="#CompressCookie">Compressing the Cookie Header Field</a></h4><div id="rfc.section.8.2.3.p.1"><p>The <a href="#RFC6265"><cite title="HTTP State Management Mechanism">Cookie header field</cite></a> <cite title="HTTP State Management Mechanism">[COOKIE]</cite> uses a semicolon (";") to delimit cookie-pairs (or "crumbs"). This header field contains multiple values, but does not use a COMMA (",") as a separator, thereby preventing cookie-pairs from being sent on multiple field lines (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.2">Section 5.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). This can significantly reduce compression efficiency, as updates to individual cookie-pairs would invalidate any field lines that are stored in the HPACK table.</p></div><div id="rfc.section.8.2.3.p.2"><p>To allow for better compression efficiency, the Cookie header field <em class="bcp14">MAY</em> be split into separate header fields, each with one or more cookie-pairs. If there are multiple Cookie header fields after decompression, these <em class="bcp14">MUST</em> be concatenated into a single octet string using the two-octet delimiter of 0x3b, 0x20 (the ASCII string "; ") before being passed into a non-HTTP/2 context, such as an HTTP/1.1 connection, or a generic HTTP server application.</p></div><div id="rfc.section.8.2.3.p.3" class="avoidbreakafter"><p>Therefore, the following two lists of Cookie header fields are semantically equivalent.</p></div><div id="rfc.section.8.2.3.p.4"><pre class="inline">
cookie: a=b; c=d; e=f

cookie: a=b
cookie: c=d
cookie: e=f
</pre></div></section></section><section id="PseudoHeaderFields"><h3 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a>&nbsp;<a href="#PseudoHeaderFields">HTTP Control Data</a></h3><div id="rfc.section.8.3.p.1"><p>HTTP/2 uses special pseudo-header fields beginning with a ':' character (ASCII 0x3a) to convey message control data (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.2">Section 6.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</p></div><div id="rfc.section.8.3.p.2"><p>Pseudo-header fields are not HTTP header fields. Endpoints <em class="bcp14">MUST NOT</em> generate pseudo-header fields other than those defined in this document. Note that an extension could negotiate the use of additional pseudo-header fields; see <a href="#extensibility" title="Extending HTTP/2">Section 5.5</a>.</p></div><div id="rfc.section.8.3.p.3"><p>Pseudo-header fields are only valid in the context in which they are defined. Pseudo-header fields defined for requests <em class="bcp14">MUST NOT</em> appear in responses; pseudo-header fields defined for responses <em class="bcp14">MUST NOT</em> appear in requests. Pseudo-header fields <em class="bcp14">MUST NOT</em> appear in a trailer section. Endpoints <em class="bcp14">MUST</em> treat a request or response that contains undefined or invalid pseudo-header fields as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.3.p.4"><p>All pseudo-header fields <em class="bcp14">MUST</em> appear in a field block before all regular field lines. Any request or response that contains a pseudo-header field that appears in a field block after a regular field line <em class="bcp14">MUST</em> be treated as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.3.p.5"><p>The same pseudo-header field name <em class="bcp14">MUST NOT</em> appear more than once in a field block. A field block for an HTTP request or response that contains a repeated pseudo-header field name <em class="bcp14">MUST</em> be treated as malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><section id="HttpRequest"><h4 id="rfc.section.8.3.1"><a href="#rfc.section.8.3.1">8.3.1.</a>&nbsp;<a href="#HttpRequest">Request Pseudo-Header Fields</a></h4><div id="rfc.section.8.3.1.p.1" class="avoidbreakafter"><p>The following pseudo-header fields are defined for HTTP/2 requests:</p></div><div id="rfc.section.8.3.1.p.2"><ul><li><div><p>The "<span class="tt">:method</span>" pseudo-header field includes the HTTP method (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9">Section 9</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</p></div> </li><li><div><p>The "<span class="tt">:scheme</span>" pseudo-header field includes the scheme portion of the request target. The scheme is taken from the target URI (<a href="https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1">Section 3.1</a> of <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>) when generating a request directly, or from the scheme of a translated request (for example, see <a href="https://www.rfc-editor.org/rfc/rfc9112.html#section-3.3">Section 3.3</a> of <a href="#RFC9112"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>). Scheme is omitted for CONNECT requests (<a href="#CONNECT" title="The CONNECT Method">Section 8.5</a>).</p></div> <div><p>"<span class="tt">:scheme</span>" is not restricted to "<span class="tt">http</span>" and "<span class="tt">https</span>" schemed URIs. A proxy or gateway can translate requests for non-HTTP schemes, enabling the use of HTTP to interact with non-HTTP services.</p></div> </li><li><div><p>The "<span class="tt">:authority</span>" pseudo-header field conveys the authority portion (<a href="https://www.rfc-editor.org/rfc/rfc3986.html#section-3.2">Section 3.2</a> of <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>) of the target URI (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.1">Section 7.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). The recipient of an HTTP/2 request <em class="bcp14">MUST NOT</em> use the <span class="tt">Host</span> header field to determine the target URI if "<span class="tt">:authority</span>" is present.</p></div> <div><p>Clients that generate HTTP/2 requests directly <em class="bcp14">MUST</em> use the "<span class="tt">:authority</span>" pseudo-header field to convey authority information, unless there is no authority information to convey (in which case it <em class="bcp14">MUST NOT</em> generate "<span class="tt">:authority</span>").</p></div> <div><p>Clients <em class="bcp14">MUST NOT</em> generate a request with a <span class="tt">Host</span> header field that differs from the "<span class="tt">:authority</span>" pseudo-header field. A server <em class="bcp14">SHOULD</em> treat a request as malformed if it contains a <span class="tt">Host</span> header field that identifies an entity that differs from the entity in the "<span class="tt">:authority</span>" pseudo-header field. The values of fields need to be normalized to compare them (see <a href="https://www.rfc-editor.org/rfc/rfc3986.html#section-6.2">Section 6.2</a> of <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>). An origin server can apply any normalization method, whereas other servers <em class="bcp14">MUST</em> perform scheme-based normalization (see <a href="https://www.rfc-editor.org/rfc/rfc3986.html#section-6.2.3">Section 6.2.3</a> of <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>) of the two fields.</p></div> <div><p>An intermediary that forwards a request over HTTP/2 <em class="bcp14">MUST</em> construct an "<span class="tt">:authority</span>" pseudo-header field using the authority information from the control data of the original request, unless the original request's target URI does not contain authority information (in which case it <em class="bcp14">MUST NOT</em> generate "<span class="tt">:authority</span>"). Note that the <span class="tt">Host</span> header field is not the sole source of this information; see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.2">Section 7.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>.</p></div> <div><p>An intermediary that needs to generate a <span class="tt">Host</span> header field (which might be necessary to construct an HTTP/1.1 request) <em class="bcp14">MUST</em> use the value from the "<span class="tt">:authority</span>" pseudo-header field as the value of the <span class="tt">Host</span> field, unless the intermediary also changes the request target. This replaces any existing <span class="tt">Host</span> field to avoid potential vulnerabilities in HTTP routing.</p></div> <div><p>An intermediary that forwards a request over HTTP/2 <em class="bcp14">MAY</em> retain any <span class="tt">Host</span> header field.</p></div> <div><p>Note that request targets for CONNECT or asterisk-form OPTIONS requests never include authority information; see Sections <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.1">7.1</a> and <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.2">7.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>.</p></div> <div><p>"<span class="tt">:authority</span>" <em class="bcp14">MUST NOT</em> include the deprecated userinfo subcomponent for "<span class="tt">http</span>" or "<span class="tt">https</span>" schemed URIs.</p></div> </li><li><div><p>The "<span class="tt">:path</span>" pseudo-header field includes the path and query parts of the target URI (the <span class="tt">absolute-path</span> production and, optionally, a '?' character followed by the <span class="tt">query</span> production; see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-4.1">Section 4.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). A request in asterisk form (for OPTIONS) includes the value '*' for the "<span class="tt">:path</span>" pseudo-header field.</p></div> <div class="avoidbreakafter"><p>This pseudo-header field <em class="bcp14">MUST NOT</em> be empty for "<span class="tt">http</span>" or "<span class="tt">https</span>" URIs; "<span class="tt">http</span>" or "<span class="tt">https</span>" URIs that do not contain a path component <em class="bcp14">MUST</em> include a value of '/'. The exceptions to this rule are:</p></div> <div><ul><li>an OPTIONS request for an "<span class="tt">http</span>" or "<span class="tt">https</span>" URI that does not include a path component; these <em class="bcp14">MUST</em> include a "<span class="tt">:path</span>" pseudo-header field with a value of '*' (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.1">Section 7.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</li><li>CONNECT requests (<a href="#CONNECT" title="The CONNECT Method">Section 8.5</a>), where the "<span class="tt">:path</span>" pseudo-header field is omitted.</li></ul></div> </li></ul></div><div id="rfc.section.8.3.1.p.3"><p>All HTTP/2 requests <em class="bcp14">MUST</em> include exactly one valid value for the "<span class="tt">:method</span>", "<span class="tt">:scheme</span>", and "<span class="tt">:path</span>" pseudo-header fields, unless they are CONNECT requests (<a href="#CONNECT" title="The CONNECT Method">Section 8.5</a>). An HTTP request that omits mandatory pseudo-header fields is malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.3.1.p.4"><p>Individual HTTP/2 requests do not carry an explicit indicator of protocol version. All HTTP/2 requests implicitly have a protocol version of "2.0" (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.2">Section 6.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</p></div></section><section id="HttpResponse"><h4 id="rfc.section.8.3.2"><a href="#rfc.section.8.3.2">8.3.2.</a>&nbsp;<a href="#HttpResponse">Response Pseudo-Header Fields</a></h4><div id="rfc.section.8.3.2.p.1"><p>For HTTP/2 responses, a single "<span class="tt">:status</span>" pseudo-header field is defined that carries the HTTP status code field (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-15">Section 15</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). This pseudo-header field <em class="bcp14">MUST</em> be included in all responses, including interim responses; otherwise, the response is malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.3.2.p.2"><p>HTTP/2 responses implicitly have a protocol version of "2.0".</p></div></section></section><section id="PushResources"><h3 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a>&nbsp;<a href="#PushResources">Server Push</a></h3><div id="rfc.section.8.4.p.1"><p>HTTP/2 allows a server to preemptively send (or "push") responses (along with corresponding "promised" requests) to a client in association with a previous client-initiated request.</p></div><div id="rfc.section.8.4.p.2"><p>Server push was designed to allow a server to improve client-perceived performance by predicting what requests will follow those that it receives, thereby removing a round trip for them. For example, a request for HTML is often followed by requests for stylesheets and scripts referenced by that page. When these requests are pushed, the client does not need to wait to receive the references to them in the HTML and issue separate requests.</p></div><div id="rfc.section.8.4.p.3"><p>In practice, server push is difficult to use effectively, because it requires the server to correctly anticipate the additional requests the client will make, taking into account factors such as caching, content negotiation, and user behavior. Errors in prediction can lead to performance degradation, due to the opportunity cost that the additional data on the wire represents. In particular, pushing any significant amount of data can cause contention issues with responses that are more important.</p></div><div id="rfc.section.8.4.p.4"><p>A client can request that server push be disabled, though this is negotiated for each hop independently. The <a href="#SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH</a> setting can be set to 0 to indicate that server push is disabled.</p></div><div id="rfc.section.8.4.p.5"><p>Promised requests <em class="bcp14">MUST</em> be safe (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.1">Section 9.2.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>) and cacheable (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.3">Section 9.2.3</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). Promised requests cannot include any content or a trailer section. Clients that receive a promised request that is not cacheable, that is not known to be safe, or that indicates the presence of request content <em class="bcp14">MUST</em> reset the promised stream with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. Note that this could result in the promised stream being reset if the client does not recognize a newly defined method as being safe.</p></div><div id="rfc.section.8.4.p.6"><p>Pushed responses that are cacheable (see <a href="https://www.rfc-editor.org/rfc/rfc9111.html#section-3">Section 3</a> of <a href="#RFC9111"><cite title="HTTP Caching">[CACHING]</cite></a>) can be stored by the client, if it implements an HTTP cache. Pushed responses are considered successfully validated on the origin server (e.g., if the "no-cache" cache response directive is present; see <a href="https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.2.4">Section 5.2.2.4</a> of <a href="#RFC9111"><cite title="HTTP Caching">[CACHING]</cite></a>) while the stream identified by the promised stream identifier is still open.</p></div><div id="rfc.section.8.4.p.7"><p>Pushed responses that are not cacheable <em class="bcp14">MUST NOT</em> be stored by any HTTP cache. They <em class="bcp14">MAY</em> be made available to the application separately.</p></div><div id="rfc.section.8.4.p.8"><p>The server <em class="bcp14">MUST</em> include a value in the "<span class="tt">:authority</span>" pseudo-header field for which the server is authoritative (see <a href="#authority" title="Server Authority">Section 10.1</a>). A client <em class="bcp14">MUST</em> treat a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> for which the server is not authoritative as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.8.4.p.9"><p>An intermediary can receive pushes from the server and choose not to forward them on to the client. In other words, how to make use of the pushed information is up to that intermediary. Equally, the intermediary might choose to make additional pushes to the client, without any action taken by the server.</p></div><div id="rfc.section.8.4.p.10"><p>A client cannot push. Thus, servers <em class="bcp14">MUST</em> treat the receipt of a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. A server cannot set the <a href="#SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH</a> setting to a value other than 0 (see <a href="#SettingValues" title="Defined Settings">Section 6.5.2</a>).</p></div><section id="PushRequests"><h4 id="rfc.section.8.4.1"><a href="#rfc.section.8.4.1">8.4.1.</a>&nbsp;<a href="#PushRequests">Push Requests</a></h4><div id="rfc.section.8.4.1.p.1"><p>Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame.</p></div><div id="rfc.section.8.4.1.p.2"><p>The <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame includes a field block that contains control data and a complete set of request header fields that the server attributes to the request. It is not possible to push a response to a request that includes message content.</p></div><div id="rfc.section.8.4.1.p.3"><p>Promised requests are always associated with an explicit request from the client. The <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames sent by the server are sent on that explicit request's stream. The <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame also includes a promised stream identifier, chosen from the stream identifiers available to the server (see <a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>).</p></div><div id="rfc.section.8.4.1.p.4"><p>The header fields in <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> and any subsequent <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames <em class="bcp14">MUST</em> be a valid and complete set of request header fields (<a href="#HttpRequest" title="Request Pseudo-Header Fields">Section 8.3.1</a>). The server <em class="bcp14">MUST</em> include a method in the "<span class="tt">:method</span>" pseudo-header field that is safe and cacheable. If a client receives a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> that does not include a complete and valid set of header fields or the "<span class="tt">:method</span>" pseudo-header field identifies a method that is not safe, it <em class="bcp14">MUST</em> respond on the promised stream with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.8.4.1.p.5"><p>The server <em class="bcp14">SHOULD</em> send <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section 6.6</a>) frames prior to sending any frames that reference the promised responses. This avoids a race where clients issue requests prior to receiving any <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames.</p></div><div id="rfc.section.8.4.1.p.6"><p>For example, if the server receives a request for a document containing embedded links to multiple image files and the server chooses to push those additional images to the client, sending <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames before the <a href="#DATA" title="DATA">DATA</a> frames that contain the image links ensures that the client is able to see that a resource will be pushed before discovering embedded links. Similarly, if the server pushes resources referenced by the field block (for instance, in Link header fields), sending a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> before sending the header ensures that clients do not request those resources.</p></div><div id="rfc.section.8.4.1.p.7"><p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames <em class="bcp14">MUST NOT</em> be sent by the client.</p></div><div id="rfc.section.8.4.1.p.8"><p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames can be sent by the server on any client-initiated stream, but the stream <em class="bcp14">MUST</em> be in either the "open" or "half-closed (remote)" state with respect to the server. <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames are interspersed with the frames that comprise a response, though they cannot be interspersed with <a href="#HEADERS" title="HEADERS">HEADERS</a> and <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames that comprise a single field block.</p></div><div id="rfc.section.8.4.1.p.9"><p>Sending a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame creates a new stream and puts the stream into the "reserved (local)" state for the server and the "reserved (remote)" state for the client.</p></div></section><section id="PushResponses"><h4 id="rfc.section.8.4.2"><a href="#rfc.section.8.4.2">8.4.2.</a>&nbsp;<a href="#PushResponses">Push Responses</a></h4><div id="rfc.section.8.4.2.p.1"><p>After sending the <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame, the server can begin delivering the pushed response as a response (<a href="#HttpResponse" title="Response Pseudo-Header Fields">Section 8.3.2</a>) on a server-initiated stream that uses the promised stream identifier. The server uses this stream to transmit an HTTP response, using the same sequence of frames as that defined in <a href="#HttpFraming" title="HTTP Message Framing">Section 8.1</a>. This stream becomes "half-closed" to the client (<a href="#StreamStates" title="Stream States">Section 5.1</a>) after the initial <a href="#HEADERS" title="HEADERS">HEADERS</a> frame is sent.</p></div><div id="rfc.section.8.4.2.p.2"><p>Once a client receives a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame and chooses to accept the pushed response, the client <em class="bcp14">SHOULD NOT</em> issue any requests for the promised response until after the promised stream has closed.</p></div><div id="rfc.section.8.4.2.p.3"><p>If the client determines, for any reason, that it does not wish to receive the pushed response from the server or if the server takes too long to begin sending the promised response, the client can send a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame, using either the <a href="#CANCEL">CANCEL</a> or <a href="#REFUSED_STREAM">REFUSED_STREAM</a> code and referencing the pushed stream's identifier.</p></div><div id="rfc.section.8.4.2.p.4"><p>A client can use the <a href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a> setting to limit the number of responses that can be concurrently pushed by a server. Advertising a <a href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a> value of zero prevents the server from opening the streams necessary to push responses. However, this does not prevent the server from reserving streams using <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames, because reserved streams do not count toward the concurrent stream limit. Clients that do not wish to receive pushed resources need to reset any unwanted reserved streams or set <a href="#SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH</a> to 0.</p></div><div id="rfc.section.8.4.2.p.5"><p>Clients receiving a pushed response <em class="bcp14">MUST</em> validate that either the server is authoritative (see <a href="#authority" title="Server Authority">Section 10.1</a>) or the proxy that provided the pushed response is configured for the corresponding request. For example, a server that offers a certificate for only the <span class="tt">example.com</span> DNS-ID (see <a href="#RFC6125"><cite title="Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)">[RFC6125]</cite></a>) is not permitted to push a response for &lt;<span class="tt">https://www.example.org/doc</span>&gt;.</p></div><div id="rfc.section.8.4.2.p.6"><p>The response for a <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> stream begins with a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame, which immediately puts the stream into the "half-closed (remote)" state for the server and "half-closed (local)" state for the client, and ends with a frame with the END_STREAM flag set, which places the stream in the "closed" state.</p></div><div id="rfc.section.8.4.2.p.7"><aside><div id="rfc.section.8.4.2.p.7.1"><p>Note: The client never sends a frame with the END_STREAM flag set for a server push.</p></div></aside></div></section></section><section id="CONNECT"><h3 id="rfc.section.8.5"><a href="#rfc.section.8.5">8.5.</a>&nbsp;<a href="#CONNECT">The CONNECT Method</a></h3><div id="rfc.section.8.5.p.1"><p>The CONNECT method (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.6">Section 9.3.6</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>) is used to convert an HTTP connection into a tunnel to a remote host. CONNECT is primarily used with HTTP proxies to establish a TLS session with an origin server for the purposes of interacting with "<span class="tt">https</span>" resources.</p></div><div id="rfc.section.8.5.p.2" class="avoidbreakafter"><p>In HTTP/2, the CONNECT method establishes a tunnel over a single HTTP/2 stream to a remote host, rather than converting the entire connection to a tunnel. A CONNECT header section is constructed as defined in <a href="#HttpRequest" title="Request Pseudo-Header Fields">Section 8.3.1</a> ("<a href="#HttpRequest" title="Request Pseudo-Header Fields">Request Pseudo-Header Fields</a>"), with a few differences. Specifically:</p></div><div id="rfc.section.8.5.p.3"><ul><li>The "<span class="tt">:method</span>" pseudo-header field is set to <span class="tt">CONNECT</span>.</li><li>The "<span class="tt">:scheme</span>" and "<span class="tt">:path</span>" pseudo-header fields <em class="bcp14">MUST</em> be omitted.</li><li>The "<span class="tt">:authority</span>" pseudo-header field contains the host and port to connect to (equivalent to the authority-form of the request-target of CONNECT requests; see <a href="https://www.rfc-editor.org/rfc/rfc9112.html#section-3.2.3">Section 3.2.3</a> of <a href="#RFC9112"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>).</li></ul></div><div id="rfc.section.8.5.p.4"><p>A CONNECT request that does not conform to these restrictions is malformed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>).</p></div><div id="rfc.section.8.5.p.5"><p>A proxy that supports CONNECT establishes a <a href="#RFC0793"><cite title="Transmission Control Protocol">TCP connection</cite></a> <cite title="Transmission Control Protocol">[TCP]</cite> to the host and port identified in the "<span class="tt">:authority</span>" pseudo-header field. Once this connection is successfully established, the proxy sends a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame containing a 2xx-series status code to the client, as defined in <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.6">Section 9.3.6</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>.</p></div><div id="rfc.section.8.5.p.6"><p>After the initial <a href="#HEADERS" title="HEADERS">HEADERS</a> frame sent by each peer, all subsequent <a href="#DATA" title="DATA">DATA</a> frames correspond to data sent on the TCP connection. The frame payload of any <a href="#DATA" title="DATA">DATA</a> frames sent by the client is transmitted by the proxy to the TCP server; data received from the TCP server is assembled into <a href="#DATA" title="DATA">DATA</a> frames by the proxy. Frame types other than <a href="#DATA" title="DATA">DATA</a> or stream management frames (<a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>, <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>, and <a href="#PRIORITY" title="PRIORITY">PRIORITY</a>) <em class="bcp14">MUST NOT</em> be sent on a connected stream and <em class="bcp14">MUST</em> be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) if received.</p></div><div id="rfc.section.8.5.p.7"><p>The TCP connection can be closed by either peer. The END_STREAM flag on a <a href="#DATA" title="DATA">DATA</a> frame is treated as being equivalent to the TCP FIN bit. A client is expected to send a <a href="#DATA" title="DATA">DATA</a> frame with the END_STREAM flag set after receiving a frame with the END_STREAM flag set. A proxy that receives a <a href="#DATA" title="DATA">DATA</a> frame with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP segment. A proxy that receives a TCP segment with the FIN bit set sends a <a href="#DATA" title="DATA">DATA</a> frame with the END_STREAM flag set. Note that the final TCP segment or <a href="#DATA" title="DATA">DATA</a> frame could be empty.</p></div><div id="rfc.section.8.5.p.8"><p>A TCP connection error is signaled with <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>. A proxy treats any error in the TCP connection, which includes receiving a TCP segment with the RST bit set, as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#CONNECT_ERROR">CONNECT_ERROR</a>. Correspondingly, a proxy <em class="bcp14">MUST</em> send a TCP segment with the RST bit set if it detects an error with the stream or the HTTP/2 connection.</p></div></section><section id="informational-responses"><h3 id="rfc.section.8.6"><a href="#rfc.section.8.6">8.6.</a>&nbsp;<a href="#informational-responses">The Upgrade Header Field</a></h3><div id="rfc.section.8.6.p.1"><p>HTTP/2 does not support the 101 (Switching Protocols) informational status code (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-15.2.2">Section 15.2.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</p></div><div id="rfc.section.8.6.p.2"><p>The semantics of 101 (Switching Protocols) aren't applicable to a multiplexed protocol. Similar functionality might be enabled through the use of <a href="#RFC8441"><cite title="Bootstrapping WebSockets with HTTP/2">extended CONNECT</cite></a> <cite title="Bootstrapping WebSockets with HTTP/2">[RFC8441]</cite>, and other protocols are able to use the same mechanisms that HTTP/2 uses to negotiate their use (see <a href="#starting" title="Starting HTTP/2">Section 3</a>).</p></div></section><section id="Reliability"><h3 id="rfc.section.8.7"><a href="#rfc.section.8.7">8.7.</a>&nbsp;<a href="#Reliability">Request Reliability</a></h3><div id="rfc.section.8.7.p.1"><p>In general, an HTTP client is unable to retry a non-idempotent request when an error occurs because there is no means to determine the nature of the error (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.2">Section 9.2.2</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). It is possible that some server processing occurred prior to the error, which could result in undesirable effects if the request were reattempted.</p></div><div id="rfc.section.8.7.p.2" class="avoidbreakafter"><p>HTTP/2 provides two mechanisms for providing a guarantee to a client that a request has not been processed:</p></div><div id="rfc.section.8.7.p.3"><ul><li>The <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame indicates the highest stream number that might have been processed. Requests on streams with higher numbers are therefore guaranteed to be safe to retry.</li><li>The <a href="#REFUSED_STREAM">REFUSED_STREAM</a> error code can be included in a <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frame to indicate that the stream is being closed prior to any processing having occurred. Any request that was sent on the reset stream can be safely retried.</li></ul></div><div id="rfc.section.8.7.p.4"><p>Requests that have not been processed have not failed; clients <em class="bcp14">MAY</em> automatically retry them, even those with non-idempotent methods.</p></div><div id="rfc.section.8.7.p.5"><p>A server <em class="bcp14">MUST NOT</em> indicate that a stream has not been processed unless it can guarantee that fact. If frames that are on a stream are passed to the application layer for any stream, then <a href="#REFUSED_STREAM">REFUSED_STREAM</a> <em class="bcp14">MUST NOT</em> be used for that stream, and a <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> frame <em class="bcp14">MUST</em> include a stream identifier that is greater than or equal to the given stream identifier.</p></div><div id="rfc.section.8.7.p.6"><p>In addition to these mechanisms, the <a href="#PING" title="PING">PING</a> frame provides a way for a client to easily test a connection. Connections that remain idle can become broken, because some middleboxes (for instance, network address translators or load balancers) silently discard connection bindings. The <a href="#PING" title="PING">PING</a> frame allows a client to safely test whether a connection is still active without sending a request.</p></div></section><section id="HttpExamples"><h3 id="rfc.section.8.8"><a href="#rfc.section.8.8">8.8.</a>&nbsp;<a href="#HttpExamples">Examples</a></h3><div id="rfc.section.8.8.p.1"><p>This section shows HTTP/1.1 requests and responses, with illustrations of equivalent HTTP/2 requests and responses.</p></div><section id="n-simple-request"><h4 id="rfc.section.8.8.1"><a href="#rfc.section.8.8.1">8.8.1.</a>&nbsp;<a href="#n-simple-request">Simple Request</a></h4><div id="rfc.section.8.8.1.p.1"><p>An HTTP GET request includes control data and a request header with no message content and is therefore transmitted as a single <a href="#HEADERS" title="HEADERS">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames containing the serialized block of request header fields. The <a href="#HEADERS" title="HEADERS">HEADERS</a> frame in the following has both the END_HEADERS and END_STREAM flags set; no <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames are sent.</p></div><div id="rfc.section.8.8.1.p.2"><pre class="inline">
  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==&gt;     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :authority = example.org
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg
</pre></div></section><section id="n-simple-response"><h4 id="rfc.section.8.8.2"><a href="#rfc.section.8.8.2">8.8.2.</a>&nbsp;<a href="#n-simple-response">Simple Response</a></h4><div id="rfc.section.8.8.2.p.1"><p>Similarly, a response that includes only control data and a response header is transmitted as a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame (again, followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames) containing the serialized block of response header fields.</p></div><div id="rfc.section.8.8.2.p.2"><pre class="inline">
  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==&gt;     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag = "xyzzy"
                                       expires = Thu, 23 Jan ...
</pre></div></section><section id="n-complex-request"><h4 id="rfc.section.8.8.3"><a href="#rfc.section.8.8.3">8.8.3.</a>&nbsp;<a href="#n-complex-request">Complex Request</a></h4><div id="rfc.section.8.8.3.p.1" class="avoidbreakafter"><p>An HTTP POST request that includes control data and a request header with message content is transmitted as one <a href="#HEADERS" title="HEADERS">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames containing the request header, followed by one or more <a href="#DATA" title="DATA">DATA</a> frames, with the last <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> (or <a href="#HEADERS" title="HEADERS">HEADERS</a>) frame having the END_HEADERS flag set and the final <a href="#DATA" title="DATA">DATA</a> frame having the END_STREAM flag set:</p></div><div id="rfc.section.8.8.3.p.2"><pre class="inline">
  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==&gt;     - END_STREAM
  Content-Type: image/jpeg           - END_HEADERS
  Content-Length: 123                  :method = POST
                                       :authority = example.org
                                       :path = /resource
  {binary data}                        :scheme = https

                                   CONTINUATION
                                     + END_HEADERS
                                       content-type = image/jpeg
                                       host = example.org
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
</pre></div><div id="rfc.section.8.8.3.p.3" class="avoidbreakbefore"><p>Note that data contributing to any given field line could be spread between field block fragments. The allocation of field lines to frames in this example is illustrative only.</p></div></section><section id="n-response-with-body"><h4 id="rfc.section.8.8.4"><a href="#rfc.section.8.8.4">8.8.4.</a>&nbsp;<a href="#n-response-with-body">Response with Body</a></h4><div id="rfc.section.8.8.4.p.1" class="avoidbreakafter"><p>A response that includes control data and a response header with message content is transmitted as a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames, followed by one or more <a href="#DATA" title="DATA">DATA</a> frames, with the last <a href="#DATA" title="DATA">DATA</a> frame in the sequence having the END_STREAM flag set:</p></div><div id="rfc.section.8.8.4.p.2"><pre class="inline">
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==&gt;     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
</pre></div></section><section id="n-informational-responses"><h4 id="rfc.section.8.8.5"><a href="#rfc.section.8.8.5">8.8.5.</a>&nbsp;<a href="#n-informational-responses">Informational Responses</a></h4><div id="rfc.section.8.8.5.p.1"><p>An informational response using a 1xx status code other than 101 is transmitted as a <a href="#HEADERS" title="HEADERS">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frames.</p></div><div id="rfc.section.8.8.5.p.2"><p>A trailer section is sent as a field block after both the request or response field block and all the <a href="#DATA" title="DATA">DATA</a> frames have been sent. The <a href="#HEADERS" title="HEADERS">HEADERS</a> frame starting the field block that comprises the trailer section has the END_STREAM flag set.</p></div><div id="rfc.section.8.8.5.p.3" class="avoidbreakafter"><p>The following example includes both a 100 (Continue) status code, which is sent in response to a request containing a "100-continue" token in the Expect header field, and a trailer section:</p></div><div id="rfc.section.8.8.5.p.4"><pre class="inline">
  HTTP/1.1 100 Continue            HEADERS
  Extension-Field: bar       ==&gt;     - END_STREAM
                                     + END_HEADERS
                                       :status = 100
                                       extension-field = bar

  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==&gt;     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status = 200
                                       content-type = image/jpeg
  123                                  trailer = Foo
  {binary data}
  0                                DATA
  Foo: bar                           - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo = bar
</pre></div></section></section></section><hr class="hidden-print"><section id="HttpExtra"><h2 id="rfc.section.9" class="np"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#HttpExtra">HTTP/2 Connections</a></h2><div id="rfc.section.9.p.1"><p>This section outlines attributes of HTTP that improve interoperability, reduce exposure to known security vulnerabilities, or reduce the potential for implementation variation.</p></div><section id="n-connection-management"><h3 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a>&nbsp;<a href="#n-connection-management">Connection Management</a></h3><div id="rfc.section.9.1.p.1"><p>HTTP/2 connections are persistent. For best performance, it is expected that clients will not close connections until it is determined that no further communication with a server is necessary (for example, when a user navigates away from a particular web page) or until the server closes the connection.</p></div><div id="rfc.section.9.1.p.2"><p>Clients <em class="bcp14">SHOULD NOT</em> open more than one HTTP/2 connection to a given host and port pair, where the host is derived from a URI, a selected <a href="#RFC7838"><cite title="HTTP Alternative Services">alternative service</cite></a> <cite title="HTTP Alternative Services">[ALT-SVC]</cite>, or a configured proxy.</p></div><div id="rfc.section.9.1.p.3"><p>A client can create additional connections as replacements, either to replace connections that are near to exhausting the available stream identifier space (<a href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>), to refresh the keying material for a TLS connection, or to replace connections that have encountered errors (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>).</p></div><div id="rfc.section.9.1.p.4"><p>A client <em class="bcp14">MAY</em> open multiple connections to the same IP address and TCP port using different <a href="#RFC6066"><cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">Server Name Indication</cite></a> <cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite> values or to provide different TLS client certificates but <em class="bcp14">SHOULD</em> avoid creating multiple connections with the same configuration.</p></div><div id="rfc.section.9.1.p.5"><p>Servers are encouraged to maintain open connections for as long as possible but are permitted to terminate idle connections if necessary. When either endpoint chooses to close the transport-layer TCP connection, the terminating endpoint <em class="bcp14">SHOULD</em> first send a <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> (<a href="#GOAWAY" title="GOAWAY">Section 6.8</a>) frame so that both endpoints can reliably determine whether previously sent frames have been processed and gracefully complete or terminate any necessary remaining tasks.</p></div><section id="reuse"><h4 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1.</a>&nbsp;<a href="#reuse">Connection Reuse</a></h4><div id="rfc.section.9.1.1.p.1"><p>Connections that are made to an origin server, either directly or through a tunnel created using the CONNECT method (<a href="#CONNECT" title="The CONNECT Method">Section 8.5</a>), <em class="bcp14">MAY</em> be reused for requests with multiple different URI authority components. A connection can be reused as long as the origin server is authoritative (<a href="#authority" title="Server Authority">Section 10.1</a>). For TCP connections without TLS, this depends on the host having resolved to the same IP address.</p></div><div id="rfc.section.9.1.1.p.2"><p>For "<span class="tt">https</span>" resources, connection reuse additionally depends on having a certificate that is valid for the host in the URI. The certificate presented by the server <em class="bcp14">MUST</em> satisfy any checks that the client would perform when forming a new TLS connection for the host in the URI. A single certificate can be used to establish authority for multiple origins. <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-4.3">Section 4.3</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a> describes how a client determines whether a server is authoritative for a URI.</p></div><div id="rfc.section.9.1.1.p.3"><p>In some deployments, reusing a connection for multiple origins can result in requests being directed to the wrong origin server. For example, TLS termination might be performed by a middlebox that uses the TLS <a href="#RFC6066"><cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">Server Name Indication</cite></a> <cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite> extension to select an origin server. This means that it is possible for clients to send requests to servers that might not be the intended target for the request, even though the server is otherwise authoritative.</p></div><div id="rfc.section.9.1.1.p.4"><p>A server that does not wish clients to reuse connections can indicate that it is not authoritative for a request by sending a 421 (Misdirected Request) status code in response to the request (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-15.5.20">Section 15.5.20</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</p></div><div id="rfc.section.9.1.1.p.5"><p>A client that is configured to use a proxy over HTTP/2 directs requests to that proxy through a single connection. That is, all requests sent via a proxy reuse the connection to the proxy.</p></div></section></section><section id="TLSUsage"><h3 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a>&nbsp;<a href="#TLSUsage">Use of TLS Features</a></h3><div id="rfc.section.9.2.p.1"><p>Implementations of HTTP/2 <em class="bcp14">MUST</em> use <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">TLS version 1.2</cite></a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite> or higher for HTTP/2 over TLS. The general TLS usage guidance in <a href="#RFC7525"><cite title="Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)">[TLSBCP]</cite></a> <em class="bcp14">SHOULD</em> be followed, with some additional restrictions that are specific to HTTP/2.</p></div><div id="rfc.section.9.2.p.2"><p>The TLS implementation <em class="bcp14">MUST</em> support the <a href="#RFC6066"><cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">Server Name Indication (SNI)</cite></a> <cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite> extension to TLS. If the server is identified by a <a href="#RFC8499"><cite title="DNS Terminology">domain name</cite></a> <cite title="DNS Terminology">[DNS-TERMS]</cite>, clients <em class="bcp14">MUST</em> send the server_name TLS extension unless an alternative mechanism to indicate the target host is used.</p></div><div id="rfc.section.9.2.p.3"><p>Requirements for deployments of HTTP/2 that negotiate <a href="#RFC8446"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">TLS 1.3</cite></a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[TLS13]</cite> are included in <a href="#tls13features" title="TLS 1.3 Features">Section 9.2.3</a>. Deployments of TLS 1.2 are subject to the requirements in Sections&nbsp;<a href="#tls12features" title="TLS 1.2 Features">9.2.1</a> and <a href="#tls12ciphers" title="TLS 1.2 Cipher Suites">9.2.2</a>. Implementations are encouraged to provide defaults that comply, but it is recognized that deployments are ultimately responsible for compliance.</p></div><section id="tls12features"><h4 id="rfc.section.9.2.1"><a href="#rfc.section.9.2.1">9.2.1.</a>&nbsp;<a href="#tls12features">TLS 1.2 Features</a></h4><div id="rfc.section.9.2.1.p.1"><p>This section describes restrictions on the TLS 1.2 feature set that can be used with HTTP/2. Due to deployment limitations, it might not be possible to fail TLS negotiation when these restrictions are not met. An endpoint <em class="bcp14">MAY</em> immediately terminate an HTTP/2 connection that does not meet these TLS requirements with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#INADEQUATE_SECURITY">INADEQUATE_SECURITY</a>.</p></div><div id="rfc.section.9.2.1.p.2"><p>A deployment of HTTP/2 over TLS 1.2 <em class="bcp14">MUST</em> disable compression. TLS compression can lead to the exposure of information that would not otherwise be revealed <a href="#RFC3749"><cite title="Transport Layer Security Protocol Compression Methods">[RFC3749]</cite></a>. Generic compression is unnecessary, since HTTP/2 provides compression features that are more aware of context and therefore likely to be more appropriate for use for performance, security, or other reasons.</p></div><div id="rfc.section.9.2.1.p.3"><p>A deployment of HTTP/2 over TLS 1.2 <em class="bcp14">MUST</em> disable renegotiation. An endpoint <em class="bcp14">MUST</em> treat a TLS renegotiation as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</p></div><div id="rfc.section.9.2.1.p.4"><p>An endpoint <em class="bcp14">MAY</em> use renegotiation to provide confidentiality protection for client credentials offered in the handshake, but any renegotiation <em class="bcp14">MUST</em> occur prior to sending the connection preface. A server <em class="bcp14">SHOULD</em> request a client certificate if it sees a renegotiation request immediately after establishing a connection.</p></div><div id="rfc.section.9.2.1.p.5"><p>This effectively prevents the use of renegotiation in response to a request for a specific protected resource. A future specification might provide a way to support this use case. Alternatively, a server might use an error (<a href="#ErrorHandler" title="Error Handling">Section 5.4</a>) of type <a href="#HTTP_1_1_REQUIRED">HTTP_1_1_REQUIRED</a> to request that the client use a protocol that supports renegotiation.</p></div><div id="rfc.section.9.2.1.p.6"><p>Implementations <em class="bcp14">MUST</em> support ephemeral key exchange sizes of at least 2048 bits for cipher suites that use ephemeral finite field Diffie-Hellman (DHE) (<a href="https://www.rfc-editor.org/rfc/rfc5246.html#section-8.1.2">Section 8.1.2</a> of <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite></a>) and 224 bits for cipher suites that use ephemeral elliptic curve Diffie-Hellman (ECDHE) <a href="#RFC8422"><cite title="Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier">[RFC8422]</cite></a>. Clients <em class="bcp14">MUST</em> accept DHE sizes of up to 4096 bits. Endpoints <em class="bcp14">MAY</em> treat negotiation of key sizes smaller than the lower limits as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#INADEQUATE_SECURITY">INADEQUATE_SECURITY</a>.</p></div></section><section id="tls12ciphers"><h4 id="rfc.section.9.2.2"><a href="#rfc.section.9.2.2">9.2.2.</a>&nbsp;<a href="#tls12ciphers">TLS 1.2 Cipher Suites</a></h4><div id="rfc.section.9.2.2.p.1"><p>A deployment of HTTP/2 over TLS 1.2 <em class="bcp14">SHOULD NOT</em> use any of the prohibited cipher suites listed in <a href="#BadCipherSuites" title="Prohibited TLS 1.2 Cipher Suites">Appendix A</a>.</p></div><div id="rfc.section.9.2.2.p.2"><p>Endpoints <em class="bcp14">MAY</em> choose to generate a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#INADEQUATE_SECURITY">INADEQUATE_SECURITY</a> if one of the prohibited cipher suites is negotiated. A deployment that chooses to use a prohibited cipher suite risks triggering a connection error unless the set of potential peers is known to accept that cipher suite.</p></div><div id="rfc.section.9.2.2.p.3"><p>Implementations <em class="bcp14">MUST NOT</em> generate this error in reaction to the negotiation of a cipher suite that is not prohibited. Consequently, when clients offer a cipher suite that is not prohibited, they have to be prepared to use that cipher suite with HTTP/2.</p></div><div id="rfc.section.9.2.2.p.4"><p>The list of prohibited cipher suites includes the cipher suite that TLS 1.2 makes mandatory, which means that TLS 1.2 deployments could have non-intersecting sets of permitted cipher suites. To avoid this problem, which causes TLS handshake failures, deployments of HTTP/2 that use TLS 1.2 <em class="bcp14">MUST</em> support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 <a href="#RFC5289"><cite title="TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)">[TLS-ECDHE]</cite></a> with the P-256 elliptic curve <a href="#RFC8422"><cite title="Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier">[RFC8422]</cite></a>.</p></div><div id="rfc.section.9.2.2.p.5"><p>Note that clients might advertise support of cipher suites that are prohibited in order to allow for connection to servers that do not support HTTP/2. This allows servers to select HTTP/1.1 with a cipher suite that is prohibited in HTTP/2. However, this can result in HTTP/2 being negotiated with a prohibited cipher suite if the application protocol and cipher suite are independently selected.</p></div></section><section id="tls13features"><h4 id="rfc.section.9.2.3"><a href="#rfc.section.9.2.3">9.2.3.</a>&nbsp;<a href="#tls13features">TLS 1.3 Features</a></h4><div id="rfc.section.9.2.3.p.1"><p>TLS 1.3 includes a number of features not available in earlier versions. This section discusses the use of these features.</p></div><div id="rfc.section.9.2.3.p.2"><p>HTTP/2 servers <em class="bcp14">MUST NOT</em> send post-handshake TLS 1.3 CertificateRequest messages. HTTP/2 clients <em class="bcp14">MUST</em> treat a TLS post-handshake CertificateRequest message as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.9.2.3.p.3"><p>The prohibition on post-handshake authentication applies even if the client offered the "post_handshake_auth" TLS extension. Post-handshake authentication support might be advertised independently of <a href="#RFC7301"><cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">ALPN</cite></a> <cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite>. Clients might offer the capability for use in other protocols, but inclusion of the extension cannot imply support within HTTP/2.</p></div><div id="rfc.section.9.2.3.p.4"><p><a href="#RFC8446"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[TLS13]</cite></a> defines other post-handshake messages, NewSessionTicket and KeyUpdate, which can be used as they have no direct interaction with HTTP/2. Unless the use of a new type of TLS message depends on an interaction with the application-layer protocol, that TLS message can be sent after the handshake completes.</p></div><div id="rfc.section.9.2.3.p.5"><p>TLS early data <em class="bcp14">MAY</em> be used to send requests, provided that the guidance in <a href="#RFC8470"><cite title="Using Early Data in HTTP">[RFC8470]</cite></a> is observed. Clients send requests in early data assuming initial values for all server settings.</p></div></section></section></section><hr class="hidden-print"><section id="security"><h2 id="rfc.section.10" class="np"><a href="#rfc.section.10">10.</a>&nbsp;<a href="#security">Security Considerations</a></h2><div id="rfc.section.10.p.1"><p>The use of TLS is necessary to provide many of the security properties of this protocol. Many of the claims in this section do not hold unless TLS is used as described in <a href="#TLSUsage" title="Use of TLS Features">Section 9.2</a>.</p></div><section id="authority"><h3 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a>&nbsp;<a href="#authority">Server Authority</a></h3><div id="rfc.section.10.1.p.1"><p>HTTP/2 relies on the HTTP definition of authority for determining whether a server is authoritative in providing a given response (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-4.3">Section 4.3</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>). This relies on local name resolution for the "<span class="tt">http</span>" URI scheme and the authenticated server identity for the "<span class="tt">https</span>" scheme.</p></div></section><section id="n-cross-protocol-attacks"><h3 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a>&nbsp;<a href="#n-cross-protocol-attacks">Cross-Protocol Attacks</a></h3><div id="rfc.section.10.2.p.1"><p>In a cross-protocol attack, an attacker causes a client to initiate a transaction in one protocol toward a server that understands a different protocol. An attacker might be able to cause the transaction to appear as a valid transaction in the second protocol. In combination with the capabilities of the web context, this can be used to interact with poorly protected servers in private networks.</p></div><div id="rfc.section.10.2.p.2"><p>Completing a TLS handshake with an ALPN identifier for HTTP/2 can be considered sufficient protection against cross-protocol attacks. ALPN provides a positive indication that a server is willing to proceed with HTTP/2, which prevents attacks on other TLS-based protocols.</p></div><div id="rfc.section.10.2.p.3"><p>The encryption in TLS makes it difficult for attackers to control the data that could be used in a cross-protocol attack on a cleartext protocol.</p></div><div id="rfc.section.10.2.p.4"><p>The cleartext version of HTTP/2 has minimal protection against cross-protocol attacks. The connection preface (<a href="#preface" title="HTTP/2 Connection Preface">Section 3.4</a>) contains a string that is designed to confuse HTTP/1.1 servers, but no special protection is offered for other protocols.</p></div></section><section id="n-intermediary-encapsulation-attacks"><h3 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3.</a>&nbsp;<a href="#n-intermediary-encapsulation-attacks">Intermediary Encapsulation Attacks</a></h3><div id="rfc.section.10.3.p.1"><p>HPACK permits encoding of field names and values that might be treated as delimiters in other HTTP versions. An intermediary that translates an HTTP/2 request or response <em class="bcp14">MUST</em> validate fields according to the rules in <a href="#HttpHeaders" title="HTTP Fields">Section 8.2</a> before translating a message to another HTTP version. Translating a field that includes invalid delimiters could be used to cause recipients to incorrectly interpret a message, which could be exploited by an attacker.</p></div><div id="rfc.section.10.3.p.2"><p><a href="#HttpHeaders" title="HTTP Fields">Section 8.2</a> does not include specific rules for validation of pseudo-header fields. If the values of these fields are used, additional validation is necessary. This is particularly important where "<span class="tt">:scheme</span>", "<span class="tt">:authority</span>", and "<span class="tt">:path</span>" are combined to form a single URI string <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>. Similar problems might occur when that URI or just "<span class="tt">:path</span>" is combined with "<span class="tt">:method</span>" to construct a request line (as in <a href="https://www.rfc-editor.org/rfc/rfc9112.html#section-3">Section 3</a> of <a href="#RFC9112"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>). Simple concatenation is not secure unless the input values are fully validated.</p></div><div id="rfc.section.10.3.p.3"><p>An intermediary can reject fields that contain invalid field names or values for other reasons -- in particular, those fields that do not conform to the HTTP ABNF grammar from <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5">Section 5</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>. Intermediaries that do not perform any validation of fields other than the minimum required by <a href="#HttpHeaders" title="HTTP Fields">Section 8.2</a> could forward messages that contain invalid field names or values.</p></div><div id="rfc.section.10.3.p.4"><p>An intermediary that receives any fields that require removal before forwarding (see <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.6.1">Section 7.6.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>) <em class="bcp14">MUST</em> remove or replace those header fields when forwarding messages. Additionally, intermediaries should take care when forwarding messages containing <span class="tt">Content-Length</span> fields to ensure that the message is well-formed (<a href="#malformed" title="Malformed Messages">Section 8.1.1</a>). This ensures that if the message is translated into HTTP/1.1 at any point, the framing will be correct.</p></div></section><section id="n-cacheability-of-pushed-responses"><h3 id="rfc.section.10.4"><a href="#rfc.section.10.4">10.4.</a>&nbsp;<a href="#n-cacheability-of-pushed-responses">Cacheability of Pushed Responses</a></h3><div id="rfc.section.10.4.p.1"><p>Pushed responses do not have an explicit request from the client; the request is provided by the server in the <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frame.</p></div><div id="rfc.section.10.4.p.2"><p>Caching responses that are pushed is possible based on the guidance provided by the origin server in the Cache-Control header field. However, this can cause issues if a single server hosts more than one tenant. For example, a server might offer multiple users each a small portion of its URI space.</p></div><div id="rfc.section.10.4.p.3"><p>Where multiple tenants share space on the same server, that server <em class="bcp14">MUST</em> ensure that tenants are not able to push representations of resources that they do not have authority over. Failure to enforce this would allow a tenant to provide a representation that would be served out of cache, overriding the actual representation that the authoritative tenant provides.</p></div><div id="rfc.section.10.4.p.4"><p>Pushed responses for which an origin server is not authoritative (see <a href="#authority" title="Server Authority">Section 10.1</a>) <em class="bcp14">MUST NOT</em> be used or cached.</p></div></section><section id="dos"><h3 id="rfc.section.10.5"><a href="#rfc.section.10.5">10.5.</a>&nbsp;<a href="#dos">Denial-of-Service Considerations</a></h3><div id="rfc.section.10.5.p.1"><p>An HTTP/2 connection can demand a greater commitment of resources to operate than an HTTP/1.1 connection. Both field section compression and flow control depend on a commitment of a greater amount of state. Settings for these features ensure that memory commitments for these features are strictly bounded.</p></div><div id="rfc.section.10.5.p.2"><p>The number of <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames is not constrained in the same fashion. A client that accepts server push <em class="bcp14">SHOULD</em> limit the number of streams it allows to be in the "reserved (remote)" state. An excessive number of server push streams can be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>) of type <a href="#ENHANCE_YOUR_CALM">ENHANCE_YOUR_CALM</a>.</p></div><div id="rfc.section.10.5.p.3" class="avoidbreakafter"><p>A number of HTTP/2 implementations were found to be vulnerable to denial of service <a href="#NFLX-2019-002"><cite title="HTTP/2 Denial of Service Advisory">[NFLX-2019-002]</cite></a>. Below is a list of known ways that implementations might be subject to denial-of-service attacks:</p></div><div id="rfc.section.10.5.p.4"><ul><li><div class="avoidbreakafter"><p>Inefficient tracking of outstanding outbound frames can lead to overload if an adversary can cause large numbers of frames to be enqueued for sending. A peer could use one of several techniques to cause large numbers of frames to be generated:</p></div> <div><ul><li>Providing tiny increments to flow control in <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a> frames can cause a sender to generate a large number of <a href="#DATA" title="DATA">DATA</a> frames.</li><li>An endpoint is required to respond to a <a href="#PING" title="PING">PING</a> frame.</li><li>Each <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame requires acknowledgment.</li><li>An invalid request (or server push) can cause a peer to send <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> frames in response.</li></ul></div> </li><li>An attacker can provide large amounts of flow-control credit at the HTTP/2 layer but withhold credit at the TCP layer, preventing frames from being sent. An endpoint that constructs and remembers frames for sending without considering TCP limits might be subject to resource exhaustion.</li><li>Large numbers of small or empty frames can be abused to cause a peer to expend time processing frame headers. Caution is required here as some uses of small frames are entirely legitimate, such as the sending of an empty <a href="#DATA" title="DATA">DATA</a> or <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> frame at the end of a stream.</li><li>The <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> frame might also be abused to cause a peer to expend additional processing time. This might be done by pointlessly changing settings, sending multiple undefined settings, or changing the same setting multiple times in the same frame.</li><li>Handling reprioritization with <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> frames can require significant processing time and can lead to overload if many <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> frames are sent.</li><li>Field section compression also provides opportunities for an attacker to waste processing resources; see <a href="https://www.rfc-editor.org/rfc/rfc7541.html#section-7">Section 7</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a> for more details on potential abuses.</li><li>Limits in <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> cannot be reduced instantaneously, which leaves an endpoint exposed to behavior from a peer that could exceed the new limits. In particular, immediately after establishing a connection, limits set by a server are not known to clients and could be exceeded without being an obvious protocol violation.</li></ul></div><div id="rfc.section.10.5.p.5"><p>Most of the features that might be exploited for denial of service -- such as <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> changes, small frames, field section compression -- have legitimate uses. These features become a burden only when they are used unnecessarily or to excess.</p></div><div id="rfc.section.10.5.p.6"><p>An endpoint that doesn't monitor use of these features exposes itself to a risk of denial of service. Implementations <em class="bcp14">SHOULD</em> track the use of these features and set limits on their use. An endpoint <em class="bcp14">MAY</em> treat activity that is suspicious as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#ENHANCE_YOUR_CALM">ENHANCE_YOUR_CALM</a>.</p></div><section id="MaxFieldBlock"><h4 id="rfc.section.10.5.1"><a href="#rfc.section.10.5.1">10.5.1.</a>&nbsp;<a href="#MaxFieldBlock">Limits on Field Block Size</a></h4><div id="rfc.section.10.5.1.p.1"><p>A large field block (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>) can cause an implementation to commit a large amount of state. Field lines that are critical for routing can appear toward the end of a field block, which prevents streaming of fields to their ultimate destination. This ordering and other reasons, such as ensuring cache correctness, mean that an endpoint might need to buffer the entire field block. Since there is no hard limit to the size of a field block, some endpoints could be forced to commit a large amount of available memory for field blocks.</p></div><div id="rfc.section.10.5.1.p.2"><p>An endpoint can use the <a href="#SETTINGS_MAX_HEADER_LIST_SIZE">SETTINGS_MAX_HEADER_LIST_SIZE</a> to advise peers of limits that might apply on the size of uncompressed field blocks. This setting is only advisory, so endpoints <em class="bcp14">MAY</em> choose to send field blocks that exceed this limit and risk the request or response being treated as malformed. This setting is specific to a connection, so any request or response could encounter a hop with a lower, unknown limit. An intermediary can attempt to avoid this problem by passing on values presented by different peers, but they are not obliged to do so.</p></div><div id="rfc.section.10.5.1.p.3"><p>A server that receives a larger field block than it is willing to handle can send an HTTP 431 (Request Header Fields Too Large) status code <a href="#RFC6585"><cite title="Additional HTTP Status Codes">[RFC6585]</cite></a>. A client can discard responses that it cannot process. The field block <em class="bcp14">MUST</em> be processed to ensure a consistent connection state, unless the connection is closed.</p></div></section><section id="connectDos"><h4 id="rfc.section.10.5.2"><a href="#rfc.section.10.5.2">10.5.2.</a>&nbsp;<a href="#connectDos">CONNECT Issues</a></h4><div id="rfc.section.10.5.2.p.1"><p>The CONNECT method can be used to create disproportionate load on a proxy, since stream creation is relatively inexpensive when compared to the creation and maintenance of a TCP connection. A proxy might also maintain some resources for a TCP connection beyond the closing of the stream that carries the CONNECT request, since the outgoing TCP connection remains in the TIME_WAIT state. Therefore, a proxy cannot rely on <a href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a> alone to limit the resources consumed by CONNECT requests.</p></div></section></section><section id="n-use-of-compression"><h3 id="rfc.section.10.6"><a href="#rfc.section.10.6">10.6.</a>&nbsp;<a href="#n-use-of-compression">Use of Compression</a></h3><div id="rfc.section.10.6.p.1"><p>Compression can allow an attacker to recover secret data when it is compressed in the same context as data under attacker control. HTTP/2 enables compression of field lines (<a href="#FieldBlock" title="Field Section Compression and Decompression">Section 4.3</a>); the following concerns also apply to the use of HTTP compressed content-codings (<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-8.4.1">Section 8.4.1</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>).</p></div><div id="rfc.section.10.6.p.2"><p>There are demonstrable attacks on compression that exploit the characteristics of the Web (e.g., <a href="#BREACH"><cite title="BREACH: Reviving the CRIME Attack">[BREACH]</cite></a>). The attacker induces multiple requests containing varying plaintext, observing the length of the resulting ciphertext in each, which reveals a shorter length when a guess about the secret is correct.</p></div><div id="rfc.section.10.6.p.3"><p>Implementations communicating on a secure channel <em class="bcp14">MUST NOT</em> compress content that includes both confidential and attacker-controlled data unless separate compression dictionaries are used for each source of data. Compression <em class="bcp14">MUST NOT</em> be used if the source of data cannot be reliably determined. Generic stream compression, such as that provided by TLS, <em class="bcp14">MUST NOT</em> be used with HTTP/2 (see <a href="#TLSUsage" title="Use of TLS Features">Section 9.2</a>).</p></div><div id="rfc.section.10.6.p.4"><p>Further considerations regarding the compression of header fields are described in <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>.</p></div></section><section id="padding"><h3 id="rfc.section.10.7"><a href="#rfc.section.10.7">10.7.</a>&nbsp;<a href="#padding">Use of Padding</a></h3><div id="rfc.section.10.7.p.1"><p>Padding within HTTP/2 is not intended as a replacement for general purpose padding, such as that provided by <a href="#RFC8446"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">TLS</cite></a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[TLS13]</cite>. Redundant padding could even be counterproductive. Correct application can depend on having specific knowledge of the data that is being padded.</p></div><div id="rfc.section.10.7.p.2"><p>To mitigate attacks that rely on compression, disabling or limiting compression might be preferable to padding as a countermeasure.</p></div><div id="rfc.section.10.7.p.3"><p>Padding can be used to obscure the exact size of frame content and is provided to mitigate specific attacks within HTTP -- for example, attacks where compressed content includes both attacker-controlled plaintext and secret data (e.g., <a href="#BREACH"><cite title="BREACH: Reviving the CRIME Attack">[BREACH]</cite></a>).</p></div><div id="rfc.section.10.7.p.4"><p>Use of padding can result in less protection than might seem immediately obvious. At best, padding only makes it more difficult for an attacker to infer length information by increasing the number of frames an attacker has to observe. Incorrectly implemented padding schemes can be easily defeated. In particular, randomized padding with a predictable distribution provides very little protection; similarly, padding frame payloads to a fixed size exposes information as frame payload sizes cross the fixed-sized boundary, which could be possible if an attacker can control plaintext.</p></div><div id="rfc.section.10.7.p.5"><p>Intermediaries <em class="bcp14">SHOULD</em> retain padding for <a href="#DATA" title="DATA">DATA</a> frames but <em class="bcp14">MAY</em> drop padding for <a href="#HEADERS" title="HEADERS">HEADERS</a> and <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> frames. A valid reason for an intermediary to change the amount of padding of frames is to improve the protections that padding provides.</p></div></section><section id="n-privacy-considerations"><h3 id="rfc.section.10.8"><a href="#rfc.section.10.8">10.8.</a>&nbsp;<a href="#n-privacy-considerations">Privacy Considerations</a></h3><div id="rfc.section.10.8.p.1"><p>Several characteristics of HTTP/2 provide an observer an opportunity to correlate actions of a single client or server over time. These include the values of settings, the manner in which flow-control windows are managed, the way priorities are allocated to streams, the timing of reactions to stimulus, and the handling of any features that are controlled by settings.</p></div><div id="rfc.section.10.8.p.2"><p>As far as these create observable differences in behavior, they could be used as a basis for fingerprinting a specific client, as defined in <a href="https://www.rfc-editor.org/rfc/rfc6973.html#section-3.2">Section 3.2</a> of <a href="#RFC6973"><cite title="Privacy Considerations for Internet Protocols">[PRIVACY]</cite></a>.</p></div><div id="rfc.section.10.8.p.3"><p>HTTP/2's preference for using a single TCP connection allows correlation of a user's activity on a site. Reusing connections for different origins allows tracking across those origins.</p></div><div id="rfc.section.10.8.p.4"><p>Because the PING and SETTINGS frames solicit immediate responses, they can be used by an endpoint to measure latency to their peer. This might have privacy implications in certain scenarios.</p></div></section><section id="n-remote-timing-attacks"><h3 id="rfc.section.10.9"><a href="#rfc.section.10.9">10.9.</a>&nbsp;<a href="#n-remote-timing-attacks">Remote Timing Attacks</a></h3><div id="rfc.section.10.9.p.1"><p>Remote timing attacks extract secrets from servers by observing variations in the time that servers take when processing requests that use secrets. HTTP/2 enables concurrent request creation and processing, which can give attackers better control over when request processing commences. Multiple HTTP/2 requests can be included in the same IP packet or TLS record. HTTP/2 can therefore make remote timing attacks more efficient by eliminating variability in request delivery, leaving only request order and the delivery of responses as sources of timing variability.</p></div><div id="rfc.section.10.9.p.2"><p>Ensuring that processing time is not dependent on the value of a secret is the best defense against any form of timing attack.</p></div></section></section><hr class="hidden-print"><section id="iana"><h2 id="rfc.section.11" class="np"><a href="#rfc.section.11">11.</a>&nbsp;<a href="#iana">IANA Considerations</a></h2><div id="rfc.section.11.p.1"><p>This revision of HTTP/2 marks the <span class="tt">HTTP2-Settings</span> header field and the <span class="tt">h2c</span> upgrade token, both defined in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, as obsolete.</p></div><div id="rfc.section.11.p.2"><p><a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-11">Section 11</a> of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> registered the <span class="tt">h2</span> and <span class="tt">h2c</span> ALPN identifiers along with the <span class="tt">PRI</span> HTTP method. RFC 7540 also established a registry for frame types, settings, and error codes. These registrations and registries apply to HTTP/2, but are not redefined in this document.</p></div><div id="rfc.section.11.p.3"><p>IANA has updated references to RFC 7540 in the following registries to refer to this document: "TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs", "HTTP/2 Frame Type", "HTTP/2 Settings", "HTTP/2 Error Code", and "HTTP Method Registry". The registration of the <span class="tt">PRI</span> method has been updated to refer to <a href="#preface" title="HTTP/2 Connection Preface">Section 3.4</a>; all other section numbers have not changed.</p></div><div id="rfc.section.11.p.4"><p>IANA has changed the policy on those portions of the "HTTP/2 Frame Type" and "HTTP/2 Settings" registries that were reserved for Experimental Use in RFC 7540. These portions of the registries shall operate on the same policy as the remainder of each registry.</p></div><section id="HTTP2-Settings"><h3 id="rfc.section.11.1"><a href="#rfc.section.11.1">11.1.</a>&nbsp;<a href="#HTTP2-Settings">HTTP2-Settings Header Field Registration</a></h3><div id="rfc.section.11.1.p.1" class="avoidbreakafter"><p>This section marks the <span class="tt">HTTP2-Settings</span> header field registered by <a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-11.5">Section 11.5</a> of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" as obsolete. This capability has been removed: see <a href="#versioning" title="HTTP/2 Version Identification">Section 3.1</a>. The registration is updated to include the details as required by <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-18.4">Section 18.4</a> of <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a>:</p></div><div id="rfc.section.11.1.p.2"><dl><dt>Field Name:</dt><dd style="margin-left: 1.5em">HTTP2-Settings</dd><dt>Status:</dt><dd style="margin-left: 1.5em">obsoleted</dd><dt>Reference:</dt><dd style="margin-left: 1.5em"><a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-3.2.1">Section 3.2.1</a> of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>&nbsp;</dd><dt>Comments:</dt><dd style="margin-left: 1.5em">Obsolete; see <a href="#HTTP2-Settings" title="HTTP2-Settings Header Field Registration">Section 11.1</a> of this document.</dd></dl></div></section><section id="iana-h2c"><h3 id="rfc.section.11.2"><a href="#rfc.section.11.2">11.2.</a>&nbsp;<a href="#iana-h2c">The h2c Upgrade Token</a></h3><div id="rfc.section.11.2.p.1" class="avoidbreakafter"><p>This section records the <span class="tt">h2c</span> upgrade token registered by <a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-11.8">Section 11.8</a> of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> in the "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" as obsolete. This capability has been removed: see <a href="#versioning" title="HTTP/2 Version Identification">Section 3.1</a>. The registration is updated as follows:</p></div><div id="rfc.section.11.2.p.2"><dl><dt>Value:</dt><dd style="margin-left: 1.5em">h2c</dd><dt>Description:</dt><dd style="margin-left: 1.5em">(OBSOLETE) Hypertext Transfer Protocol version 2 (HTTP/2)</dd><dt>Expected Version Tokens:</dt><dd style="margin-left: 1.5em">None</dd><dt>Reference:</dt><dd style="margin-left: 1.5em"><a href="#versioning" title="HTTP/2 Version Identification">Section 3.1</a> of this document</dd></dl></div></section></section><section class="np"><div id="rfc.references"><h2 id="rfc.section.12"><a href="#rfc.section.12">12.</a> References</h2><section><div id="rfc.references.2"><h3 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1.</a> Normative References</h3><dl class="dl-horizontal"><dt id="RFC9111">[CACHING]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., â€œ<a href="https://www.rfc-editor.org/rfc/rfc9111.html">HTTP Caching</a>â€, <a href="https://www.rfc-editor.org/info/std98">STD 98</a>, RFC 9111, <a href="https://dx.doi.org/10.17487/RFC9111">DOI 10.17487/RFC9111</a>, June 2022, &lt;<a href="https://www.rfc-editor.org/info/rfc9111">https://www.rfc-editor.org/info/rfc9111</a>&gt;.</dd><dt id="RFC7541">[COMPRESSION]</dt><dd>Peon, R. and H. Ruellan, â€œ<a href="https://www.rfc-editor.org/rfc/rfc7541.html">HPACK: Header Compression for HTTP/2</a>â€, RFC 7541, <a href="https://dx.doi.org/10.17487/RFC7541">DOI 10.17487/RFC7541</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;.</dd><dt id="RFC6265">[COOKIE]</dt><dd>Barth, A., â€œ<a href="https://www.rfc-editor.org/rfc/rfc6265.html">HTTP State Management Mechanism</a>â€, RFC 6265, <a href="https://dx.doi.org/10.17487/RFC6265">DOI 10.17487/RFC6265</a>, April 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.</dd><dt id="RFC9110">[HTTP]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., â€œ<a href="https://www.rfc-editor.org/rfc/rfc9110.html">HTTP Semantics</a>â€, <a href="https://www.rfc-editor.org/info/std97">STD 97</a>, RFC 9110, <a href="https://dx.doi.org/10.17487/RFC9110">DOI 10.17487/RFC9110</a>, June 2022, &lt;<a href="https://www.rfc-editor.org/info/rfc9110">https://www.rfc-editor.org/info/rfc9110</a>&gt;.</dd><dt id="RFC9000">[QUIC]</dt><dd>Iyengar, J., Ed. and M. Thomson, Ed., â€œ<a href="https://www.rfc-editor.org/rfc/rfc9000.html">QUIC: A UDP-Based Multiplexed and Secure Transport</a>â€, RFC 9000, <a href="https://dx.doi.org/10.17487/RFC9000">DOI 10.17487/RFC9000</a>, May 2021, &lt;<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., â€œ<a href="https://www.rfc-editor.org/rfc/rfc2119.html">Key words for use in RFCs to Indicate Requirement Levels</a>â€, <a href="https://www.rfc-editor.org/info/bcp14">BCP 14</a>, RFC 2119, <a href="https://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC3986">[RFC3986]</dt><dd>Berners-Lee, T., Fielding, R., and L. Masinter, â€œ<a href="https://www.rfc-editor.org/rfc/rfc3986.html">Uniform Resource Identifier (URI): Generic Syntax</a>â€, <a href="https://www.rfc-editor.org/info/std66">STD 66</a>, RFC 3986, <a href="https://dx.doi.org/10.17487/RFC3986">DOI 10.17487/RFC3986</a>, January 2005, &lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., â€œ<a href="https://www.rfc-editor.org/rfc/rfc8174.html">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>â€, <a href="https://www.rfc-editor.org/info/bcp14">BCP 14</a>, RFC 8174, <a href="https://dx.doi.org/10.17487/RFC8174">DOI 10.17487/RFC8174</a>, May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd><dt id="RFC8422">[RFC8422]</dt><dd>Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, â€œ<a href="https://www.rfc-editor.org/rfc/rfc8422.html">Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier</a>â€, RFC 8422, <a href="https://dx.doi.org/10.17487/RFC8422">DOI 10.17487/RFC8422</a>, August 2018, &lt;<a href="https://www.rfc-editor.org/info/rfc8422">https://www.rfc-editor.org/info/rfc8422</a>&gt;.</dd><dt id="RFC8470">[RFC8470]</dt><dd>Thomson, M., Nottingham, M., and W. Tarreau, â€œ<a href="https://www.rfc-editor.org/rfc/rfc8470.html">Using Early Data in HTTP</a>â€, RFC 8470, <a href="https://dx.doi.org/10.17487/RFC8470">DOI 10.17487/RFC8470</a>, September 2018, &lt;<a href="https://www.rfc-editor.org/info/rfc8470">https://www.rfc-editor.org/info/rfc8470</a>&gt;.</dd><dt id="RFC0793">[TCP]</dt><dd>Postel, J., â€œ<a href="https://www.rfc-editor.org/rfc/rfc793.html">Transmission Control Protocol</a>â€, <a href="https://www.rfc-editor.org/info/std7">STD 7</a>, RFC 793, <a href="https://dx.doi.org/10.17487/RFC0793">DOI 10.17487/RFC0793</a>, September 1981, &lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;.</dd><dt id="RFC7301">[TLS-ALPN]</dt><dd>Friedl, S., Popov, A., Langley, A., and E. Stephan, â€œ<a href="https://www.rfc-editor.org/rfc/rfc7301.html">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>â€, RFC 7301, <a href="https://dx.doi.org/10.17487/RFC7301">DOI 10.17487/RFC7301</a>, July 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7301">https://www.rfc-editor.org/info/rfc7301</a>&gt;.</dd><dt id="RFC5289">[TLS-ECDHE]</dt><dd>Rescorla, E., â€œ<a href="https://www.rfc-editor.org/rfc/rfc5289.html">TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)</a>â€, RFC 5289, <a href="https://dx.doi.org/10.17487/RFC5289">DOI 10.17487/RFC5289</a>, August 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5289">https://www.rfc-editor.org/info/rfc5289</a>&gt;.</dd><dt id="RFC6066">[TLS-EXT]</dt><dd>Eastlake 3rd, D., â€œ<a href="https://www.rfc-editor.org/rfc/rfc6066.html">Transport Layer Security (TLS) Extensions: Extension Definitions</a>â€, RFC 6066, <a href="https://dx.doi.org/10.17487/RFC6066">DOI 10.17487/RFC6066</a>, January 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6066">https://www.rfc-editor.org/info/rfc6066</a>&gt;.</dd><dt id="RFC5246">[TLS12]</dt><dd>Dierks, T. and E. Rescorla, â€œ<a href="https://www.rfc-editor.org/rfc/rfc5246.html">The Transport Layer Security (TLS) Protocol Version 1.2</a>â€, RFC 5246, <a href="https://dx.doi.org/10.17487/RFC5246">DOI 10.17487/RFC5246</a>, August 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5246">https://www.rfc-editor.org/info/rfc5246</a>&gt;.</dd><dt id="RFC8446">[TLS13]</dt><dd>Rescorla, E., â€œ<a href="https://www.rfc-editor.org/rfc/rfc8446.html">The Transport Layer Security (TLS) Protocol Version 1.3</a>â€, RFC 8446, <a href="https://dx.doi.org/10.17487/RFC8446">DOI 10.17487/RFC8446</a>, August 2018, &lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;.</dd><dt id="RFC7525">[TLSBCP]</dt><dd>Sheffer, Y., Holz, R., and P. Saint-Andre, â€œ<a href="https://www.rfc-editor.org/rfc/rfc7525.html">Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>â€, <a href="https://www.rfc-editor.org/info/bcp195">BCP 195</a>, RFC 7525, <a href="https://dx.doi.org/10.17487/RFC7525">DOI 10.17487/RFC7525</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7525">https://www.rfc-editor.org/info/rfc7525</a>&gt;.</dd></dl></div></section><section><div id="rfc.references.3"><h3 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2.</a> Informative References</h3><dl class="dl-horizontal"><dt id="RFC7838">[ALT-SVC]</dt><dd>Nottingham, M., McManus, P., and J. Reschke, â€œ<a href="https://www.rfc-editor.org/rfc/rfc7838.html">HTTP Alternative Services</a>â€, RFC 7838, <a href="https://dx.doi.org/10.17487/RFC7838">DOI 10.17487/RFC7838</a>, April 2016, &lt;<a href="https://www.rfc-editor.org/info/rfc7838">https://www.rfc-editor.org/info/rfc7838</a>&gt;.</dd><dt id="BREACH">[BREACH]</dt><dd>Gluck, Y., Harris, N., and A. Prado, â€œ<a href="https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">BREACH: Reviving the CRIME Attack</a>â€, July 2013, &lt;<a href="https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf</a>&gt;.</dd><dt id="RFC8499">[DNS-TERMS]</dt><dd>Hoffman, P., Sullivan, A., and K. Fujiwara, â€œ<a href="https://www.rfc-editor.org/rfc/rfc8499.html">DNS Terminology</a>â€, <a href="https://www.rfc-editor.org/info/bcp219">BCP 219</a>, RFC 8499, <a href="https://dx.doi.org/10.17487/RFC8499">DOI 10.17487/RFC8499</a>, January 2019, &lt;<a href="https://www.rfc-editor.org/info/rfc8499">https://www.rfc-editor.org/info/rfc8499</a>&gt;.</dd><dt id="RFC9218">[HTTP-PRIORITY]</dt><dd>Oku, K. and L. Pardue, â€œ<a href="https://www.rfc-editor.org/rfc/rfc9218.html">Extensible Prioritization Scheme for HTTP</a>â€, RFC 9218, <a href="https://dx.doi.org/10.17487/RFC9218">DOI 10.17487/RFC9218</a>, June 2022, &lt;<a href="https://www.rfc-editor.org/info/rfc9218">https://www.rfc-editor.org/info/rfc9218</a>&gt;.</dd><dt id="RFC9112">[HTTP/1.1]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., â€œ<a href="https://www.rfc-editor.org/rfc/rfc9112.html">HTTP/1.1</a>â€, <a href="https://www.rfc-editor.org/info/std99">STD 99</a>, RFC 9112, <a href="https://dx.doi.org/10.17487/RFC9112">DOI 10.17487/RFC9112</a>, June 2022, &lt;<a href="https://www.rfc-editor.org/info/rfc9112">https://www.rfc-editor.org/info/rfc9112</a>&gt;.</dd><dt id="NFLX-2019-002">[NFLX-2019-002]</dt><dd>Netflix, â€œ<a href="https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md">HTTP/2 Denial of Service Advisory</a>â€, August 2019, &lt;<a href="https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md">https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md</a>&gt;.</dd><dt id="RFC6973">[PRIVACY]</dt><dd>Cooper, A., Tschofenig, H., Aboba, B., Peterson, J., Morris, J., Hansen, M., and R. Smith, â€œ<a href="https://www.rfc-editor.org/rfc/rfc6973.html">Privacy Considerations for Internet Protocols</a>â€, RFC 6973, <a href="https://dx.doi.org/10.17487/RFC6973">DOI 10.17487/RFC6973</a>, July 2013, &lt;<a href="https://www.rfc-editor.org/info/rfc6973">https://www.rfc-editor.org/info/rfc6973</a>&gt;.</dd><dt id="RFC1122">[RFC1122]</dt><dd>Braden, R., Ed., â€œ<a href="https://www.rfc-editor.org/rfc/rfc1122.html">Requirements for Internet Hosts - Communication Layers</a>â€, <a href="https://www.rfc-editor.org/info/std3">STD 3</a>, RFC 1122, <a href="https://dx.doi.org/10.17487/RFC1122">DOI 10.17487/RFC1122</a>, October 1989, &lt;<a href="https://www.rfc-editor.org/info/rfc1122">https://www.rfc-editor.org/info/rfc1122</a>&gt;.</dd><dt id="RFC3749">[RFC3749]</dt><dd>Hollenbeck, S., â€œ<a href="https://www.rfc-editor.org/rfc/rfc3749.html">Transport Layer Security Protocol Compression Methods</a>â€, RFC 3749, <a href="https://dx.doi.org/10.17487/RFC3749">DOI 10.17487/RFC3749</a>, May 2004, &lt;<a href="https://www.rfc-editor.org/info/rfc3749">https://www.rfc-editor.org/info/rfc3749</a>&gt;.</dd><dt id="RFC6125">[RFC6125]</dt><dd>Saint-Andre, P. and J. Hodges, â€œ<a href="https://www.rfc-editor.org/rfc/rfc6125.html">Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</a>â€, RFC 6125, <a href="https://dx.doi.org/10.17487/RFC6125">DOI 10.17487/RFC6125</a>, March 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6125">https://www.rfc-editor.org/info/rfc6125</a>&gt;.</dd><dt id="RFC6585">[RFC6585]</dt><dd>Nottingham, M. and R. Fielding, â€œ<a href="https://www.rfc-editor.org/rfc/rfc6585.html">Additional HTTP Status Codes</a>â€, RFC 6585, <a href="https://dx.doi.org/10.17487/RFC6585">DOI 10.17487/RFC6585</a>, April 2012, &lt;<a href="https://www.rfc-editor.org/info/rfc6585">https://www.rfc-editor.org/info/rfc6585</a>&gt;.</dd><dt id="RFC7323">[RFC7323]</dt><dd>Borman, D., Braden, B., Jacobson, V., and R. Scheffenegger, Ed., â€œ<a href="https://www.rfc-editor.org/rfc/rfc7323.html">TCP Extensions for High Performance</a>â€, RFC 7323, <a href="https://dx.doi.org/10.17487/RFC7323">DOI 10.17487/RFC7323</a>, September 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7323">https://www.rfc-editor.org/info/rfc7323</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., â€œ<a href="https://www.rfc-editor.org/rfc/rfc7540.html">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>â€, RFC 7540, <a href="https://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC8441">[RFC8441]</dt><dd>McManus, P., â€œ<a href="https://www.rfc-editor.org/rfc/rfc8441.html">Bootstrapping WebSockets with HTTP/2</a>â€, RFC 8441, <a href="https://dx.doi.org/10.17487/RFC8441">DOI 10.17487/RFC8441</a>, September 2018, &lt;<a href="https://www.rfc-editor.org/info/rfc8441">https://www.rfc-editor.org/info/rfc8441</a>&gt;.</dd><dt id="RFC8740">[RFC8740]</dt><dd>Benjamin, D., â€œ<a href="https://www.rfc-editor.org/rfc/rfc8740.html">Using TLS 1.3 with HTTP/2</a>â€, RFC 8740, <a href="https://dx.doi.org/10.17487/RFC8740">DOI 10.17487/RFC8740</a>, February 2020, &lt;<a href="https://www.rfc-editor.org/info/rfc8740">https://www.rfc-editor.org/info/rfc8740</a>&gt;.</dd><dt id="TALKING">[TALKING]</dt><dd>Huang, L., Chen, E., Barth, A., Rescorla, E., and C. Jackson, â€œ<a href="https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf">Talking to Yourself for Fun and Profit</a>â€, 2011, &lt;<a href="https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf">https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf</a>&gt;.</dd></dl></div></section></div></section><hr class="hidden-print"><section id="BadCipherSuites"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">Appendix A.</a>&nbsp;<a href="#BadCipherSuites">Prohibited TLS 1.2 Cipher Suites</a></h2><div id="rfc.section.A.p.1" class="avoidbreakafter"><p>An HTTP/2 implementation <em class="bcp14">MAY</em> treat the negotiation of any of the following cipher suites with TLS 1.2 as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>) of type <a href="#INADEQUATE_SECURITY">INADEQUATE_SECURITY</a>:</p></div><div id="rfc.section.A.p.2"><ul><li>TLS_NULL_WITH_NULL_NULL</li><li>TLS_RSA_WITH_NULL_MD5</li><li>TLS_RSA_WITH_NULL_SHA</li><li>TLS_RSA_EXPORT_WITH_RC4_40_MD5</li><li>TLS_RSA_WITH_RC4_128_MD5</li><li>TLS_RSA_WITH_RC4_128_SHA</li><li>TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5</li><li>TLS_RSA_WITH_IDEA_CBC_SHA</li><li>TLS_RSA_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_RSA_WITH_DES_CBC_SHA</li><li>TLS_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DH_DSS_WITH_DES_CBC_SHA</li><li>TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DH_RSA_WITH_DES_CBC_SHA</li><li>TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DHE_DSS_WITH_DES_CBC_SHA</li><li>TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DHE_RSA_WITH_DES_CBC_SHA</li><li>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DH_anon_EXPORT_WITH_RC4_40_MD5</li><li>TLS_DH_anon_WITH_RC4_128_MD5</li><li>TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DH_anon_WITH_DES_CBC_SHA</li><li>TLS_DH_anon_WITH_3DES_EDE_CBC_SHA</li><li>TLS_KRB5_WITH_DES_CBC_SHA</li><li>TLS_KRB5_WITH_3DES_EDE_CBC_SHA</li><li>TLS_KRB5_WITH_RC4_128_SHA</li><li>TLS_KRB5_WITH_IDEA_CBC_SHA</li><li>TLS_KRB5_WITH_DES_CBC_MD5</li><li>TLS_KRB5_WITH_3DES_EDE_CBC_MD5</li><li>TLS_KRB5_WITH_RC4_128_MD5</li><li>TLS_KRB5_WITH_IDEA_CBC_MD5</li><li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</li><li>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA</li><li>TLS_KRB5_EXPORT_WITH_RC4_40_SHA</li><li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</li><li>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5</li><li>TLS_KRB5_EXPORT_WITH_RC4_40_MD5</li><li>TLS_PSK_WITH_NULL_SHA</li><li>TLS_DHE_PSK_WITH_NULL_SHA</li><li>TLS_RSA_PSK_WITH_NULL_SHA</li><li>TLS_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_DH_DSS_WITH_AES_128_CBC_SHA</li><li>TLS_DH_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_DHE_DSS_WITH_AES_128_CBC_SHA</li><li>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_DH_anon_WITH_AES_128_CBC_SHA</li><li>TLS_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_DH_DSS_WITH_AES_256_CBC_SHA</li><li>TLS_DH_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_DHE_DSS_WITH_AES_256_CBC_SHA</li><li>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_DH_anon_WITH_AES_256_CBC_SHA</li><li>TLS_RSA_WITH_NULL_SHA256</li><li>TLS_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_RSA_WITH_AES_256_CBC_SHA256</li><li>TLS_DH_DSS_WITH_AES_128_CBC_SHA256</li><li>TLS_DH_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_AES_128_CBC_SHA256</li><li>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_DH_DSS_WITH_AES_256_CBC_SHA256</li><li>TLS_DH_RSA_WITH_AES_256_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_AES_256_CBC_SHA256</li><li>TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</li><li>TLS_DH_anon_WITH_AES_128_CBC_SHA256</li><li>TLS_DH_anon_WITH_AES_256_CBC_SHA256</li><li>TLS_RSA_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_PSK_WITH_RC4_128_SHA</li><li>TLS_PSK_WITH_3DES_EDE_CBC_SHA</li><li>TLS_PSK_WITH_AES_128_CBC_SHA</li><li>TLS_PSK_WITH_AES_256_CBC_SHA</li><li>TLS_DHE_PSK_WITH_RC4_128_SHA</li><li>TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DHE_PSK_WITH_AES_128_CBC_SHA</li><li>TLS_DHE_PSK_WITH_AES_256_CBC_SHA</li><li>TLS_RSA_PSK_WITH_RC4_128_SHA</li><li>TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA</li><li>TLS_RSA_PSK_WITH_AES_128_CBC_SHA</li><li>TLS_RSA_PSK_WITH_AES_256_CBC_SHA</li><li>TLS_RSA_WITH_SEED_CBC_SHA</li><li>TLS_DH_DSS_WITH_SEED_CBC_SHA</li><li>TLS_DH_RSA_WITH_SEED_CBC_SHA</li><li>TLS_DHE_DSS_WITH_SEED_CBC_SHA</li><li>TLS_DHE_RSA_WITH_SEED_CBC_SHA</li><li>TLS_DH_anon_WITH_SEED_CBC_SHA</li><li>TLS_RSA_WITH_AES_128_GCM_SHA256</li><li>TLS_RSA_WITH_AES_256_GCM_SHA384</li><li>TLS_DH_RSA_WITH_AES_128_GCM_SHA256</li><li>TLS_DH_RSA_WITH_AES_256_GCM_SHA384</li><li>TLS_DH_DSS_WITH_AES_128_GCM_SHA256</li><li>TLS_DH_DSS_WITH_AES_256_GCM_SHA384</li><li>TLS_DH_anon_WITH_AES_128_GCM_SHA256</li><li>TLS_DH_anon_WITH_AES_256_GCM_SHA384</li><li>TLS_PSK_WITH_AES_128_GCM_SHA256</li><li>TLS_PSK_WITH_AES_256_GCM_SHA384</li><li>TLS_RSA_PSK_WITH_AES_128_GCM_SHA256</li><li>TLS_RSA_PSK_WITH_AES_256_GCM_SHA384</li><li>TLS_PSK_WITH_AES_128_CBC_SHA256</li><li>TLS_PSK_WITH_AES_256_CBC_SHA384</li><li>TLS_PSK_WITH_NULL_SHA256</li><li>TLS_PSK_WITH_NULL_SHA384</li><li>TLS_DHE_PSK_WITH_AES_128_CBC_SHA256</li><li>TLS_DHE_PSK_WITH_AES_256_CBC_SHA384</li><li>TLS_DHE_PSK_WITH_NULL_SHA256</li><li>TLS_DHE_PSK_WITH_NULL_SHA384</li><li>TLS_RSA_PSK_WITH_AES_128_CBC_SHA256</li><li>TLS_RSA_PSK_WITH_AES_256_CBC_SHA384</li><li>TLS_RSA_PSK_WITH_NULL_SHA256</li><li>TLS_RSA_PSK_WITH_NULL_SHA384</li><li>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_EMPTY_RENEGOTIATION_INFO_SCSV</li><li>TLS_ECDH_ECDSA_WITH_NULL_SHA</li><li>TLS_ECDH_ECDSA_WITH_RC4_128_SHA</li><li>TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA</li><li>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA</li><li>TLS_ECDHE_ECDSA_WITH_NULL_SHA</li><li>TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</li><li>TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</li><li>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</li><li>TLS_ECDH_RSA_WITH_NULL_SHA</li><li>TLS_ECDH_RSA_WITH_RC4_128_SHA</li><li>TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_ECDHE_RSA_WITH_NULL_SHA</li><li>TLS_ECDHE_RSA_WITH_RC4_128_SHA</li><li>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_ECDH_anon_WITH_NULL_SHA</li><li>TLS_ECDH_anon_WITH_RC4_128_SHA</li><li>TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDH_anon_WITH_AES_128_CBC_SHA</li><li>TLS_ECDH_anon_WITH_AES_256_CBC_SHA</li><li>TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA</li><li>TLS_SRP_SHA_WITH_AES_128_CBC_SHA</li><li>TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA</li><li>TLS_SRP_SHA_WITH_AES_256_CBC_SHA</li><li>TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA</li><li>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256</li><li>TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384</li><li>TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256</li><li>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</li><li>TLS_ECDHE_PSK_WITH_RC4_128_SHA</li><li>TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA</li><li>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA</li><li>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDHE_PSK_WITH_NULL_SHA</li><li>TLS_ECDHE_PSK_WITH_NULL_SHA256</li><li>TLS_ECDHE_PSK_WITH_NULL_SHA384</li><li>TLS_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DH_anon_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DH_anon_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_RSA_WITH_ARIA_128_GCM_SHA256</li><li>TLS_RSA_WITH_ARIA_256_GCM_SHA384</li><li>TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256</li><li>TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384</li><li>TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256</li><li>TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384</li><li>TLS_DH_anon_WITH_ARIA_128_GCM_SHA256</li><li>TLS_DH_anon_WITH_ARIA_256_GCM_SHA384</li><li>TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256</li><li>TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384</li><li>TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256</li><li>TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384</li><li>TLS_PSK_WITH_ARIA_128_CBC_SHA256</li><li>TLS_PSK_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384</li><li>TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256</li><li>TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384</li><li>TLS_PSK_WITH_ARIA_128_GCM_SHA256</li><li>TLS_PSK_WITH_ARIA_256_GCM_SHA384</li><li>TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256</li><li>TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384</li><li>TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_RSA_WITH_AES_128_CCM</li><li>TLS_RSA_WITH_AES_256_CCM</li><li>TLS_RSA_WITH_AES_128_CCM_8</li><li>TLS_RSA_WITH_AES_256_CCM_8</li><li>TLS_PSK_WITH_AES_128_CCM</li><li>TLS_PSK_WITH_AES_256_CCM</li><li>TLS_PSK_WITH_AES_128_CCM_8</li><li>TLS_PSK_WITH_AES_256_CCM_8</li></ul></div><div id="rfc.section.A.p.3"><aside><div id="rfc.section.A.p.3.1"><p>Note: This list was assembled from the set of registered TLS cipher suites when <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> was developed. This list includes those cipher suites that do not offer an ephemeral key exchange and those that are based on the TLS null, stream, or block cipher type (as defined in <a href="https://www.rfc-editor.org/rfc/rfc5246.html#section-6.2.3">Section 6.2.3</a> of <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite></a>). Additional cipher suites with these properties could be defined; these would not be explicitly prohibited.</p></div></aside></div><div id="rfc.section.A.p.4"><p>For more details, see <a href="#tls12ciphers" title="TLS 1.2 Cipher Suites">Section 9.2.2</a>.</p></div></section><hr class="hidden-print"><section id="revision-updates"><h2 id="rfc.section.B" class="np"><a href="#rfc.section.B">Appendix B.</a>&nbsp;<a href="#revision-updates">Changes from RFC 7540</a></h2><div id="rfc.section.B.p.1" class="avoidbreakafter"><p>This revision includes the following substantive changes:</p></div><div id="rfc.section.B.p.2"><ul><li>Use of TLS 1.3 was defined based on <a href="#RFC8740"><cite title="Using TLS 1.3 with HTTP/2">[RFC8740]</cite></a>, which this document obsoletes.</li><li>The priority scheme defined in RFC 7540 is deprecated. Definitions for the format of the <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> frame and the priority fields in the <a href="#HEADERS" title="HEADERS">HEADERS</a> frame have been retained, plus the rules governing when <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> frames can be sent and received, but the semantics of these fields are only described in RFC 7540. The priority signaling scheme from RFC 7540 was not successful. Using the simpler signaling in <a href="#RFC9218"><cite title="Extensible Prioritization Scheme for HTTP">[HTTP-PRIORITY]</cite></a> is recommended.</li><li>The HTTP/1.1 Upgrade mechanism is deprecated and no longer specified in this document. It was never widely deployed, with plaintext HTTP/2 users choosing to use the prior-knowledge implementation instead.</li><li>Validation for field names and values has been narrowed. The validation that is mandatory for intermediaries is precisely defined, and error reporting for requests has been amended to encourage sending 400-series status codes.</li><li>The ranges of codepoints for settings and frame types that were reserved for Experimental Use are now available for general use.</li><li>Connection-specific header fields -- which are prohibited -- are more precisely and comprehensively identified.</li><li><span class="tt">Host</span> and "<span class="tt">:authority</span>" are no longer permitted to disagree.</li><li>Rules for sending Dynamic Table Size Update instructions after changes in settings have been clarified in <a href="#dynamic-table" title="Compression State">Section 4.3.1</a>.</li></ul></div><div id="rfc.section.B.p.3"><p>Editorial changes are also included. In particular, changes to terminology and document structure are in response to updates to <a href="#RFC9110"><cite title="HTTP Semantics">core HTTP semantics</cite></a> <cite title="HTTP Semantics">[HTTP]</cite>. Those documents now include some concepts that were first defined in RFC 7540, such as the 421 status code or connection coalescing.</p></div></section><hr class="hidden-print"><section id="n-acknowledgments"><h2 id="rfc.section.unnumbered-4" class="np"><a href="#n-acknowledgments">Acknowledgments</a></h2><div id="rfc.section.unnumbered-4.p.1"><p>Credit for non-trivial input to this document is owed to a large number of people who have contributed to the HTTP Working Group over the years. <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> contains a more extensive list of people that deserve acknowledgment for their contributions.</p></div></section><hr class="hidden-print"><section id="n-contributors"><h2 id="rfc.section.unnumbered-5" class="np"><a href="#n-contributors">Contributors</a></h2><div id="rfc.section.unnumbered-5.p.1"><p>Mike Belshe and Roberto Peon authored the text that this document is based on.</p></div></section><hr class="hidden-print"><section id="rfc.authors" class="np"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Martin Thomson</b> (editor)<br>Mozilla<br>Australia<br>EMail: <a href="mailto:mt@lowentropy.net">mt@lowentropy.net</a></address><address><b>Cory Benfield</b> (editor)<br>Apple Inc.<br>EMail: <a href="mailto:cbenfield@apple.com">cbenfield@apple.com</a></address></section></div></div></div><script src="/assets/node_modules/jquery/dist/jquery.min.js"></script><script src="/assets/node_modules/bootstrap/dist/js/bootstrap.min.js"></script></body></html>