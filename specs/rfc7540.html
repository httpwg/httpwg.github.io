<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "about:legacy-compat">
<html lang="en"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title><script type="application/javascript">
function getMeta(rfcno, container) {

  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://tools.ietf.org/draft/rfc" + rfcno + "/state.xml", true);
  xhr.onload = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var doc = xhr.responseXML;
        var info = getChildByName(doc.documentElement, "info");
  
        var cont = document.getElementById(container);
        // empty the container
        while (cont.firstChild) {
          cont.removeChild(myNode.firstChild);
        }      
  
        var c = getChildByName(info, "stdstatus");
        if (c !== null) {
          var bld = newElementWithText("b", c.textContent);
          cont.appendChild(bld);
        }
  
        c = getChildByName(info, "updatedby");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          cont.appendChild(newText("Updated by: "));
          appendRfcLinks(cont, c.textContent);
        }
  
        c = getChildByName(info, "obsoletedby");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          cont.appendChild(newText("Obsoleted by: "));
          appendRfcLinks(cont, c.textContent);
        }
        
        c = getChildByName(info, "errata");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          var link = newElementWithText("a", "errata");
          link.setAttribute("href", "http://www.rfc-editor.org/errata_search.php?rfc=" + rfcno);
          var errata = newElementWithText("i", "This document has ");
          errata.appendChild(link);
          errata.appendChild(newText("."));
          cont.appendChild(errata);
        }

        cont.style.display = "block";
      } else {
        console.error(xhr.statusText);
      }
    }
  };
  xhr.onerror = function (e) {
    console.error(xhr.status + " " + xhr.statusText);
  };
  xhr.send(null);
}

// DOM helpers
function newElement(name) {
  return document.createElement(name);
}
function newElementWithText(name, txt) {
  var e = document.createElement(name);
  e.appendChild(newText(txt));
  return e;
}
function newText(text) {
  return document.createTextNode(text);
}

function getChildByName(parent, name) {
  if (parent === null) {
    return null;
  }
  else {
    for (var c = parent.firstChild; c !== null; c = c.nextSibling) {
      if (name == c.nodeName) {
        return c;
      }
    }
    return null;
  }
}

function appendRfcLinks(parent, text) {
  var updates = text.split(",");
  for (var i = 0; i < updates.length; i++) {
    var rfc = updates[i].trim();
    if (rfc.substring(0, 3) == "rfc") {
      var link = newElement("a");
      link.setAttribute("href", "http://tools.ietf.org/html/" + rfc);
      link.appendChild(newText(rfc.substring(3)));
      parent.appendChild(link);
    } else {
      parent.appendChild(newText(rfc));
    }
    if (i != updates.length - 1) {
      parent.appendChild(newText(", "));
    }
  }
}
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="/bower_components/bootstrap/dist/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul li {
        list-style: none;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
    </style><link rel="stylesheet" type="text/css" href="/asset/site.css"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 HTTP/2 Protocol Overview" href="#rfc.section.2"><link rel="Chapter" title="3 Starting HTTP/2" href="#rfc.section.3"><link rel="Chapter" title="4 HTTP Frames" href="#rfc.section.4"><link rel="Chapter" title="5 Streams and Multiplexing" href="#rfc.section.5"><link rel="Chapter" title="6 Frame Definitions" href="#rfc.section.6"><link rel="Chapter" title="7 Error Codes" href="#rfc.section.7"><link rel="Chapter" title="8 HTTP Message Exchanges" href="#rfc.section.8"><link rel="Chapter" title="9 Additional HTTP Requirements/Considerations" href="#rfc.section.9"><link rel="Chapter" title="10 Security Considerations" href="#rfc.section.10"><link rel="Chapter" title="11 IANA Considerations" href="#rfc.section.11"><link rel="Chapter" href="#rfc.section.12" title="12 References"><link rel="Appendix" title="A TLS 1.2 Cipher Suite Black List" href="#rfc.section.A"><link rel="Appendix" title="Acknowledgements" href="#rfc.section.unnumbered-1"><link rel="Alternate" title="Authoritative ASCII Version" href="http://www.ietf.org/rfc/rfc7540.txt"><link rel="Help" title="RFC-Editor's Status Page" href="http://www.rfc-editor.org/info/rfc7540"><link rel="Help" title="Additional Information on tools.ietf.org" href="http://tools.ietf.org/html/rfc7540"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="HTTP, SPDY, Web"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Belshe, M."><meta name="dct.creator" content="Peon, R."><meta name="dct.creator" content="Thomson, M."><meta name="dct.identifier" content="urn:ietf:rfc:7540"><meta name="dct.issued" scheme="ISO8601" content="2015-05"><meta name="dct.abstract" content="This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection. It also introduces unsolicited push of representations from servers to clients. This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged."><meta name="dct.isPartOf" content="urn:issn:2070-1721"><meta name="description" content="This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection. It also introduces unsolicited push of representations from servers to clients. This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged."></head><body onload="getMeta(7540,&#34;rfc.meta&#34;);"><nav class="navbar navbar-default navbar-inverse navbar-fixed-top" role="navigation">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/"><img src="/asset/http.svg" height="23"></a>
  </div>
  
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">
      
      
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a href="/specs/">HTTP Documentation Home</a></li>
            <li class="divider"></li>
            <li class="dropdown-header">HTTP Specs</li>
            <li><a href="/specs/rfc7230.html">HTTP/1.1: Message Syntax and Routing</a></li>
            <li><a href="/specs/rfc7231.html">HTTP/1.1: Semantics and Content</a></li>
            <li><a href="/specs/rfc7232.html">HTTP/1.1: Conditional Requests </a></li>
            <li><a href="/specs/rfc7233.html">HTTP/1.1: Range Requests</a></li>
            <li><a href="/specs/rfc7234.html">HTTP/1.1: Caching</a></li>
            <li><a href="/specs/rfc7235.html">HTTP/1.1: Authentication</a></li>
            <li><a href="/specs/rfc7540.html">HTTP/2</a></li>
            <li><a href="/specs/rfc7541.html">HPACK</a></li>
            <li><a href="/specs/rfc6265.html">HTTP Cookies</a></li>
            <li class="divider"></li>
            <li class="dropdown-header">Extension Registries</li>
            <li><a href="http://www.iana.org/assignments/http-methods/">HTTP Method Registry</a></li>
            <li><a href="http://www.iana.org/assignments/http-status-codes/">HTTP Status Code Registry</a></li>
            <li><a href="http://www.iana.org/assignments/message-headers/">Message Header Registry</a></li>
            <li><a href="http://www.iana.org/assignments/http-authschemes/">HTTP Authentication Scheme Registry</a></li>
            <li><a href="http://www.iana.org/assignments/http-cache-directives/">HTTP Cache Directive Registry</a></li>
            <li><a href="http://www.iana.org/assignments/http-parameters/">HTTP Parameters Registry</a></li>
          </ul>
      </li>

      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">FAQs<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a href="/faq/spec/">FAQs for Spec Writers</a></li>
            <li><a href="https://http2.github.io/faq/">HTTP/2 FAQ</a></li>
          </ul>
      </li>

      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Work in Progress<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li class="dropdown-header">HTTP Extensions</li>
            <li><a href="https://github.com/httpwg/http-extensions#draft-http-extension-specifications">HTTP Extensions Repository</a></li>
            <li><a href="https://github.com/httpwg/http-extensions/issues">HTTP Extensions Issues</a></li>
            <li><a href="https://github.com/httpwg/wiki/wiki/WatchList">Future Work</a></li>          
          </ul>
      </li>

      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Participate<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a href="/about/">About the HTTP Working Group</a></li>
            <li class="divider"></li>
            <li><a href="https://github.com/httpwg/http-extensions/blob/master/CONTRIBUTING.md">Contribution Policy</a></li>
            <li><a href="http://datatracker.ietf.org/wg/httpbis/charter/">WG Charter</a></li>
            <li><a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">Group Mailing List <span class="glyphicon glyphicon-envelope"></span></a></li>
            <li><a href="https://github.com/httpwg/wg-materials">Meeting Materials Repository</a></li>
          </ul>
      </li>
            
    </ul>
    <ul class="nav navbar-nav navbar-right">
      <li><a href="https://twitter.com/http_wg"><img src="https://g.twimg.com/Twitter_logo_blue.png" width="22" height="16"></a></li>
    </ul>
  </div>
</nav><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top"><strong>RFC </strong>7540</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#Overview">HTTP/2 Protocol Overview</a><ul><li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.1">Document Organization</a></li><li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.2">Conventions and Terminology</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#starting">Starting HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#versioning">HTTP/2 Version Identification</a></li><li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#discover-http">Starting HTTP/2 for "http" URIs</a><ul><li><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#Http2SettingsHeader">HTTP2-Settings Header Field</a></li></ul></li><li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#discover-https">Starting HTTP/2 for "https" URIs</a></li><li><a href="#rfc.section.3.4">3.4</a>&nbsp;&nbsp;&nbsp;<a href="#known-http">Starting HTTP/2 with Prior Knowledge</a></li><li><a href="#rfc.section.3.5">3.5</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionHeader">HTTP/2 Connection Preface</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#FramingLayer">HTTP Frames</a><ul><li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#FrameHeader">Frame Format</a></li><li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#FrameSize">Frame Size</a></li><li><a href="#rfc.section.4.3">4.3</a>&nbsp;&nbsp;&nbsp;<a href="#HeaderBlock">Header Compression and Decompression</a></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamsLayer">Streams and Multiplexing</a><ul><li><a href="#rfc.section.5.1">5.1</a>&nbsp;&nbsp;&nbsp;<a href="#StreamStates">Stream States</a><ul><li><a href="#rfc.section.5.1.1">5.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#StreamIdentifiers">Stream Identifiers</a></li><li><a href="#rfc.section.5.1.2">5.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.1.2">Stream Concurrency</a></li></ul></li><li><a href="#rfc.section.5.2">5.2</a>&nbsp;&nbsp;&nbsp;<a href="#FlowControl">Flow Control</a><ul><li><a href="#rfc.section.5.2.1">5.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#fc-principles">Flow-Control Principles</a></li><li><a href="#rfc.section.5.2.2">5.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#DisableFlowControl">Appropriate Use of Flow Control</a></li></ul></li><li><a href="#rfc.section.5.3">5.3</a>&nbsp;&nbsp;&nbsp;<a href="#StreamPriority">Stream Priority</a><ul><li><a href="#rfc.section.5.3.1">5.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#pri-depend">Stream Dependencies</a></li><li><a href="#rfc.section.5.3.2">5.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.3.2">Dependency Weighting</a></li><li><a href="#rfc.section.5.3.3">5.3.3</a>&nbsp;&nbsp;&nbsp;<a href="#reprioritize">Reprioritization</a></li><li><a href="#rfc.section.5.3.4">5.3.4</a>&nbsp;&nbsp;&nbsp;<a href="#priority-gc">Prioritization State Management</a></li><li><a href="#rfc.section.5.3.5">5.3.5</a>&nbsp;&nbsp;&nbsp;<a href="#pri-default">Default Priorities</a></li></ul></li><li><a href="#rfc.section.5.4">5.4</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorHandler">Error Handling</a><ul><li><a href="#rfc.section.5.4.1">5.4.1</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionErrorHandler">Connection Error Handling</a></li><li><a href="#rfc.section.5.4.2">5.4.2</a>&nbsp;&nbsp;&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></li><li><a href="#rfc.section.5.4.3">5.4.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4.3">Connection Termination</a></li></ul></li><li><a href="#rfc.section.5.5">5.5</a>&nbsp;&nbsp;&nbsp;<a href="#extensibility">Extending HTTP/2</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameTypes">Frame Definitions</a><ul><li><a href="#rfc.section.6.1">6.1</a>&nbsp;&nbsp;&nbsp;<a href="#DATA">DATA</a></li><li><a href="#rfc.section.6.2">6.2</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS">HEADERS</a></li><li><a href="#rfc.section.6.3">6.3</a>&nbsp;&nbsp;&nbsp;<a href="#PRIORITY">PRIORITY</a></li><li><a href="#rfc.section.6.4">6.4</a>&nbsp;&nbsp;&nbsp;<a href="#RST_STREAM">RST_STREAM</a></li><li><a href="#rfc.section.6.5">6.5</a>&nbsp;&nbsp;&nbsp;<a href="#SETTINGS">SETTINGS</a><ul><li><a href="#rfc.section.6.5.1">6.5.1</a>&nbsp;&nbsp;&nbsp;<a href="#SettingFormat">SETTINGS Format</a></li><li><a href="#rfc.section.6.5.2">6.5.2</a>&nbsp;&nbsp;&nbsp;<a href="#SettingValues">Defined SETTINGS Parameters</a></li><li><a href="#rfc.section.6.5.3">6.5.3</a>&nbsp;&nbsp;&nbsp;<a href="#SettingsSync">Settings Synchronization</a></li></ul></li><li><a href="#rfc.section.6.6">6.6</a>&nbsp;&nbsp;&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></li><li><a href="#rfc.section.6.7">6.7</a>&nbsp;&nbsp;&nbsp;<a href="#PING">PING</a></li><li><a href="#rfc.section.6.8">6.8</a>&nbsp;&nbsp;&nbsp;<a href="#GOAWAY">GOAWAY</a></li><li><a href="#rfc.section.6.9">6.9</a>&nbsp;&nbsp;&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a><ul><li><a href="#rfc.section.6.9.1">6.9.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.9.1">The Flow-Control Window</a></li><li><a href="#rfc.section.6.9.2">6.9.2</a>&nbsp;&nbsp;&nbsp;<a href="#InitialWindowSize">Initial Flow-Control Window Size</a></li><li><a href="#rfc.section.6.9.3">6.9.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.9.3">Reducing the Stream Window Size</a></li></ul></li><li><a href="#rfc.section.6.10">6.10</a>&nbsp;&nbsp;&nbsp;<a href="#CONTINUATION">CONTINUATION</a></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorCodes">Error Codes</a></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#HTTPLayer">HTTP Message Exchanges</a><ul><li><a href="#rfc.section.8.1">8.1</a>&nbsp;&nbsp;&nbsp;<a href="#HttpSequence">HTTP Request/Response Exchange</a><ul><li><a href="#rfc.section.8.1.1">8.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#informational-responses">Upgrading from HTTP/2</a></li><li><a href="#rfc.section.8.1.2">8.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#HttpHeaders">HTTP Header Fields</a></li><li><a href="#rfc.section.8.1.3">8.1.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.1.3">Examples</a></li><li><a href="#rfc.section.8.1.4">8.1.4</a>&nbsp;&nbsp;&nbsp;<a href="#Reliability">Request Reliability Mechanisms in HTTP/2</a></li></ul></li><li><a href="#rfc.section.8.2">8.2</a>&nbsp;&nbsp;&nbsp;<a href="#PushResources">Server Push</a><ul><li><a href="#rfc.section.8.2.1">8.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#PushRequests">Push Requests</a></li><li><a href="#rfc.section.8.2.2">8.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#PushResponses">Push Responses</a></li></ul></li><li><a href="#rfc.section.8.3">8.3</a>&nbsp;&nbsp;&nbsp;<a href="#CONNECT">The CONNECT Method</a></li></ul></li><li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExtra">Additional HTTP Requirements/Considerations</a><ul><li><a href="#rfc.section.9.1">9.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.1">Connection Management</a><ul><li><a href="#rfc.section.9.1.1">9.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#reuse">Connection Reuse</a></li><li><a href="#rfc.section.9.1.2">9.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#MisdirectedRequest">The 421 (Misdirected Request) Status Code</a></li></ul></li><li><a href="#rfc.section.9.2">9.2</a>&nbsp;&nbsp;&nbsp;<a href="#TLSUsage">Use of TLS Features</a><ul><li><a href="#rfc.section.9.2.1">9.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.2.1">TLS 1.2 Features</a></li><li><a href="#rfc.section.9.2.2">9.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.2.2">TLS 1.2 Cipher Suites</a></li></ul></li></ul></li><li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#security">Security Considerations</a><ul><li><a href="#rfc.section.10.1">10.1</a>&nbsp;&nbsp;&nbsp;<a href="#authority">Server Authority</a></li><li><a href="#rfc.section.10.2">10.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.2">Cross-Protocol Attacks</a></li><li><a href="#rfc.section.10.3">10.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.3">Intermediary Encapsulation Attacks</a></li><li><a href="#rfc.section.10.4">10.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.4">Cacheability of Pushed Responses</a></li><li><a href="#rfc.section.10.5">10.5</a>&nbsp;&nbsp;&nbsp;<a href="#dos">Denial-of-Service Considerations</a><ul><li><a href="#rfc.section.10.5.1">10.5.1</a>&nbsp;&nbsp;&nbsp;<a href="#MaxHeaderBlock">Limits on Header Block Size</a></li><li><a href="#rfc.section.10.5.2">10.5.2</a>&nbsp;&nbsp;&nbsp;<a href="#connectDos">CONNECT Issues</a></li></ul></li><li><a href="#rfc.section.10.6">10.6</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.6">Use of Compression</a></li><li><a href="#rfc.section.10.7">10.7</a>&nbsp;&nbsp;&nbsp;<a href="#padding">Use of Padding</a></li><li><a href="#rfc.section.10.8">10.8</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.10.8">Privacy Considerations</a></li></ul></li><li><a href="#rfc.section.11">11.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a><ul><li><a href="#rfc.section.11.1">11.1</a>&nbsp;&nbsp;&nbsp;<a href="#iana-alpn">Registration of HTTP/2 Identification Strings</a></li><li><a href="#rfc.section.11.2">11.2</a>&nbsp;&nbsp;&nbsp;<a href="#iana-frames">Frame Type Registry</a></li><li><a href="#rfc.section.11.3">11.3</a>&nbsp;&nbsp;&nbsp;<a href="#iana-settings">Settings Registry</a></li><li><a href="#rfc.section.11.4">11.4</a>&nbsp;&nbsp;&nbsp;<a href="#iana-errors">Error Code Registry</a></li><li><a href="#rfc.section.11.5">11.5</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.11.5">HTTP2-Settings Header Field Registration</a></li><li><a href="#rfc.section.11.6">11.6</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.11.6">PRI Method Registration</a></li><li><a href="#rfc.section.11.7">11.7</a>&nbsp;&nbsp;&nbsp;<a href="#iana-MisdirectedRequest">The 421 (Misdirected Request) HTTP Status Code</a></li><li><a href="#rfc.section.11.8">11.8</a>&nbsp;&nbsp;&nbsp;<a href="#iana-h2c">The h2c Upgrade Token</a></li></ul></li><li><a href="#rfc.section.12">12.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.12.1">12.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.12.2">12.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#BadCipherSuites">TLS 1.2 Cipher Suite Black List</a></li><li><a href="#rfc.section.unnumbered-1">Acknowledgements</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-md-8 col-md-pull-4 main" role="main"><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Internet Engineering Task Force (IETF)</td><td class="text-right">M. Belshe</td></tr><tr><td class="text-left">Request for Comments: 7540</td><td class="text-right">BitGo</td></tr><tr><td class="text-left">Category: Standards Track</td><td class="text-right">R. Peon</td></tr><tr><td class="text-left">ISSN: 2070-1721</td><td class="text-right">Google, Inc</td></tr><tr><td class="text-left"></td><td class="text-right">M. Thomson, Editor</td></tr><tr><td class="text-left"></td><td class="text-right">Mozilla</td></tr><tr><td class="text-left"></td><td class="text-right">May 2015</td></tr></tbody></table><div id="rfc.title"><h1>Hypertext Transfer Protocol Version 2 (HTTP/2)</h1></div><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><p>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection. It also introduces unsolicited push of representations from servers to clients.</p><p>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged.</p></div><div id="rfc.meta" class="alert alert-info"></div><div id="rfc.status"><h2><a href="#rfc.status">Status of This Memo</a></h2><p>This is an Internet Standards Track document.</p><p>This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.</p><p>Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at <a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>.</p></div><div id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2015 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div><div id="intro"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#intro">Introduction</a></h2><div id="rfc.section.1.p.1"><p>The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol. However, the way HTTP/1.1 uses the underlying transport (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#connection.management" title="Connection Management">Section 6</a>) has several characteristics that have a negative overall effect on application performance today.</p></div><div id="rfc.section.1.p.2"><p>In particular, HTTP/1.0 allowed only one request to be outstanding at a time on a given TCP connection. HTTP/1.1 added request pipelining, but this only partially addressed request concurrency and still suffers from head-of-line blocking. Therefore, HTTP/1.0 and HTTP/1.1 clients that need to make many requests use multiple connections to a server in order to achieve concurrency and thereby reduce latency.</p></div><div id="rfc.section.1.p.3"><p>Furthermore, HTTP header fields are often repetitive and verbose, causing unnecessary network traffic as well as causing the initial <a href="#TCP">TCP</a> <cite title="Transmission Control Protocol">[TCP]</cite> congestion window to quickly fill. This can result in excessive latency when multiple requests are made on a new TCP connection.</p></div><div id="rfc.section.1.p.4"><p>HTTP/2 addresses these issues by defining an optimized mapping of HTTP's semantics to an underlying connection. Specifically, it allows interleaving of request and response messages on the same connection and uses an efficient coding for HTTP header fields. It also allows prioritization of requests, letting more important requests complete more quickly, further improving performance.</p></div><div id="rfc.section.1.p.5"><p>The resulting protocol is more friendly to the network because fewer TCP connections can be used in comparison to HTTP/1.x. This means less competition with other flows and longer-lived connections, which in turn lead to better utilization of available network capacity.</p></div><div id="rfc.section.1.p.6"><p>Finally, HTTP/2 also enables more efficient processing of messages through use of binary message framing.</p></div></div><div id="Overview"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#Overview">HTTP/2 Protocol Overview</a></h2><div id="rfc.section.2.p.1"><p>HTTP/2 provides an optimized transport for HTTP semantics. HTTP/2 supports all of the core features of HTTP/1.1 but aims to be more efficient in several ways.</p></div><div id="rfc.section.2.p.2"><p>The basic protocol unit in HTTP/2 is a frame (<a href="#FrameHeader" title="Frame Format">Section&nbsp;4.1</a>). Each frame type serves a different purpose. For example, <a href="#HEADERS" class="smpl">HEADERS</a> and <a href="#DATA" class="smpl">DATA</a> frames form the basis of HTTP requests and responses (<a href="#HttpSequence" title="HTTP Request/Response Exchange">Section&nbsp;8.1</a>); other frame types like <a href="#SETTINGS" class="smpl">SETTINGS</a>, <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, and <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> are used in support of other HTTP/2 features.</p></div><div id="rfc.section.2.p.3"><p>Multiplexing of requests is achieved by having each HTTP request/response exchange associated with its own stream (<a href="#StreamsLayer" title="Streams and Multiplexing">Section&nbsp;5</a>). Streams are largely independent of each other, so a blocked or stalled request or response does not prevent progress on other streams.</p></div><div id="rfc.section.2.p.4"><p>Flow control and prioritization ensure that it is possible to efficiently use multiplexed streams. Flow control (<a href="#FlowControl" title="Flow Control">Section&nbsp;5.2</a>) helps to ensure that only data that can be used by a receiver is transmitted. Prioritization (<a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>) ensures that limited resources can be directed to the most important streams first.</p></div><div id="rfc.section.2.p.5"><p>HTTP/2 adds a new interaction mode whereby a server can push responses to a client (<a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>). Server push allows a server to speculatively send data to a client that the server anticipates the client will need, trading off some network usage against a potential latency gain. The server does this by synthesizing a request, which it sends as a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame. The server is then able to send a response to the synthetic request on a separate stream.</p></div><div id="rfc.section.2.p.6"><p>Because HTTP header fields used in a connection can contain large amounts of redundant data, frames that contain them are compressed (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>). This has especially advantageous impact upon request sizes in the common case, allowing many requests to be compressed into one packet.</p></div><div><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;Document Organization</h3><div id="rfc.section.2.1.p.1"><p>The HTTP/2 specification is split into four parts: </p><ul><li>Starting HTTP/2 (<a href="#starting" title="Starting HTTP/2">Section&nbsp;3</a>) covers how an HTTP/2 connection is initiated.</li><li>The frame (<a href="#FramingLayer" title="HTTP Frames">Section&nbsp;4</a>) and stream (<a href="#StreamsLayer" title="Streams and Multiplexing">Section&nbsp;5</a>) layers describe the way HTTP/2 frames are structured and formed into multiplexed streams.</li><li>Frame (<a href="#FrameTypes" title="Frame Definitions">Section&nbsp;6</a>) and error (<a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>) definitions include details of the frame and error types used in HTTP/2.</li><li>HTTP mappings (<a href="#HTTPLayer" title="HTTP Message Exchanges">Section&nbsp;8</a>) and additional requirements (<a href="#HttpExtra" title="Additional HTTP Requirements/Considerations">Section&nbsp;9</a>) describe how HTTP semantics are expressed using frames and streams.</li></ul></div><div id="rfc.section.2.1.p.2"><p>While some of the frame and stream layer concepts are isolated from HTTP, this specification does not define a completely generic frame layer. The frame and stream layers are tailored to the needs of the HTTP protocol and server push.</p></div></div><div><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;Conventions and Terminology</h3><div id="rfc.section.2.2.p.1"><p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite>.</p></div><div id="rfc.section.2.2.p.2"><p>All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided in decimal or hexadecimal as appropriate. Hexadecimal literals are prefixed with <tt>0x</tt> to distinguish them from decimal literals.</p></div><div id="rfc.section.2.2.p.3"><p>The following terms are used: </p><dl><dt>client:</dt><dd>The endpoint that initiates an HTTP/2 connection. Clients send HTTP requests and receive HTTP responses.</dd><dt>connection:</dt><dd>A transport-layer connection between two endpoints.</dd><dt>connection error:</dt><dd>An error that affects the entire HTTP/2 connection.</dd><dt>endpoint:</dt><dd>Either the client or server of the connection.</dd><dt>frame:</dt><dd>The smallest unit of communication within an HTTP/2 connection, consisting of a header and a variable-length sequence of octets structured according to the frame type.</dd><dt>peer:</dt><dd>An endpoint. When discussing a particular endpoint, "peer" refers to the endpoint that is remote to the primary subject of discussion.</dd><dt>receiver:</dt><dd>An endpoint that is receiving frames.</dd><dt>sender:</dt><dd>An endpoint that is transmitting frames.</dd><dt>server:</dt><dd>The endpoint that accepts an HTTP/2 connection. Servers receive HTTP requests and send HTTP responses.</dd><dt>stream:</dt><dd>A bidirectional flow of frames within the HTTP/2 connection.</dd><dt>stream error:</dt><dd>An error on the individual HTTP/2 stream.</dd></dl></div><div id="rfc.section.2.2.p.4"><p>Finally, the terms "gateway", "intermediary", "proxy", and "tunnel" are defined in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#intermediaries" title="Intermediaries">Section 2.3</a> of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>. Intermediaries act as both client and server at different times.</p></div><div id="rfc.section.2.2.p.5"><p>The term "payload body" is defined in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#message.body" title="Message Body">Section 3.3</a> of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div></div></div><div id="starting"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#starting">Starting HTTP/2</a></h2><div id="rfc.section.3.p.1"><p>An HTTP/2 connection is an application-layer protocol running on top of a TCP connection (<a href="#TCP"><cite title="Transmission Control Protocol">[TCP]</cite></a>). The client is the TCP connection initiator.</p></div><div id="rfc.section.3.p.2"><p>HTTP/2 uses the same "http" and "https" URI schemes used by HTTP/1.1. HTTP/2 shares the same default port numbers: 80 for "http" URIs and 443 for "https" URIs. As a result, implementations processing requests for target resource URIs like <tt>http://example.org/foo</tt> or <tt>https://example.com/bar</tt> are required to first discover whether the upstream server (the immediate peer to which the client wishes to establish a connection) supports HTTP/2.</p></div><div id="rfc.section.3.p.3"><p>The means by which support for HTTP/2 is determined is different for "http" and "https" URIs. Discovery for "http" URIs is described in <a href="#discover-http" title="Starting HTTP/2 for &#34;http&#34; URIs">Section&nbsp;3.2</a>. Discovery for "https" URIs is described in <a href="#discover-https" title="Starting HTTP/2 for &#34;https&#34; URIs">Section&nbsp;3.3</a>.</p></div><div id="versioning"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a href="#versioning">HTTP/2 Version Identification</a></h3><div id="rfc.section.3.1.p.1"><p>The protocol defined in this document has two identifiers. </p><ul><li><p>The string "h2" identifies the protocol where HTTP/2 uses <a href="#TLS12">Transport Layer Security (TLS)</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite>. This identifier is used in the <a href="#TLS-ALPN">TLS application-layer protocol negotiation (ALPN) extension</a> <cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite> field and in any place where HTTP/2 over TLS is identified.</p><p>The "h2" string is serialized into an ALPN protocol identifier as the two-octet sequence: 0x68, 0x32.</p></li><li><p>The string "h2c" identifies the protocol where HTTP/2 is run over cleartext TCP. This identifier is used in the HTTP/1.1 Upgrade header field and in any place where HTTP/2 over TCP is identified.</p><p>The "h2c" string is reserved from the ALPN identifier space but describes a protocol that does not use TLS.</p></li></ul></div><div id="rfc.section.3.1.p.2"><p>Negotiating "h2" or "h2c" implies the use of the transport, security, framing, and message semantics described in this document.</p></div></div><div id="discover-http"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a href="#discover-http">Starting HTTP/2 for "http" URIs</a></h3><div id="rfc.section.3.2.p.1"><p>A client that makes a request for an "http" URI without prior knowledge about support for HTTP/2 on the next hop uses the HTTP Upgrade mechanism (<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.upgrade" title="Upgrade">Section 6.7</a> of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>). The client does so by making an HTTP/1.1 request that includes an Upgrade header field with the "h2c" token. Such an HTTP/1.1 request MUST include exactly one HTTP2-Settings (<a href="#Http2SettingsHeader" title="HTTP2-Settings Header Field">Section&nbsp;3.2.1</a>) header field.</p></div><div id="rfc.figure.u.1"><p>For example:</p><pre class="text2">GET / HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: h2c
HTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload&gt;

</pre></div><div id="rfc.section.3.2.p.2"><p>Requests that contain a payload body MUST be sent in their entirety before the client can send HTTP/2 frames. This means that a large request can block the use of the connection until it is completely sent.</p></div><div id="rfc.section.3.2.p.3"><p>If concurrency of an initial request with subsequent requests is important, an OPTIONS request can be used to perform the upgrade to HTTP/2, at the cost of an additional round trip.</p></div><div id="rfc.section.3.2.p.4" class="avoidbreakafter"><p>A server that does not support HTTP/2 can respond to the request as though the Upgrade header field were absent:</p></div><div id="rfc.figure.u.2"><pre class="text">HTTP/1.1 200 OK
Content-Length: 243
Content-Type: text/html

...
</pre></div><div id="rfc.section.3.2.p.5"><p>A server MUST ignore an "h2" token in an Upgrade header field. Presence of a token with "h2" implies HTTP/2 over TLS, which is instead negotiated as described in <a href="#discover-https" title="Starting HTTP/2 for &#34;https&#34; URIs">Section&nbsp;3.3</a>.</p></div><div id="rfc.section.3.2.p.6"><p>A server that supports HTTP/2 accepts the upgrade with a 101 (Switching Protocols) response. After the empty line that terminates the 101 response, the server can begin sending HTTP/2 frames. These frames MUST include a response to the request that initiated the upgrade.</p></div><div id="rfc.figure.u.3"><p>For example:</p><pre class="text">HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: h2c

[ HTTP/2 connection ...
</pre></div><div id="rfc.section.3.2.p.7"><p>The first HTTP/2 frame sent by the server MUST be a server connection preface (<a href="#ConnectionHeader" title="HTTP/2 Connection Preface">Section&nbsp;3.5</a>) consisting of a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a>). Upon receiving the 101 response, the client MUST send a connection preface (<a href="#ConnectionHeader" title="HTTP/2 Connection Preface">Section&nbsp;3.5</a>), which includes a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame.</p></div><div id="rfc.section.3.2.p.8"><p>The HTTP/1.1 request that is sent prior to upgrade is assigned a stream identifier of 1 (see <a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>) with default priority values (<a href="#pri-default" title="Default Priorities">Section&nbsp;5.3.5</a>). Stream 1 is implicitly "half-closed" from the client toward the server (see <a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>), since the request is completed as an HTTP/1.1 request. After commencing the HTTP/2 connection, stream 1 is used for the response.</p></div><div id="Http2SettingsHeader"><h4 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;<a href="#Http2SettingsHeader">HTTP2-Settings Header Field</a></h4><div id="rfc.section.3.2.1.p.1"><p>A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly one <tt>HTTP2-Settings</tt> header field. The <tt>HTTP2-Settings</tt> header field is a connection-specific header field that includes parameters that govern the HTTP/2 connection, provided in anticipation of the server accepting the request to upgrade.</p></div><div id="rfc.figure.u.4"><pre class="inline">HTTP2-Settings    = token68
</pre></div><div id="rfc.section.3.2.1.p.2"><p>A server MUST NOT upgrade the connection to HTTP/2 if this header field is not present or if more than one is present. A server MUST NOT send this header field.</p></div><div id="rfc.section.3.2.1.p.3"><p>The content of the <tt>HTTP2-Settings</tt> header field is the payload of a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a>), encoded as a base64url string (that is, the URL- and filename-safe Base64 encoding described in <a href="https://tools.ietf.org/html/rfc4648#section-5">Section 5</a> of <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, with any trailing '=' characters omitted). The <a href="#RFC5234">ABNF</a> <cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite> production for <tt>token68</tt> is defined in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7235.html#challenge.and.response" title="Challenge and Response">Section 2.1</a> of <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a>.</p></div><div id="rfc.section.3.2.1.p.4"><p>Since the upgrade is only intended to apply to the immediate connection, a client sending the <tt>HTTP2-Settings</tt> header field MUST also send <tt>HTTP2-Settings</tt> as a connection option in the <tt>Connection</tt> header field to prevent it from being forwarded (see <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.connection" title="Connection">Section 6.1</a> of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>).</p></div><div id="rfc.section.3.2.1.p.5"><p>A server decodes and interprets these values as it would any other <a href="#SETTINGS" class="smpl">SETTINGS</a> frame. Explicit acknowledgement of these settings (<a href="#SettingsSync" title="Settings Synchronization">Section&nbsp;6.5.3</a>) is not necessary, since a 101 response serves as implicit acknowledgement. Providing these values in the upgrade request gives a client an opportunity to provide parameters prior to receiving any frames from the server.</p></div></div></div><div id="discover-https"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a href="#discover-https">Starting HTTP/2 for "https" URIs</a></h3><div id="rfc.section.3.3.p.1"><p>A client that makes a request to an "https" URI uses <a href="#TLS12">TLS</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite> with the <a href="#TLS-ALPN">application-layer protocol negotiation (ALPN) extension</a> <cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite>.</p></div><div id="rfc.section.3.3.p.2"><p>HTTP/2 over TLS uses the "h2" protocol identifier. The "h2c" protocol identifier MUST NOT be sent by a client or selected by a server; the "h2c" protocol identifier describes a protocol that does not use TLS.</p></div><div id="rfc.section.3.3.p.3"><p>Once TLS negotiation is complete, both the client and the server MUST send a connection preface (<a href="#ConnectionHeader" title="HTTP/2 Connection Preface">Section&nbsp;3.5</a>).</p></div></div><div id="known-http"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;<a href="#known-http">Starting HTTP/2 with Prior Knowledge</a></h3><div id="rfc.section.3.4.p.1"><p>A client can learn that a particular server supports HTTP/2 by other means. For example, <a href="#ALT-SVC"><cite title="HTTP Alternative Services">[ALT-SVC]</cite></a> describes a mechanism for advertising this capability.</p></div><div id="rfc.section.3.4.p.2"><p>A client MUST send the connection preface (<a href="#ConnectionHeader" title="HTTP/2 Connection Preface">Section&nbsp;3.5</a>) and then MAY immediately send HTTP/2 frames to such a server; servers can identify these connections by the presence of the connection preface. This only affects the establishment of HTTP/2 connections over cleartext TCP; implementations that support HTTP/2 over TLS MUST use <a href="#TLS-ALPN">protocol negotiation in TLS</a> <cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite>.</p></div><div id="rfc.section.3.4.p.3"><p>Likewise, the server MUST send a connection preface (<a href="#ConnectionHeader" title="HTTP/2 Connection Preface">Section&nbsp;3.5</a>).</p></div><div id="rfc.section.3.4.p.4"><p>Without additional information, prior support for HTTP/2 is not a strong signal that a given server will support HTTP/2 for future connections. For example, it is possible for server configurations to change, for configurations to differ between instances in clustered servers, or for network conditions to change.</p></div></div><div id="ConnectionHeader"><h3 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a>&nbsp;<a href="#ConnectionHeader">HTTP/2 Connection Preface</a></h3><div id="rfc.section.3.5.p.1"><p>In HTTP/2, each endpoint is required to send a connection preface as a final confirmation of the protocol in use and to establish the initial settings for the HTTP/2 connection. The client and server each send a different connection preface.</p></div><div id="rfc.section.3.5.p.2" class="avoidbreakafter"><p>The client connection preface starts with a sequence of 24 octets, which in hex notation is:</p></div><div id="rfc.figure.u.5"><pre class="inline">0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
</pre></div><div id="rfc.section.3.5.p.3"><p>That is, the connection preface starts with the string <tt>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</tt>). This sequence MUST be followed by a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a>), which MAY be empty. The client sends the client connection preface immediately upon receipt of a 101 (Switching Protocols) response (indicating a successful upgrade) or as the first application data octets of a TLS connection. If starting an HTTP/2 connection with prior knowledge of server support for the protocol, the client connection preface is sent upon connection establishment.</p></div><div class="alert alert-warning"><div id="rfc.section.3.5.p.4"><p><b>Note:</b> The client connection preface is selected so that a large proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do not attempt to process further frames. Note that this does not address the concerns raised in <a href="#TALKING"><cite title="Talking to Yourself for Fun and Profit">[TALKING]</cite></a>.</p></div></div><div id="rfc.section.3.5.p.5"><p>The server connection preface consists of a potentially empty <a href="#SETTINGS" class="smpl">SETTINGS</a> frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a>) that MUST be the first frame the server sends in the HTTP/2 connection.</p></div><div id="rfc.section.3.5.p.6"><p>The <a href="#SETTINGS" class="smpl">SETTINGS</a> frames received from a peer as part of the connection preface MUST be acknowledged (see <a href="#SettingsSync" title="Settings Synchronization">Section&nbsp;6.5.3</a>) after sending the connection preface.</p></div><div id="rfc.section.3.5.p.7"><p>To avoid unnecessary latency, clients are permitted to send additional frames to the server immediately after sending the client connection preface, without waiting to receive the server connection preface. It is important to note, however, that the server connection preface <a href="#SETTINGS" class="smpl">SETTINGS</a> frame might include parameters that necessarily alter how a client is expected to communicate with the server. Upon receiving the <a href="#SETTINGS" class="smpl">SETTINGS</a> frame, the client is expected to honor any parameters established. In some configurations, it is possible for the server to transmit <a href="#SETTINGS" class="smpl">SETTINGS</a> before the client sends additional frames, providing an opportunity to avoid this issue.</p></div><div id="rfc.section.3.5.p.8"><p>Clients and servers MUST treat an invalid connection preface as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. A <a href="#GOAWAY" class="smpl">GOAWAY</a> frame (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;6.8</a>) MAY be omitted in this case, since an invalid preface indicates that the peer is not using HTTP/2.</p></div></div></div><div id="FramingLayer"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#FramingLayer">HTTP Frames</a></h2><div id="rfc.section.4.p.1"><p>Once the HTTP/2 connection is established, endpoints can begin exchanging frames.</p></div><div id="FrameHeader"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a href="#FrameHeader">Frame Format</a></h3><div id="rfc.section.4.1.p.1"><p>All frames begin with a fixed 9-octet header followed by a variable-length payload.</p></div><div id="FrameLayout"></div><div id="rfc.figure.1"><pre class="inline"> +-----------------------------------------------+
 |                 Length (24)                   |
 +---------------+---------------+---------------+
 |   Type (8)    |   Flags (8)   |
 +-+-------------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +=+=============================================================+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 1: Frame Layout</p><div id="rfc.section.4.1.p.2"><p>The fields of the frame header are defined as: </p><dl><dt>Length:</dt><dd><p>The length of the frame payload expressed as an unsigned 24-bit integer. Values greater than 2<sup>14</sup> (16,384) MUST NOT be sent unless the receiver has set a larger value for <a href="#SETTINGS_MAX_FRAME_SIZE" class="smpl">SETTINGS_MAX_FRAME_SIZE</a>.</p><p>The 9 octets of the frame header are not included in this value.</p></dd><dt>Type:</dt><dd><p>The 8-bit type of the frame. The frame type determines the format and semantics of the frame. Implementations MUST ignore and discard any frame that has a type that is unknown.</p></dd><dt>Flags:</dt><dd><p>An 8-bit field reserved for boolean flags specific to the frame type.</p><p>Flags are assigned semantics specific to the indicated frame type. Flags that have no defined semantics for a particular frame type MUST be ignored and MUST be left unset (0x0) when sending.</p></dd><dt>R:</dt><dd><p>A reserved 1-bit field. The semantics of this bit are undefined, and the bit MUST remain unset (0x0) when sending and MUST be ignored when receiving.</p></dd><dt>Stream Identifier:</dt><dd><p>A stream identifier (see <a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>) expressed as an unsigned 31-bit integer. The value 0x0 is reserved for frames that are associated with the connection as a whole as opposed to an individual stream.</p></dd></dl></div><div id="rfc.section.4.1.p.3"><p>The structure and content of the frame payload is dependent entirely on the frame type.</p></div></div><div id="FrameSize"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a href="#FrameSize">Frame Size</a></h3><div id="rfc.section.4.2.p.1"><p>The size of a frame payload is limited by the maximum size that a receiver advertises in the <a href="#SETTINGS_MAX_FRAME_SIZE" class="smpl">SETTINGS_MAX_FRAME_SIZE</a> setting. This setting can have any value between 2<sup>14</sup> (16,384) and 2<sup>24</sup>-1 (16,777,215) octets, inclusive.</p></div><div id="rfc.section.4.2.p.2"><p>All implementations MUST be capable of receiving and minimally processing frames up to 2<sup>14</sup> octets in length, plus the 9-octet frame header (<a href="#FrameHeader" title="Frame Format">Section&nbsp;4.1</a>). The size of the frame header is not included when describing frame sizes.</p></div><div class="alert alert-warning"><div id="rfc.section.4.2.p.3"><p><b>Note:</b> Certain frame types, such as PING (<a href="#PING" title="PING">Section&nbsp;6.7</a>), impose additional limits on the amount of payload data allowed.</p></div></div><div id="rfc.section.4.2.p.4"><p>An endpoint MUST send an error code of <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a> if a frame exceeds the size defined in <a href="#SETTINGS_MAX_FRAME_SIZE" class="smpl">SETTINGS_MAX_FRAME_SIZE</a>, exceeds any limit defined for the frame type, or is too small to contain mandatory frame data. A frame size error in a frame that could alter the state of the entire connection MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>); this includes any frame carrying a header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) (that is, <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>, and <a href="#CONTINUATION" class="smpl">CONTINUATION</a>), <a href="#SETTINGS" class="smpl">SETTINGS</a>, and any frame with a stream identifier of 0.</p></div><div id="rfc.section.4.2.p.5"><p>Endpoints are not obligated to use all available space in a frame. Responsiveness can be improved by using frames that are smaller than the permitted maximum size. Sending large frames can result in delays in sending time-sensitive frames (such as <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, or <a href="#PRIORITY" class="smpl">PRIORITY</a>), which, if blocked by the transmission of a large frame, could affect performance.</p></div></div><div id="HeaderBlock"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a href="#HeaderBlock">Header Compression and Decompression</a></h3><div id="rfc.section.4.3.p.1"><p>Just as in HTTP/1, a header field in HTTP/2 is a name with one or more associated values. Header fields are used within HTTP request and response messages as well as in server push operations (see <a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>).</p></div><div id="rfc.section.4.3.p.2"><p>Header lists are collections of zero or more header fields. When transmitted over a connection, a header list is serialized into a header block using <a href="#COMPRESSION">HTTP header compression</a> <cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite>. The serialized header block is then divided into one or more octet sequences, called header block fragments, and transmitted within the payload of HEADERS (<a href="#HEADERS" title="HEADERS">Section&nbsp;6.2</a>), PUSH_PROMISE (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section&nbsp;6.6</a>), or CONTINUATION (<a href="#CONTINUATION" title="CONTINUATION">Section&nbsp;6.10</a>) frames.</p></div><div id="rfc.section.4.3.p.3"><p>The <a href="#COOKIE">Cookie header field</a> <cite title="HTTP State Management Mechanism">[COOKIE]</cite> is treated specially by the HTTP mapping (see <a href="#CompressCookie" title="Compressing the Cookie Header Field">Section&nbsp;8.1.2.5</a>).</p></div><div id="rfc.section.4.3.p.4"><p>A receiving endpoint reassembles the header block by concatenating its fragments and then decompresses the block to reconstruct the header list.</p></div><div id="rfc.section.4.3.p.5"><p>A complete header block consists of either: </p><ul><li>a single <a href="#HEADERS" class="smpl">HEADERS</a> or <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame, with the END_HEADERS flag set, or</li><li>a <a href="#HEADERS" class="smpl">HEADERS</a> or <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame with the END_HEADERS flag cleared and one or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames, where the last <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frame has the END_HEADERS flag set.</li></ul></div><div id="rfc.section.4.3.p.6"><p>Header compression is stateful. One compression context and one decompression context are used for the entire connection. A decoding error in a header block MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#COMPRESSION_ERROR" class="smpl">COMPRESSION_ERROR</a>.</p></div><div id="rfc.section.4.3.p.7"><p>Each header block is processed as a discrete unit. Header blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved frames of any other type or from any other stream. The last frame in a sequence of <a href="#HEADERS" class="smpl">HEADERS</a> or <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames has the END_HEADERS flag set. The last frame in a sequence of <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> or <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames has the END_HEADERS flag set. This allows a header block to be logically equivalent to a single frame.</p></div><div id="rfc.section.4.3.p.8"><p>Header block fragments can only be sent as the payload of <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>, or <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames because these frames carry data that can modify the compression context maintained by a receiver. An endpoint receiving <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>, or <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames needs to reassemble header blocks and perform decompression even if the frames are to be discarded. A receiver MUST terminate the connection with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#COMPRESSION_ERROR" class="smpl">COMPRESSION_ERROR</a> if it does not decompress a header block.</p></div></div></div><div id="StreamsLayer"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#StreamsLayer">Streams and Multiplexing</a></h2><div id="rfc.section.5.p.1"><p>A "stream" is an independent, bidirectional sequence of frames exchanged between the client and server within an HTTP/2 connection. Streams have several important characteristics: </p><ul><li>A single HTTP/2 connection can contain multiple concurrently open streams, with either endpoint interleaving frames from multiple streams.</li><li>Streams can be established and used unilaterally or shared by either the client or server.</li><li>Streams can be closed by either endpoint.</li><li>The order in which frames are sent on a stream is significant. Recipients process frames in the order they are received. In particular, the order of <a href="#HEADERS" class="smpl">HEADERS</a> and <a href="#DATA" class="smpl">DATA</a> frames is semantically significant.</li><li>Streams are identified by an integer. Stream identifiers are assigned to streams by the endpoint initiating the stream.</li></ul></div><div id="StreamStates"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;<a href="#StreamStates">Stream States</a></h3><div id="rfc.section.5.1.p.1"><p>The lifecycle of a stream is shown in <a href="#StreamStatesFigure">Figure&nbsp;2</a>.</p></div><div id="StreamStatesFigure"></div><div id="rfc.figure.2"><pre class="drawing">            
                             +--------+
                     send PP |        | recv PP
                    ,--------|  idle  |--------.
                   /         |        |         \
                  v          +--------+          v
           +----------+          |           +----------+
           |          |          | send H /  |          |
    ,------| reserved |          | recv H    | reserved |------.
    |      | (local)  |          |           | (remote) |      |
    |      +----------+          v           +----------+      |
    |          |             +--------+             |          |
    |          |     recv ES |        | send ES     |          |
    |   send H |     ,-------|  open  |-------.     | recv H   |
    |          |    /        |        |        \    |          |
    |          v   v         +--------+         v   v          |
    |      +----------+          |           +----------+      |
    |      |   half   |          |           |   half   |      |
    |      |  closed  |          | send R /  |  closed  |      |
    |      | (remote) |          | recv R    | (local)  |      |
    |      +----------+          |           +----------+      |
    |           |                |                 |           |
    |           | send ES /      |       recv ES / |           |
    |           | send R /       v        send R / |           |
    |           | recv R     +--------+   recv R   |           |
    | send R /  `-----------&gt;|        |&lt;-----------'  send R / |
    | recv R                 | closed |               recv R   |
    `-----------------------&gt;|        |&lt;----------------------'
                             +--------+

       send:   endpoint sends this frame
       recv:   endpoint receives this frame

       H:  HEADERS frame (with implied CONTINUATIONs)
       PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
       ES: END_STREAM flag
       R:  RST_STREAM frame

          </pre></div><p class="figure">Figure 2: Stream States</p><div id="rfc.section.5.1.p.2"><p>Note that this diagram shows stream state transitions and the frames and flags that affect those transitions only. In this regard, <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames do not result in state transitions; they are effectively part of the <a href="#HEADERS" class="smpl">HEADERS</a> or <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> that they follow. For the purpose of state transitions, the END_STREAM flag is processed as a separate event to the frame that bears it; a <a href="#HEADERS" class="smpl">HEADERS</a> frame with the END_STREAM flag set can cause two state transitions.</p></div><div id="rfc.section.5.1.p.3"><p>Both endpoints have a subjective view of the state of a stream that could be different when frames are in transit. Endpoints do not coordinate the creation of streams; they are created unilaterally by either endpoint. The negative consequences of a mismatch in states are limited to the "closed" state after sending <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, where frames might be received for some time after closing.</p></div><div id="rfc.section.5.1.p.4"><p>Streams have the following states: </p><dl><dt>idle:</dt><dd><p><br> All streams start in the "idle" state.</p><p>The following transitions are valid from this state: </p><ul><li>Sending or receiving a <a href="#HEADERS" class="smpl">HEADERS</a> frame causes the stream to become "open". The stream identifier is selected as described in <a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>. The same <a href="#HEADERS" class="smpl">HEADERS</a> frame can also cause a stream to immediately become "half-closed".</li><li>Sending a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame on another stream reserves the idle stream that is identified for later use. The stream state for the reserved stream transitions to "reserved (local)".</li><li>Receiving a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame on another stream reserves an idle stream that is identified for later use. The stream state for the reserved stream transitions to "reserved (remote)".</li><li>Note that the <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame is not sent on the idle stream but references the newly reserved stream in the Promised Stream ID field.</li></ul><p>Receiving any frame other than <a href="#HEADERS" class="smpl">HEADERS</a> or <a href="#PRIORITY" class="smpl">PRIORITY</a> on a stream in this state MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></dd><dt>reserved (local):</dt><dd><p><br> A stream in the "reserved (local)" state is one that has been promised by sending a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame. A <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame reserves an idle stream by associating the stream with an open stream that was initiated by the remote peer (see <a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>).</p><p>In this state, only the following transitions are possible: </p><ul><li>The endpoint can send a <a href="#HEADERS" class="smpl">HEADERS</a> frame. This causes the stream to open in a "half-closed (remote)" state.</li><li>Either endpoint can send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame to cause the stream to become "closed". This releases the stream reservation.</li></ul><p>An endpoint MUST NOT send any type of frame other than <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, or <a href="#PRIORITY" class="smpl">PRIORITY</a> in this state.</p><p>A <a href="#PRIORITY" class="smpl">PRIORITY</a> or <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frame MAY be received in this state. Receiving any type of frame other than <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, <a href="#PRIORITY" class="smpl">PRIORITY</a>, or <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> on a stream in this state MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></dd><dt>reserved (remote):</dt><dd><p><br> A stream in the "reserved (remote)" state has been reserved by a remote peer.</p><p>In this state, only the following transitions are possible: </p><ul><li>Receiving a <a href="#HEADERS" class="smpl">HEADERS</a> frame causes the stream to transition to "half-closed (local)".</li><li>Either endpoint can send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame to cause the stream to become "closed". This releases the stream reservation.</li></ul><p>An endpoint MAY send a <a href="#PRIORITY" class="smpl">PRIORITY</a> frame in this state to reprioritize the reserved stream. An endpoint MUST NOT send any type of frame other than <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, or <a href="#PRIORITY" class="smpl">PRIORITY</a> in this state.</p><p>Receiving any type of frame other than <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, or <a href="#PRIORITY" class="smpl">PRIORITY</a> on a stream in this state MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></dd><dt>open:</dt><dd><p><br> A stream in the "open" state may be used by both peers to send frames of any type. In this state, sending peers observe advertised stream-level flow-control limits (<a href="#FlowControl" title="Flow Control">Section&nbsp;5.2</a>).</p><p>From this state, either endpoint can send a frame with an END_STREAM flag set, which causes the stream to transition into one of the "half-closed" states. An endpoint sending an END_STREAM flag causes the stream state to become "half-closed (local)"; an endpoint receiving an END_STREAM flag causes the stream state to become "half-closed (remote)".</p><p>Either endpoint can send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame from this state, causing it to transition immediately to "closed".</p></dd><dt>half-closed (local):</dt><dd><p><br> A stream that is in the "half-closed (local)" state cannot be used for sending frames other than <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, <a href="#PRIORITY" class="smpl">PRIORITY</a>, and <a href="#RST_STREAM" class="smpl">RST_STREAM</a>.</p><p>A stream transitions from this state to "closed" when a frame that contains an END_STREAM flag is received or when either peer sends a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame.</p><p>An endpoint can receive any type of frame in this state. Providing flow-control credit using <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frames is necessary to continue receiving flow-controlled frames. In this state, a receiver can ignore <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frames, which might arrive for a short period after a frame bearing the END_STREAM flag is sent.</p><p><a href="#PRIORITY" class="smpl">PRIORITY</a> frames received in this state are used to reprioritize streams that depend on the identified stream.</p></dd><dt>half-closed (remote):</dt><dd><p><br> A stream that is "half-closed (remote)" is no longer being used by the peer to send frames. In this state, an endpoint is no longer obligated to maintain a receiver flow-control window.</p><p>If an endpoint receives additional frames, other than <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, <a href="#PRIORITY" class="smpl">PRIORITY</a>, or <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, for a stream that is in this state, it MUST respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#STREAM_CLOSED" class="smpl">STREAM_CLOSED</a>.</p><p>A stream that is "half-closed (remote)" can be used by the endpoint to send frames of any type. In this state, the endpoint continues to observe advertised stream-level flow-control limits (<a href="#FlowControl" title="Flow Control">Section&nbsp;5.2</a>).</p><p>A stream can transition from this state to "closed" by sending a frame that contains an END_STREAM flag or when either peer sends a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame.</p></dd><dt>closed:</dt><dd><p><br> The "closed" state is the terminal state.</p><p>An endpoint MUST NOT send frames other than <a href="#PRIORITY" class="smpl">PRIORITY</a> on a closed stream. An endpoint that receives any frame other than <a href="#PRIORITY" class="smpl">PRIORITY</a> after receiving a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> MUST treat that as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#STREAM_CLOSED" class="smpl">STREAM_CLOSED</a>. Similarly, an endpoint that receives any frames after receiving a frame with the END_STREAM flag set MUST treat that as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#STREAM_CLOSED" class="smpl">STREAM_CLOSED</a>, unless the frame is permitted as described below.</p><p><a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> or <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frames can be received in this state for a short period after a <a href="#DATA" class="smpl">DATA</a> or <a href="#HEADERS" class="smpl">HEADERS</a> frame containing an END_STREAM flag is sent. Until the remote peer receives and processes <a href="#RST_STREAM" class="smpl">RST_STREAM</a> or the frame bearing the END_STREAM flag, it might send frames of these types. Endpoints MUST ignore <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> or <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frames received in this state, though endpoints MAY choose to treat frames that arrive a significant time after sending END_STREAM as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p><p><a href="#PRIORITY" class="smpl">PRIORITY</a> frames can be sent on closed streams to prioritize streams that are dependent on the closed stream. Endpoints SHOULD process <a href="#PRIORITY" class="smpl">PRIORITY</a> frames, though they can be ignored if the stream has been removed from the dependency tree (see <a href="#priority-gc" title="Prioritization State Management">Section&nbsp;5.3.4</a>).</p><p>If this state is reached as a result of sending a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame, the peer that receives the <a href="#RST_STREAM" class="smpl">RST_STREAM</a> might have already sent — or enqueued for sending — frames on the stream that cannot be withdrawn. An endpoint MUST ignore frames that it receives on closed streams after it has sent a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame. An endpoint MAY choose to limit the period over which it ignores frames and treat frames that arrive after this time as being in error.</p><p>Flow-controlled frames (i.e., <a href="#DATA" class="smpl">DATA</a>) received after sending <a href="#RST_STREAM" class="smpl">RST_STREAM</a> are counted toward the connection flow-control window. Even though these frames might be ignored, because they are sent before the sender receives the <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, the sender will consider the frames to count against the flow-control window.</p><p>An endpoint might receive a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame after it sends <a href="#RST_STREAM" class="smpl">RST_STREAM</a>. <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> causes a stream to become "reserved" even if the associated stream has been reset. Therefore, a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> is needed to close an unwanted promised stream.</p></dd></dl></div><div id="rfc.section.5.1.p.5"><p>In the absence of more specific guidance elsewhere in this document, implementations SHOULD treat the receipt of a frame that is not expressly permitted in the description of a state as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. Note that <a href="#PRIORITY" class="smpl">PRIORITY</a> can be sent and received in any stream state. Frames of unknown types are ignored.</p></div><div id="rfc.section.5.1.p.6"><p>An example of the state transitions for an HTTP request/response exchange can be found in <a href="#HttpSequence" title="HTTP Request/Response Exchange">Section&nbsp;8.1</a>. An example of the state transitions for server push can be found in Sections <a href="#PushRequests" title="Push Requests">8.2.1</a> and <a href="#PushResponses" title="Push Responses">8.2.2</a>.</p></div><div id="StreamIdentifiers"><h4 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1</a>&nbsp;<a href="#StreamIdentifiers">Stream Identifiers</a></h4><div id="rfc.section.5.1.1.p.1"><p>Streams are identified with an unsigned 31-bit integer. Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers. A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.</p></div><div id="rfc.section.5.1.1.p.2"><p>HTTP/1.1 requests that are upgraded to HTTP/2 (see <a href="#discover-http" title="Starting HTTP/2 for &#34;http&#34; URIs">Section&nbsp;3.2</a>) are responded to with a stream identifier of one (0x1). After the upgrade completes, stream 0x1 is "half-closed (local)" to the client. Therefore, stream 0x1 cannot be selected as a new stream identifier by a client that upgrades from HTTP/1.1.</p></div><div id="rfc.section.5.1.1.p.3"><p>The identifier of a newly established stream MUST be numerically greater than all streams that the initiating endpoint has opened or reserved. This governs streams that are opened using a <a href="#HEADERS" class="smpl">HEADERS</a> frame and streams that are reserved using <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>. An endpoint that receives an unexpected stream identifier MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.5.1.1.p.4"><p>The first use of a new stream identifier implicitly closes all streams in the "idle" state that might have been initiated by that peer with a lower-valued stream identifier. For example, if a client sends a <a href="#HEADERS" class="smpl">HEADERS</a> frame on stream 7 without ever sending a frame on stream 5, then stream 5 transitions to the "closed" state when the first frame for stream 7 is sent or received.</p></div><div id="rfc.section.5.1.1.p.5"><p>Stream identifiers cannot be reused. Long-lived connections can result in an endpoint exhausting the available range of stream identifiers. A client that is unable to establish a new stream identifier can establish a new connection for new streams. A server that is unable to establish a new stream identifier can send a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame so that the client is forced to open a new connection for new streams.</p></div></div><div><h4 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2</a>&nbsp;Stream Concurrency</h4><div id="rfc.section.5.1.2.p.1"><p>A peer can limit the number of concurrently active streams using the <a href="#SETTINGS_MAX_CONCURRENT_STREAMS" class="smpl">SETTINGS_MAX_CONCURRENT_STREAMS</a> parameter (see <a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a>) within a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame. The maximum concurrent streams setting is specific to each endpoint and applies only to the peer that receives the setting. That is, clients specify the maximum number of concurrent streams the server can initiate, and servers specify the maximum number of concurrent streams the client can initiate.</p></div><div id="rfc.section.5.1.2.p.2"><p>Streams that are in the "open" state or in either of the "half-closed" states count toward the maximum number of streams that an endpoint is permitted to open. Streams in any of these three states count toward the limit advertised in the <a href="#SETTINGS_MAX_CONCURRENT_STREAMS" class="smpl">SETTINGS_MAX_CONCURRENT_STREAMS</a> setting. Streams in either of the "reserved" states do not count toward the stream limit.</p></div><div id="rfc.section.5.1.2.p.3"><p>Endpoints MUST NOT exceed the limit set by their peer. An endpoint that receives a <a href="#HEADERS" class="smpl">HEADERS</a> frame that causes its advertised concurrent stream limit to be exceeded MUST treat this as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a> or <a href="#REFUSED_STREAM" class="smpl">REFUSED_STREAM</a>. The choice of error code determines whether the endpoint wishes to enable automatic retry (see <a href="#Reliability" title="Request Reliability Mechanisms in HTTP/2">Section&nbsp;8.1.4</a>) for details).</p></div><div id="rfc.section.5.1.2.p.4"><p>An endpoint that wishes to reduce the value of <a href="#SETTINGS_MAX_CONCURRENT_STREAMS" class="smpl">SETTINGS_MAX_CONCURRENT_STREAMS</a> to a value that is below the current number of open streams can either close streams that exceed the new value or allow streams to complete.</p></div></div></div><div id="FlowControl"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;<a href="#FlowControl">Flow Control</a></h3><div id="rfc.section.5.2.p.1"><p>Using streams for multiplexing introduces contention over use of the TCP connection, resulting in blocked streams. A flow-control scheme ensures that streams on the same connection do not destructively interfere with each other. Flow control is used for both individual streams and for the connection as a whole.</p></div><div id="rfc.section.5.2.p.2"><p>HTTP/2 provides for flow control through use of the WINDOW_UPDATE frame (<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section&nbsp;6.9</a>).</p></div><div id="fc-principles"><h4 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1</a>&nbsp;<a href="#fc-principles">Flow-Control Principles</a></h4><div id="rfc.section.5.2.1.p.1"><p>HTTP/2 stream flow control aims to allow a variety of flow-control algorithms to be used without requiring protocol changes. Flow control in HTTP/2 has the following characteristics: </p><ol><li>Flow control is specific to a connection. Both types of flow control are between the endpoints of a single hop and not over the entire end-to-end path.</li><li>Flow control is based on <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frames. Receivers advertise how many octets they are prepared to receive on a stream and for the entire connection. This is a credit-based scheme.</li><li>Flow control is directional with overall control provided by the receiver. A receiver MAY choose to set any window size that it desires for each stream and for the entire connection. A sender MUST respect flow-control limits imposed by a receiver. Clients, servers, and intermediaries all independently advertise their flow-control window as a receiver and abide by the flow-control limits set by their peer when sending.</li><li>The initial value for the flow-control window is 65,535 octets for both new streams and the overall connection.</li><li>The frame type determines whether flow control applies to a frame. Of the frames specified in this document, only <a href="#DATA" class="smpl">DATA</a> frames are subject to flow control; all other frame types do not consume space in the advertised flow-control window. This ensures that important control frames are not blocked by flow control.</li><li>Flow control cannot be disabled.</li><li>HTTP/2 defines only the format and semantics of the <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frame (<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section&nbsp;6.9</a>). This document does not stipulate how a receiver decides when to send this frame or the value that it sends, nor does it specify how a sender chooses to send packets. Implementations are able to select any algorithm that suits their needs.</li></ol></div><div id="rfc.section.5.2.1.p.2"><p>Implementations are also responsible for managing how requests and responses are sent based on priority, choosing how to avoid head-of-line blocking for requests, and managing the creation of new streams. Algorithm choices for these could interact with any flow-control algorithm.</p></div></div><div id="DisableFlowControl"><h4 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2</a>&nbsp;<a href="#DisableFlowControl">Appropriate Use of Flow Control</a></h4><div id="rfc.section.5.2.2.p.1"><p>Flow control is defined to protect endpoints that are operating under resource constraints. For example, a proxy needs to share memory between many connections and also might have a slow upstream connection and a fast downstream one. Flow-control addresses cases where the receiver is unable to process data on one stream yet wants to continue to process other streams in the same connection.</p></div><div id="rfc.section.5.2.2.p.2"><p>Deployments that do not require this capability can advertise a flow-control window of the maximum size (2<sup>31</sup>-1) and can maintain this window by sending a <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frame when any data is received. This effectively disables flow control for that receiver. Conversely, a sender is always subject to the flow-control window advertised by the receiver.</p></div><div id="rfc.section.5.2.2.p.3"><p>Deployments with constrained resources (for example, memory) can employ flow control to limit the amount of memory a peer can consume. Note, however, that this can lead to suboptimal use of available network resources if flow control is enabled without knowledge of the bandwidth-delay product (see <a href="#RFC7323"><cite title="TCP Extensions for High Performance">[RFC7323]</cite></a>).</p></div><div id="rfc.section.5.2.2.p.4"><p>Even with full awareness of the current bandwidth-delay product, implementation of flow control can be difficult. When using flow control, the receiver MUST read from the TCP receive buffer in a timely fashion. Failure to do so could lead to a deadlock when critical frames, such as <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, are not read and acted upon.</p></div></div></div><div id="StreamPriority"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;<a href="#StreamPriority">Stream Priority</a></h3><div id="rfc.section.5.3.p.1"><p>A client can assign a priority for a new stream by including prioritization information in the HEADERS frame (<a href="#HEADERS" title="HEADERS">Section&nbsp;6.2</a>) that opens the stream. At any other time, the PRIORITY frame (<a href="#PRIORITY" title="PRIORITY">Section&nbsp;6.3</a>) can be used to change the priority of a stream.</p></div><div id="rfc.section.5.3.p.2"><p>The purpose of prioritization is to allow an endpoint to express how it would prefer its peer to allocate resources when managing concurrent streams. Most importantly, priority can be used to select streams for transmitting frames when there is limited capacity for sending.</p></div><div id="rfc.section.5.3.p.3"><p>Streams can be prioritized by marking them as dependent on the completion of other streams (<a href="#pri-depend" title="Stream Dependencies">Section&nbsp;5.3.1</a>). Each dependency is assigned a relative weight, a number that is used to determine the relative proportion of available resources that are assigned to streams dependent on the same stream.</p></div><div id="rfc.section.5.3.p.4"><p>Explicitly setting the priority for a stream is input to a prioritization process. It does not guarantee any particular processing or transmission order for the stream relative to any other stream. An endpoint cannot force a peer to process concurrent streams in a particular order using priority. Expressing priority is therefore only a suggestion.</p></div><div id="rfc.section.5.3.p.5"><p>Prioritization information can be omitted from messages. Defaults are used prior to any explicit values being provided (<a href="#pri-default" title="Default Priorities">Section&nbsp;5.3.5</a>).</p></div><div id="pri-depend"><h4 id="rfc.section.5.3.1"><a href="#rfc.section.5.3.1">5.3.1</a>&nbsp;<a href="#pri-depend">Stream Dependencies</a></h4><div id="rfc.section.5.3.1.p.1"><p>Each stream can be given an explicit dependency on another stream. Including a dependency expresses a preference to allocate resources to the identified stream rather than to the dependent stream.</p></div><div id="rfc.section.5.3.1.p.2"><p>A stream that is not dependent on any other stream is given a stream dependency of 0x0. In other words, the non-existent stream 0 forms the root of the tree.</p></div><div id="rfc.section.5.3.1.p.3"><p>A stream that depends on another stream is a dependent stream. The stream upon which a stream is dependent is a parent stream. A dependency on a stream that is not currently in the tree — such as a stream in the "idle" state — results in that stream being given a default priority (<a href="#pri-default" title="Default Priorities">Section&nbsp;5.3.5</a>).</p></div><div id="rfc.section.5.3.1.p.4"><p>When assigning a dependency on another stream, the stream is added as a new dependency of the parent stream. Dependent streams that share the same parent are not ordered with respect to each other. For example, if streams B and C are dependent on stream A, and if stream D is created with a dependency on stream A, this results in a dependency order of A followed by B, C, and D in any order.</p></div><div id="ExampleofDefaultDependencyCreation"></div><div id="rfc.figure.3"><pre class="inline">    A                 A
   / \      ==&gt;      /|\
  B   C             B D C
</pre></div><p class="figure">Figure 3: Example of Default Dependency Creation</p><div id="rfc.section.5.3.1.p.5"><p>An exclusive flag allows for the insertion of a new level of dependencies. The exclusive flag causes the stream to become the sole dependency of its parent stream, causing other dependencies to become dependent on the exclusive stream. In the previous example, if stream D is created with an exclusive dependency on stream A, this results in D becoming the dependency parent of B and C.</p></div><div id="ExampleofExclusiveDependencyCreation"></div><div id="rfc.figure.4"><pre class="inline">                      A
    A                 |
   / \      ==&gt;       D
  B   C              / \
                    B   C
</pre></div><p class="figure">Figure 4: Example of Exclusive Dependency Creation</p><div id="rfc.section.5.3.1.p.6"><p>Inside the dependency tree, a dependent stream SHOULD only be allocated resources if either all of the streams that it depends on (the chain of parent streams up to 0x0) are closed or it is not possible to make progress on them.</p></div><div id="rfc.section.5.3.1.p.7"><p>A stream cannot depend on itself. An endpoint MUST treat this as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div></div><div><h4 id="rfc.section.5.3.2"><a href="#rfc.section.5.3.2">5.3.2</a>&nbsp;Dependency Weighting</h4><div id="rfc.section.5.3.2.p.1"><p>All dependent streams are allocated an integer weight between 1 and 256 (inclusive).</p></div><div id="rfc.section.5.3.2.p.2"><p>Streams with the same parent SHOULD be allocated resources proportionally based on their weight. Thus, if stream B depends on stream A with weight 4, stream C depends on stream A with weight 12, and no progress can be made on stream A, stream B ideally receives one-third of the resources allocated to stream C.</p></div></div><div id="reprioritize"><h4 id="rfc.section.5.3.3"><a href="#rfc.section.5.3.3">5.3.3</a>&nbsp;<a href="#reprioritize">Reprioritization</a></h4><div id="rfc.section.5.3.3.p.1"><p>Stream priorities are changed using the <a href="#PRIORITY" class="smpl">PRIORITY</a> frame. Setting a dependency causes a stream to become dependent on the identified parent stream.</p></div><div id="rfc.section.5.3.3.p.2"><p>Dependent streams move with their parent stream if the parent is reprioritized. Setting a dependency with the exclusive flag for a reprioritized stream causes all the dependencies of the new parent stream to become dependent on the reprioritized stream.</p></div><div id="rfc.section.5.3.3.p.3"><p>If a stream is made dependent on one of its own dependencies, the formerly dependent stream is first moved to be dependent on the reprioritized stream's previous parent. The moved dependency retains its weight.</p></div><div id="ExampleofDependencyReordering"></div><div id="rfc.figure.5"><p>For example, consider an original dependency tree where B and C depend on A, D and E depend on C, and F depends on D. If A is made dependent on D, then D takes the place of A. All other dependency relationships stay the same, except for F, which becomes dependent on A if the reprioritization is exclusive.</p><pre class="inline">    x                x                x                 x
    |               / \               |                 |
    A              D   A              D                 D
   / \            /   / \            / \                |
  B   C     ==&gt;  F   B   C   ==&gt;    F   A       OR      A
     / \                 |             / \             /|\
    D   E                E            B   C           B C F
    |                                     |             |
    F                                     E             E
               (intermediate)   (non-exclusive)    (exclusive)
</pre></div><p class="figure">Figure 5: Example of Dependency Reordering</p></div><div id="priority-gc"><h4 id="rfc.section.5.3.4"><a href="#rfc.section.5.3.4">5.3.4</a>&nbsp;<a href="#priority-gc">Prioritization State Management</a></h4><div id="rfc.section.5.3.4.p.1"><p>When a stream is removed from the dependency tree, its dependencies can be moved to become dependent on the parent of the closed stream. The weights of new dependencies are recalculated by distributing the weight of the dependency of the closed stream proportionally based on the weights of its dependencies.</p></div><div id="rfc.section.5.3.4.p.2"><p>Streams that are removed from the dependency tree cause some prioritization information to be lost. Resources are shared between streams with the same parent stream, which means that if a stream in that set closes or becomes blocked, any spare capacity allocated to a stream is distributed to the immediate neighbors of the stream. However, if the common dependency is removed from the tree, those streams share resources with streams at the next highest level.</p></div><div id="rfc.section.5.3.4.p.3"><p>For example, assume streams A and B share a parent, and streams C and D both depend on stream A. Prior to the removal of stream A, if streams A and D are unable to proceed, then stream C receives all the resources dedicated to stream A. If stream A is removed from the tree, the weight of stream A is divided between streams C and D. If stream D is still unable to proceed, this results in stream C receiving a reduced proportion of resources. For equal starting weights, C receives one third, rather than one half, of available resources.</p></div><div id="rfc.section.5.3.4.p.4"><p>It is possible for a stream to become closed while prioritization information that creates a dependency on that stream is in transit. If a stream identified in a dependency has no associated priority information, then the dependent stream is instead assigned a default priority (<a href="#pri-default" title="Default Priorities">Section&nbsp;5.3.5</a>). This potentially creates suboptimal prioritization, since the stream could be given a priority that is different from what is intended.</p></div><div id="rfc.section.5.3.4.p.5"><p>To avoid these problems, an endpoint SHOULD retain stream prioritization state for a period after streams become closed. The longer state is retained, the lower the chance that streams are assigned incorrect or default priority values.</p></div><div id="rfc.section.5.3.4.p.6"><p>Similarly, streams that are in the "idle" state can be assigned priority or become a parent of other streams. This allows for the creation of a grouping node in the dependency tree, which enables more flexible expressions of priority. Idle streams begin with a default priority (<a href="#pri-default" title="Default Priorities">Section&nbsp;5.3.5</a>).</p></div><div id="rfc.section.5.3.4.p.7"><p>The retention of priority information for streams that are not counted toward the limit set by <a href="#SETTINGS_MAX_CONCURRENT_STREAMS" class="smpl">SETTINGS_MAX_CONCURRENT_STREAMS</a> could create a large state burden for an endpoint. Therefore, the amount of prioritization state that is retained MAY be limited.</p></div><div id="rfc.section.5.3.4.p.8"><p>The amount of additional state an endpoint maintains for prioritization could be dependent on load; under high load, prioritization state can be discarded to limit resource commitments. In extreme cases, an endpoint could even discard prioritization state for active or reserved streams. If a limit is applied, endpoints SHOULD maintain state for at least as many streams as allowed by their setting for <a href="#SETTINGS_MAX_CONCURRENT_STREAMS" class="smpl">SETTINGS_MAX_CONCURRENT_STREAMS</a>. Implementations SHOULD also attempt to retain state for streams that are in active use in the priority tree.</p></div><div id="rfc.section.5.3.4.p.9"><p>If it has retained enough state to do so, an endpoint receiving a <a href="#PRIORITY" class="smpl">PRIORITY</a> frame that changes the priority of a closed stream SHOULD alter the dependencies of the streams that depend on it.</p></div></div><div id="pri-default"><h4 id="rfc.section.5.3.5"><a href="#rfc.section.5.3.5">5.3.5</a>&nbsp;<a href="#pri-default">Default Priorities</a></h4><div id="rfc.section.5.3.5.p.1"><p>All streams are initially assigned a non-exclusive dependency on stream 0x0. Pushed streams (<a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>) initially depend on their associated stream. In both cases, streams are assigned a default weight of 16.</p></div></div></div><div id="ErrorHandler"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4</a>&nbsp;<a href="#ErrorHandler">Error Handling</a></h3><div id="rfc.section.5.4.p.1"><p>HTTP/2 framing permits two classes of error: </p><ul><li>An error condition that renders the entire connection unusable is a connection error.</li><li>An error in an individual stream is a stream error.</li></ul></div><div id="rfc.section.5.4.p.2"><p>A list of error codes is included in <a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>.</p></div><div id="ConnectionErrorHandler"><h4 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1</a>&nbsp;<a href="#ConnectionErrorHandler">Connection Error Handling</a></h4><div id="rfc.section.5.4.1.p.1"><p>A connection error is any error that prevents further processing of the frame layer or corrupts any connection state.</p></div><div id="rfc.section.5.4.1.p.2"><p>An endpoint that encounters a connection error SHOULD first send a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;6.8</a>) with the stream identifier of the last stream that it successfully received from its peer. The <a href="#GOAWAY" class="smpl">GOAWAY</a> frame includes an error code that indicates why the connection is terminating. After sending the <a href="#GOAWAY" class="smpl">GOAWAY</a> frame for an error condition, the endpoint MUST close the TCP connection.</p></div><div id="rfc.section.5.4.1.p.3"><p>It is possible that the <a href="#GOAWAY" class="smpl">GOAWAY</a> will not be reliably received by the receiving endpoint (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#persistent.tear-down" title="Tear-down">Section 6.6</a> describes how an immediate connection close can result in data loss). In the event of a connection error, <a href="#GOAWAY" class="smpl">GOAWAY</a> only provides a best-effort attempt to communicate with the peer about why the connection is being terminated.</p></div><div id="rfc.section.5.4.1.p.4"><p>An endpoint can end a connection at any time. In particular, an endpoint MAY choose to treat a stream error as a connection error. Endpoints SHOULD send a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame when ending a connection, providing that circumstances permit it.</p></div></div><div id="StreamErrorHandler"><h4 id="rfc.section.5.4.2"><a href="#rfc.section.5.4.2">5.4.2</a>&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></h4><div id="rfc.section.5.4.2.p.1"><p>A stream error is an error related to a specific stream that does not affect processing of other streams.</p></div><div id="rfc.section.5.4.2.p.2"><p>An endpoint that detects a stream error sends a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame (<a href="#RST_STREAM" title="RST_STREAM">Section&nbsp;6.4</a>) that contains the stream identifier of the stream where the error occurred. The <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame includes an error code that indicates the type of error.</p></div><div id="rfc.section.5.4.2.p.3"><p>A <a href="#RST_STREAM" class="smpl">RST_STREAM</a> is the last frame that an endpoint can send on a stream. The peer that sends the <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame MUST be prepared to receive any frames that were sent or enqueued for sending by the remote peer. These frames can be ignored, except where they modify connection state (such as the state maintained for header compression (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) or flow control).</p></div><div id="rfc.section.5.4.2.p.4"><p>Normally, an endpoint SHOULD NOT send more than one <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame for any stream. However, an endpoint MAY send additional <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frames if it receives frames on a closed stream after more than a round-trip time. This behavior is permitted to deal with misbehaving implementations.</p></div><div id="rfc.section.5.4.2.p.5"><p>To avoid looping, an endpoint MUST NOT send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> in response to a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame.</p></div></div><div><h4 id="rfc.section.5.4.3"><a href="#rfc.section.5.4.3">5.4.3</a>&nbsp;Connection Termination</h4><div id="rfc.section.5.4.3.p.1"><p>If the TCP connection is closed or reset while streams remain in "open" or "half-closed" state, then the affected streams cannot be automatically retried (see <a href="#Reliability" title="Request Reliability Mechanisms in HTTP/2">Section&nbsp;8.1.4</a> for details).</p></div></div></div><div id="extensibility"><h3 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5</a>&nbsp;<a href="#extensibility">Extending HTTP/2</a></h3><div id="rfc.section.5.5.p.1"><p>HTTP/2 permits extension of the protocol. Within the limitations described in this section, protocol extensions can be used to provide additional services or alter any aspect of the protocol. Extensions are effective only within the scope of a single HTTP/2 connection.</p></div><div id="rfc.section.5.5.p.2"><p>This applies to the protocol elements defined in this document. This does not affect the existing options for extending HTTP, such as defining new methods, status codes, or header fields.</p></div><div id="rfc.section.5.5.p.3"><p>Extensions are permitted to use new frame types (<a href="#FrameHeader" title="Frame Format">Section&nbsp;4.1</a>), new settings (<a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a>), or new error codes (<a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>). Registries are established for managing these extension points: frame types (<a href="#iana-frames" title="Frame Type Registry">Section&nbsp;11.2</a>), settings (<a href="#iana-settings" title="Settings Registry">Section&nbsp;11.3</a>), and error codes (<a href="#iana-errors" title="Error Code Registry">Section&nbsp;11.4</a>).</p></div><div id="rfc.section.5.5.p.4"><p>Implementations MUST ignore unknown or unsupported values in all extensible protocol elements. Implementations MUST discard frames that have unknown or unsupported types. This means that any of these extension points can be safely used by extensions without prior arrangement or negotiation. However, extension frames that appear in the middle of a header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) are not permitted; these MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.5.5.p.5"><p>Extensions that could change the semantics of existing protocol components MUST be negotiated before being used. For example, an extension that changes the layout of the <a href="#HEADERS" class="smpl">HEADERS</a> frame cannot be used until the peer has given a positive signal that this is acceptable. In this case, it could also be necessary to coordinate when the revised layout comes into effect. Note that treating any frames other than <a href="#DATA" class="smpl">DATA</a> frames as flow controlled is such a change in semantics and can only be done through negotiation.</p></div><div id="rfc.section.5.5.p.6"><p>This document doesn't mandate a specific method for negotiating the use of an extension but notes that a setting (<a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a>) could be used for that purpose. If both peers set a value that indicates willingness to use the extension, then the extension can be used. If a setting is used for extension negotiation, the initial value MUST be defined in such a fashion that the extension is initially disabled.</p></div></div></div><div id="FrameTypes"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#FrameTypes">Frame Definitions</a></h2><div id="rfc.section.6.p.1"><p>This specification defines a number of frame types, each identified by a unique 8-bit type code. Each frame type serves a distinct purpose in the establishment and management either of the connection as a whole or of individual streams.</p></div><div id="rfc.section.6.p.2"><p>The transmission of specific frame types can alter the state of a connection. If endpoints fail to maintain a synchronized view of the connection state, successful communication within the connection will no longer be possible. Therefore, it is important that endpoints have a shared comprehension of how the state is affected by the use any given frame.</p></div><div id="DATA"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a>&nbsp;<a href="#DATA">DATA</a></h3><div id="rfc.section.6.1.p.1"><p>DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response payloads.</p></div><div id="rfc.section.6.1.p.2"><p>DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the size of messages. Padding is a security feature; see <a href="#padding" title="Use of Padding">Section&nbsp;10.7</a>.</p></div><div id="DATAFramePayload"></div><div id="rfc.figure.6"><pre class="inline"> +---------------+
 |Pad Length? (8)|
 +---------------+-----------------------------------------------+
 |                            Data (*)                         ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 6: DATA Frame Payload</p><div id="rfc.section.6.1.p.3"><p>The DATA frame contains the following fields: </p><dl><dt>Pad Length:</dt><dd>An 8-bit field containing the length of the frame padding in units of octets. This field is conditional (as signified by a "?" in the diagram) and is only present if the PADDED flag is set.</dd><dt>Data:</dt><dd>Application data. The amount of data is the remainder of the frame payload after subtracting the length of the other fields that are present.</dd><dt>Padding:</dt><dd>Padding octets that contain no application semantic value. Padding octets MUST be set to zero when sending. A receiver is not obligated to verify padding but MAY treat non-zero padding as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</dd></dl></div><div id="rfc.section.6.1.p.4"><p>The DATA frame defines the following flags: </p><dl><dt>END_STREAM (0x1):</dt><dd>When set, bit 0 indicates that this frame is the last that the endpoint will send for the identified stream. Setting this flag causes the stream to enter one of the "half-closed" states or the "closed" state (<a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>).</dd><dt>PADDED (0x8):</dt><dd>When set, bit 3 indicates that the Pad Length field and any padding that it describes are present.</dd></dl></div><div id="rfc.section.6.1.p.5"><p>DATA frames MUST be associated with a stream. If a DATA frame is received whose stream identifier field is 0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.1.p.6"><p>DATA frames are subject to flow control and can only be sent when a stream is in the "open" or "half-closed (remote)" state. The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present. If a DATA frame is received whose stream is not in "open" or "half-closed (local)" state, the recipient MUST respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#STREAM_CLOSED" class="smpl">STREAM_CLOSED</a>.</p></div><div id="rfc.section.6.1.p.7"><p>The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient MUST treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div class="alert alert-warning"><div id="rfc.section.6.1.p.8"><p><b>Note:</b> A frame can be increased in size by one octet by including a Pad Length field with a value of zero.</p></div></div></div><div id="HEADERS"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a>&nbsp;<a href="#HEADERS">HEADERS</a></h3><div id="rfc.section.6.2.p.1"><p>The HEADERS frame (type=0x1) is used to open a stream (<a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>), and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.</p></div><div id="HEADERSFramePayload"></div><div id="rfc.figure.7"><pre class="inline"> +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |E|                 Stream Dependency? (31)                     |
 +-+-------------+-----------------------------------------------+
 |  Weight? (8)  |
 +-+-------------+-----------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 7: HEADERS Frame Payload</p><div id="rfc.section.6.2.p.2"><p>The HEADERS frame payload has the following fields: </p><dl><dt>Pad Length:</dt><dd>An 8-bit field containing the length of the frame padding in units of octets. This field is only present if the PADDED flag is set.</dd><dt>E:</dt><dd>A single-bit flag indicating that the stream dependency is exclusive (see <a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>). This field is only present if the PRIORITY flag is set.</dd><dt>Stream Dependency:</dt><dd>A 31-bit stream identifier for the stream that this stream depends on (see <a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>). This field is only present if the PRIORITY flag is set.</dd><dt>Weight:</dt><dd>An unsigned 8-bit integer representing a priority weight for the stream (see <a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>). Add one to the value to obtain a weight between 1 and 256. This field is only present if the PRIORITY flag is set.</dd><dt>Header Block Fragment:</dt><dd>A header block fragment (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>).</dd><dt>Padding:</dt><dd>Padding octets.</dd></dl></div><div id="rfc.section.6.2.p.3"><p>The HEADERS frame defines the following flags: </p><dl><dt>END_STREAM (0x1):</dt><dd><p>When set, bit 0 indicates that the header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) is the last that the endpoint will send for the identified stream.</p><p>A HEADERS frame carries the END_STREAM flag that signals the end of a stream. However, a HEADERS frame with the END_STREAM flag set can be followed by <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames on the same stream. Logically, the <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames are part of the HEADERS frame.</p></dd><dt>END_HEADERS (0x4):</dt><dd><p>When set, bit 2 indicates that this frame contains an entire header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) and is not followed by any <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames.</p><p>A HEADERS frame without the END_HEADERS flag set MUST be followed by a <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frame for the same stream. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></dd><dt>PADDED (0x8):</dt><dd><p>When set, bit 3 indicates that the Pad Length field and any padding that it describes are present.</p></dd><dt>PRIORITY (0x20):</dt><dd><p>When set, bit 5 indicates that the Exclusive Flag (E), Stream Dependency, and Weight fields are present; see <a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>.</p></dd></dl></div><div id="rfc.section.6.2.p.4"><p>The payload of a HEADERS frame contains a header block fragment (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>). A header block that does not fit within a HEADERS frame is continued in a CONTINUATION frame (<a href="#CONTINUATION" title="CONTINUATION">Section&nbsp;6.10</a>).</p></div><div id="rfc.section.6.2.p.5"><p>HEADERS frames MUST be associated with a stream. If a HEADERS frame is received whose stream identifier field is 0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.2.p.6"><p>The HEADERS frame changes the connection state as described in <a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>.</p></div><div id="rfc.section.6.2.p.7"><p>The HEADERS frame can include padding. Padding fields and flags are identical to those defined for DATA frames (<a href="#DATA" title="DATA">Section&nbsp;6.1</a>). Padding that exceeds the size remaining for the header block fragment MUST be treated as a <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.2.p.8"><p>Prioritization information in a HEADERS frame is logically equivalent to a separate <a href="#PRIORITY" class="smpl">PRIORITY</a> frame, but inclusion in HEADERS avoids the potential for churn in stream prioritization when new streams are created. Prioritization fields in HEADERS frames subsequent to the first on a stream reprioritize the stream (<a href="#reprioritize" title="Reprioritization">Section&nbsp;5.3.3</a>).</p></div></div><div id="PRIORITY"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3</a>&nbsp;<a href="#PRIORITY">PRIORITY</a></h3><div id="rfc.section.6.3.p.1"><p>The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream (<a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>). It can be sent in any stream state, including idle or closed streams.</p></div><div id="PRIORITYFramePayload"></div><div id="rfc.figure.8"><pre class="inline"> +-+-------------------------------------------------------------+
 |E|                  Stream Dependency (31)                     |
 +-+-------------+-----------------------------------------------+
 |   Weight (8)  |
 +-+-------------+
</pre></div><p class="figure">Figure 8: PRIORITY Frame Payload</p><div id="rfc.section.6.3.p.2"><p>The payload of a PRIORITY frame contains the following fields: </p><dl><dt>E:</dt><dd>A single-bit flag indicating that the stream dependency is exclusive (see <a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>).</dd><dt>Stream Dependency:</dt><dd>A 31-bit stream identifier for the stream that this stream depends on (see <a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>).</dd><dt>Weight:</dt><dd>An unsigned 8-bit integer representing a priority weight for the stream (see <a href="#StreamPriority" title="Stream Priority">Section&nbsp;5.3</a>). Add one to the value to obtain a weight between 1 and 256.</dd></dl></div><div id="rfc.section.6.3.p.3"><p>The PRIORITY frame does not define any flags.</p></div><div id="rfc.section.6.3.p.4"><p>The PRIORITY frame always identifies a stream. If a PRIORITY frame is received with a stream identifier of 0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.3.p.5"><p>The PRIORITY frame can be sent on a stream in any state, though it cannot be sent between consecutive frames that comprise a single header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>). Note that this frame could arrive after processing or frame sending has completed, which would cause it to have no effect on the identified stream. For a stream that is in the "half-closed (remote)" or "closed" state, this frame can only affect processing of the identified stream and its dependent streams; it does not affect frame transmission on that stream.</p></div><div id="rfc.section.6.3.p.6"><p>The PRIORITY frame can be sent for a stream in the "idle" or "closed" state. This allows for the reprioritization of a group of dependent streams by altering the priority of an unused or closed parent stream.</p></div><div id="rfc.section.6.3.p.7"><p>A PRIORITY frame with a length other than 5 octets MUST be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a>.</p></div></div><div id="RST_STREAM"><h3 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4</a>&nbsp;<a href="#RST_STREAM">RST_STREAM</a></h3><div id="rfc.section.6.4.p.1"><p>The RST_STREAM frame (type=0x3) allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.</p></div><div id="RST_STREAMFramePayload"></div><div id="rfc.figure.9"><pre class="inline"> +---------------------------------------------------------------+
 |                        Error Code (32)                        |
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 9: RST_STREAM Frame Payload</p><div id="rfc.section.6.4.p.2"><p>The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error code (<a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>). The error code indicates why the stream is being terminated.</p></div><div id="rfc.section.6.4.p.3"><p>The RST_STREAM frame does not define any flags.</p></div><div id="rfc.section.6.4.p.4"><p>The RST_STREAM frame fully terminates the referenced stream and causes it to enter the "closed" state. After receiving a RST_STREAM on a stream, the receiver MUST NOT send additional frames for that stream, with the exception of <a href="#PRIORITY" class="smpl">PRIORITY</a>. However, after sending the RST_STREAM, the sending endpoint MUST be prepared to receive and process additional frames sent on the stream that might have been sent by the peer prior to the arrival of the RST_STREAM.</p></div><div id="rfc.section.6.4.p.5"><p>RST_STREAM frames MUST be associated with a stream. If a RST_STREAM frame is received with a stream identifier of 0x0, the recipient MUST treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.4.p.6"><p>RST_STREAM frames MUST NOT be sent for a stream in the "idle" state. If a RST_STREAM frame identifying an idle stream is received, the recipient MUST treat this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.4.p.7"><p>A RST_STREAM frame with a length other than 4 octets MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a>.</p></div></div><div id="SETTINGS"><h3 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5</a>&nbsp;<a href="#SETTINGS">SETTINGS</a></h3><div id="rfc.section.6.5.p.1"><p>The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those parameters. Individually, a SETTINGS parameter can also be referred to as a "setting".</p></div><div id="rfc.section.6.5.p.2"><p>SETTINGS parameters are not negotiated; they describe characteristics of the sending peer, which are used by the receiving peer. Different values for the same parameter can be advertised by each peer. For example, a client might set a high initial flow-control window, whereas a server might set a lower value to conserve resources.</p></div><div id="rfc.section.6.5.p.3"><p>A SETTINGS frame MUST be sent by both endpoints at the start of a connection and MAY be sent at any other time by either endpoint over the lifetime of the connection. Implementations MUST support all of the parameters defined by this specification.</p></div><div id="rfc.section.6.5.p.4"><p>Each parameter in a SETTINGS frame replaces any existing value for that parameter. Parameters are processed in the order in which they appear, and a receiver of a SETTINGS frame does not need to maintain any state other than the current value of its parameters. Therefore, the value of a SETTINGS parameter is the last value that is seen by a receiver.</p></div><div id="rfc.section.6.5.p.5"><p>SETTINGS parameters are acknowledged by the receiving peer. To enable this, the SETTINGS frame defines the following flag: </p><dl><dt>ACK (0x1):</dt><dd>When set, bit 0 indicates that this frame acknowledges receipt and application of the peer's SETTINGS frame. When this bit is set, the payload of the SETTINGS frame MUST be empty. Receipt of a SETTINGS frame with the ACK flag set and a length field value other than 0 MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a>. For more information, see <a href="#SettingsSync" title="Settings Synchronization">Section&nbsp;6.5.3</a> ("<a href="#SettingsSync" title="Settings Synchronization">Settings Synchronization</a>").</dd></dl></div><div id="rfc.section.6.5.p.6"><p>SETTINGS frames always apply to a connection, never a single stream. The stream identifier for a SETTINGS frame MUST be zero (0x0). If an endpoint receives a SETTINGS frame whose stream identifier field is anything other than 0x0, the endpoint MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.5.p.7"><p>The SETTINGS frame affects connection state. A badly formed or incomplete SETTINGS frame MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.5.p.8"><p>A SETTINGS frame with a length other than a multiple of 6 octets MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a>.</p></div><div id="SettingFormat"><h4 id="rfc.section.6.5.1"><a href="#rfc.section.6.5.1">6.5.1</a>&nbsp;<a href="#SettingFormat">SETTINGS Format</a></h4><div id="rfc.section.6.5.1.p.1"><p>The payload of a SETTINGS frame consists of zero or more parameters, each consisting of an unsigned 16-bit setting identifier and an unsigned 32-bit value.</p></div><div id="SettingFormatFigure"></div><div id="rfc.figure.10"><pre class="inline"> +-------------------------------+
 |       Identifier (16)         |
 +-------------------------------+-------------------------------+
 |                        Value (32)                             |
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 10: Setting Format</p></div><div id="SettingValues"><h4 id="rfc.section.6.5.2"><a href="#rfc.section.6.5.2">6.5.2</a>&nbsp;<a href="#SettingValues">Defined SETTINGS Parameters</a></h4><div id="rfc.section.6.5.2.p.1"><p>The following parameters are defined: </p><dl><dt id="SETTINGS_HEADER_TABLE_SIZE">SETTINGS_HEADER_TABLE_SIZE (0x1):</dt><dd><p>Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets. The encoder can select any size equal to or less than this value by using signaling specific to the header compression format inside a header block (see <a href="#COMPRESSION"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>). The initial value is 4,096 octets.</p></dd><dt id="SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH (0x2):</dt><dd><p>This setting can be used to disable server push (<a href="#PushResources" title="Server Push">Section&nbsp;8.2</a>). An endpoint MUST NOT send a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame if it receives this parameter set to a value of 0. An endpoint that has both set this parameter to 0 and had it acknowledged MUST treat the receipt of a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p><p>The initial value is 1, which indicates that server push is permitted. Any value other than 0 or 1 MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></dd><dt id="SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS (0x3):</dt><dd><p>Indicates the maximum number of concurrent streams that the sender will allow. This limit is directional: it applies to the number of streams that the sender permits the receiver to create. Initially, there is no limit to this value. It is recommended that this value be no smaller than 100, so as to not unnecessarily limit parallelism.</p><p>A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be treated as special by endpoints. A zero value does prevent the creation of new streams; however, this can also happen for any limit that is exhausted with active streams. Servers SHOULD only set a zero value for short durations; if a server does not wish to accept requests, closing the connection is more appropriate.</p></dd><dt id="SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE (0x4):</dt><dd><p>Indicates the sender's initial window size (in octets) for stream-level flow control. The initial value is 2<sup>16</sup>-1 (65,535) octets.</p><p>This setting affects the window size of all streams (see <a href="#InitialWindowSize" title="Initial Flow-Control Window Size">Section&nbsp;6.9.2</a>).</p><p>Values above the maximum flow-control window size of 2<sup>31</sup>-1 MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a>.</p></dd><dt id="SETTINGS_MAX_FRAME_SIZE">SETTINGS_MAX_FRAME_SIZE (0x5):</dt><dd><p>Indicates the size of the largest frame payload that the sender is willing to receive, in octets.</p><p>The initial value is 2<sup>14</sup> (16,384) octets. The value advertised by an endpoint MUST be between this initial value and the maximum allowed frame size (2<sup>24</sup>-1 or 16,777,215 octets), inclusive. Values outside this range MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></dd><dt id="SETTINGS_MAX_HEADER_LIST_SIZE">SETTINGS_MAX_HEADER_LIST_SIZE (0x6):</dt><dd><p>This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets. The value is based on the uncompressed size of header fields, including the length of the name and value in octets plus an overhead of 32 octets for each header field.</p><p>For any given request, a lower limit than what is advertised MAY be enforced. The initial value of this setting is unlimited.</p></dd></dl></div><div id="rfc.section.6.5.2.p.2"><p>An endpoint that receives a SETTINGS frame with any unknown or unsupported identifier MUST ignore that setting.</p></div></div><div id="SettingsSync"><h4 id="rfc.section.6.5.3"><a href="#rfc.section.6.5.3">6.5.3</a>&nbsp;<a href="#SettingsSync">Settings Synchronization</a></h4><div id="rfc.section.6.5.3.p.1"><p>Most values in SETTINGS benefit from or require an understanding of when the peer has received and applied the changed parameter values. In order to provide such synchronization timepoints, the recipient of a SETTINGS frame in which the ACK flag is not set MUST apply the updated parameters as soon as possible upon receipt.</p></div><div id="rfc.section.6.5.3.p.2"><p>The values in the SETTINGS frame MUST be processed in the order they appear, with no other frame processing between values. Unsupported parameters MUST be ignored. Once all values have been processed, the recipient MUST immediately emit a SETTINGS frame with the ACK flag set. Upon receiving a SETTINGS frame with the ACK flag set, the sender of the altered parameters can rely on the setting having been applied.</p></div><div id="rfc.section.6.5.3.p.3"><p>If the sender of a SETTINGS frame does not receive an acknowledgement within a reasonable amount of time, it MAY issue a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#SETTINGS_TIMEOUT" class="smpl">SETTINGS_TIMEOUT</a>.</p></div></div></div><div id="PUSH_PROMISE"><h3 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6</a>&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></h3><div id="rfc.section.6.6.p.1"><p>The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a set of headers that provide additional context for the stream. <a href="#PushResources" title="Server Push">Section&nbsp;8.2</a> contains a thorough description of the use of PUSH_PROMISE frames.</p></div><div id="PUSH_PROMISEPayloadFormat"></div><div id="rfc.figure.11"><pre class="inline"> +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |R|                  Promised Stream ID (31)                    |
 +-+-----------------------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 11: PUSH_PROMISE Payload Format</p><div id="rfc.section.6.6.p.2"><p>The PUSH_PROMISE frame payload has the following fields: </p><dl><dt>Pad Length:</dt><dd>An 8-bit field containing the length of the frame padding in units of octets. This field is only present if the PADDED flag is set.</dd><dt>R:</dt><dd>A single reserved bit.</dd><dt>Promised Stream ID:</dt><dd>An unsigned 31-bit integer that identifies the stream that is reserved by the PUSH_PROMISE. The promised stream identifier MUST be a valid choice for the next stream sent by the sender (see "new stream identifier" in <a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>).</dd><dt>Header Block Fragment:</dt><dd>A header block fragment (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) containing request header fields.</dd><dt>Padding:</dt><dd>Padding octets.</dd></dl></div><div id="rfc.section.6.6.p.3"><p>The PUSH_PROMISE frame defines the following flags: </p><dl><dt>END_HEADERS (0x4):</dt><dd><p>When set, bit 2 indicates that this frame contains an entire header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) and is not followed by any <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames.</p><p>A PUSH_PROMISE frame without the END_HEADERS flag set MUST be followed by a CONTINUATION frame for the same stream. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></dd><dt>PADDED (0x8):</dt><dd><p>When set, bit 3 indicates that the Pad Length field and any padding that it describes are present.</p></dd></dl></div><div id="rfc.section.6.6.p.4"><p>PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that is in either the "open" or "half-closed (remote)" state. The stream identifier of a PUSH_PROMISE frame indicates the stream it is associated with. If the stream identifier field specifies the value 0x0, a recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.6.p.5"><p>Promised streams are not required to be used in the order they are promised. The PUSH_PROMISE only reserves stream identifiers for later use.</p></div><div id="rfc.section.6.6.p.6"><p>PUSH_PROMISE MUST NOT be sent if the <a href="#SETTINGS_ENABLE_PUSH" class="smpl">SETTINGS_ENABLE_PUSH</a> setting of the peer endpoint is set to 0. An endpoint that has set this setting and has received acknowledgement MUST treat the receipt of a PUSH_PROMISE frame as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.6.p.7"><p>Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> referencing the promised stream identifier back to the sender of the PUSH_PROMISE.</p></div><div id="rfc.section.6.6.p.8"><p>A PUSH_PROMISE frame modifies the connection state in two ways. First, the inclusion of a header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) potentially modifies the state maintained for header compression. Second, PUSH_PROMISE also reserves a stream for later use, causing the promised stream to enter the "reserved" state. A sender MUST NOT send a PUSH_PROMISE on a stream unless that stream is either "open" or "half-closed (remote)"; the sender MUST ensure that the promised stream is a valid choice for a new stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>) (that is, the promised stream MUST be in the "idle" state).</p></div><div id="rfc.section.6.6.p.9"><p>Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame causes the stream state to become indeterminate. A receiver MUST treat the receipt of a PUSH_PROMISE on a stream that is neither "open" nor "half-closed (local)" as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. However, an endpoint that has sent <a href="#RST_STREAM" class="smpl">RST_STREAM</a> on the associated stream MUST handle PUSH_PROMISE frames that might have been created before the <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame is received and processed.</p></div><div id="rfc.section.6.6.p.10"><p>A receiver MUST treat the receipt of a PUSH_PROMISE that promises an illegal stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>) as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. Note that an illegal stream identifier is an identifier for a stream that is not currently in the "idle" state.</p></div><div id="rfc.section.6.6.p.11"><p>The PUSH_PROMISE frame can include padding. Padding fields and flags are identical to those defined for DATA frames (<a href="#DATA" title="DATA">Section&nbsp;6.1</a>).</p></div></div><div id="PING"><h3 id="rfc.section.6.7"><a href="#rfc.section.6.7">6.7</a>&nbsp;<a href="#PING">PING</a></h3><div id="rfc.section.6.7.p.1"><p>The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.</p></div><div id="PINGPayloadFormat"></div><div id="rfc.figure.12"><pre class="inline"> +---------------------------------------------------------------+
 |                                                               |
 |                      Opaque Data (64)                         |
 |                                                               |
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 12: PING Payload Format</p><div id="rfc.section.6.7.p.2"><p>In addition to the frame header, PING frames MUST contain 8 octets of opaque data in the payload. A sender can include any value it chooses and use those octets in any fashion.</p></div><div id="rfc.section.6.7.p.3"><p>Receivers of a PING frame that does not include an ACK flag MUST send a PING frame with the ACK flag set in response, with an identical payload. PING responses SHOULD be given higher priority than any other frame.</p></div><div id="rfc.section.6.7.p.4"><p>The PING frame defines the following flags: </p><dl><dt>ACK (0x1):</dt><dd>When set, bit 0 indicates that this PING frame is a PING response. An endpoint MUST set this flag in PING responses. An endpoint MUST NOT respond to PING frames containing this flag.</dd></dl></div><div id="rfc.section.6.7.p.5"><p>PING frames are not associated with any individual stream. If a PING frame is received with a stream identifier field value other than 0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.7.p.6"><p>Receipt of a PING frame with a length field value other than 8 MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a>.</p></div></div><div id="GOAWAY"><h3 id="rfc.section.6.8"><a href="#rfc.section.6.8">6.8</a>&nbsp;<a href="#GOAWAY">GOAWAY</a></h3><div id="rfc.section.6.8.p.1"><p>The GOAWAY frame (type=0x7) is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.</p></div><div id="rfc.section.6.8.p.2"><p>There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.</p></div><div id="rfc.section.6.8.p.3"><p>Once sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.</p></div><div id="rfc.section.6.8.p.4"><p>If the receiver of the GOAWAY has sent data on streams with a higher stream identifier than what is indicated in the GOAWAY frame, those streams are not or will not be processed. The receiver of the GOAWAY frame can treat the streams as though they had never been created at all, thereby allowing those streams to be retried later on a new connection.</p></div><div id="rfc.section.6.8.p.5"><p>Endpoints SHOULD always send a GOAWAY frame before closing a connection so that the remote peer can know whether a stream has been partially processed or not. For example, if an HTTP client sends a POST at the same time that a server closes a connection, the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate what streams it might have acted on.</p></div><div id="rfc.section.6.8.p.6"><p>An endpoint might choose to close a connection without sending a GOAWAY for misbehaving peers.</p></div><div id="rfc.section.6.8.p.7"><p>A GOAWAY frame might not immediately precede closing of the connection; a receiver of a GOAWAY that has no more use for the connection SHOULD still send a GOAWAY frame before terminating the connection.</p></div><div id="GOAWAYPayloadFormat"></div><div id="rfc.figure.13"><pre class="inline"> +-+-------------------------------------------------------------+
 |R|                  Last-Stream-ID (31)                        |
 +-+-------------------------------------------------------------+
 |                      Error Code (32)                          |
 +---------------------------------------------------------------+
 |                  Additional Debug Data (*)                    |
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 13: GOAWAY Payload Format</p><div id="rfc.section.6.8.p.8"><p>The GOAWAY frame does not define any flags.</p></div><div id="rfc.section.6.8.p.9"><p>The GOAWAY frame applies to the connection, not a specific stream. An endpoint MUST treat a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame with a stream identifier other than 0x0 as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.6.8.p.10"><p>The last stream identifier in the GOAWAY frame contains the highest-numbered stream identifier for which the sender of the GOAWAY frame might have taken some action on or might yet take action on. All streams up to and including the identified stream might have been processed in some way. The last stream identifier can be set to 0 if no streams were processed.</p></div><div class="alert alert-warning"><div id="rfc.section.6.8.p.11"><p><b>Note:</b> In this context, "processed" means that some data from the stream was passed to some higher layer of software that might have taken some action as a result.</p></div></div><div id="rfc.section.6.8.p.12"><p>If a connection terminates without a GOAWAY frame, the last stream identifier is effectively the highest possible stream identifier.</p></div><div id="rfc.section.6.8.p.13"><p>On streams with lower- or equal-numbered identifiers that were not closed completely prior to the connection being closed, reattempting requests, transactions, or any protocol activity is not possible, with the exception of idempotent actions like HTTP GET, PUT, or DELETE. Any protocol activity that uses higher-numbered streams can be safely retried using a new connection.</p></div><div id="rfc.section.6.8.p.14"><p>Activity on streams numbered lower or equal to the last stream identifier might still complete successfully. The sender of a GOAWAY frame might gracefully shut down a connection by sending a GOAWAY frame, maintaining the connection in an "open" state until all in-progress streams complete.</p></div><div id="rfc.section.6.8.p.15"><p>An endpoint MAY send multiple GOAWAY frames if circumstances change. For instance, an endpoint that sends GOAWAY with <a href="#NO_ERROR" class="smpl">NO_ERROR</a> during graceful shutdown could subsequently encounter a condition that requires immediate termination of the connection. The last stream identifier from the last GOAWAY frame received indicates which streams could have been acted upon. Endpoints MUST NOT increase the value they send in the last stream identifier, since the peers might already have retried unprocessed requests on another connection.</p></div><div id="rfc.section.6.8.p.16"><p>A client that is unable to retry requests loses all requests that are in flight when the server closes the connection. This is especially true for intermediaries that might not be serving clients using HTTP/2. A server that is attempting to gracefully shut down a connection SHOULD send an initial GOAWAY frame with the last stream identifier set to 2<sup>31</sup>-1 and a <a href="#NO_ERROR" class="smpl">NO_ERROR</a> code. This signals to the client that a shutdown is imminent and that initiating further requests is prohibited. After allowing time for any in-flight stream creation (at least one round-trip time), the server can send another GOAWAY frame with an updated last stream identifier. This ensures that a connection can be cleanly shut down without losing requests.</p></div><div id="rfc.section.6.8.p.17"><p>After sending a GOAWAY frame, the sender can discard frames for streams initiated by the receiver with identifiers higher than the identified last stream. However, any frames that alter connection state cannot be completely ignored. For instance, <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>, and <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames MUST be minimally processed to ensure the state maintained for header compression is consistent (see <a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>); similarly, DATA frames MUST be counted toward the connection flow-control window. Failure to process these frames can cause flow control or header compression state to become unsynchronized.</p></div><div id="rfc.section.6.8.p.18"><p>The GOAWAY frame also contains a 32-bit error code (<a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a>) that contains the reason for closing the connection.</p></div><div id="rfc.section.6.8.p.19"><p>Endpoints MAY append opaque data to the payload of any GOAWAY frame. Additional debug data is intended for diagnostic purposes only and carries no semantic value. Debug information could contain security- or privacy-sensitive data. Logged or otherwise persistently stored debug data MUST have adequate safeguards to prevent unauthorized access.</p></div></div><div id="WINDOW_UPDATE"><h3 id="rfc.section.6.9"><a href="#rfc.section.6.9">6.9</a>&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a></h3><div id="rfc.section.6.9.p.1"><p>The WINDOW_UPDATE frame (type=0x8) is used to implement flow control; see <a href="#FlowControl" title="Flow Control">Section&nbsp;5.2</a> for an overview.</p></div><div id="rfc.section.6.9.p.2"><p>Flow control operates at two levels: on each individual stream and on the entire connection.</p></div><div id="rfc.section.6.9.p.3"><p>Both types of flow control are hop by hop, that is, only between the two endpoints. Intermediaries do not forward WINDOW_UPDATE frames between dependent connections. However, throttling of data transfer by any receiver can indirectly cause the propagation of flow-control information toward the original sender.</p></div><div id="rfc.section.6.9.p.4"><p>Flow control only applies to frames that are identified as being subject to flow control. Of the frame types defined in this document, this includes only <a href="#DATA" class="smpl">DATA</a> frames. Frames that are exempt from flow control MUST be accepted and processed, unless the receiver is unable to assign resources to handling the frame. A receiver MAY respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) or connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a> if it is unable to accept a frame.</p></div><div id="WINDOW_UPDATEPayloadFormat"></div><div id="rfc.figure.14"><pre class="inline"> +-+-------------------------------------------------------------+
 |R|              Window Size Increment (31)                     |
 +-+-------------------------------------------------------------+
</pre></div><p class="figure">Figure 14: WINDOW_UPDATE Payload Format</p><div id="rfc.section.6.9.p.5"><p>The payload of a WINDOW_UPDATE frame is one reserved bit plus an unsigned 31-bit integer indicating the number of octets that the sender can transmit in addition to the existing flow-control window. The legal range for the increment to the flow-control window is 1 to 2<sup>31</sup>-1 (2,147,483,647) octets.</p></div><div id="rfc.section.6.9.p.6"><p>The WINDOW_UPDATE frame does not define any flags.</p></div><div id="rfc.section.6.9.p.7"><p>The WINDOW_UPDATE frame can be specific to a stream or to the entire connection. In the former case, the frame's stream identifier indicates the affected stream; in the latter, the value "0" indicates that the entire connection is the subject of the frame.</p></div><div id="rfc.section.6.9.p.8"><p>A receiver MUST treat the receipt of a WINDOW_UPDATE frame with an flow-control window increment of 0 as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>; errors on the connection flow-control window MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>).</p></div><div id="rfc.section.6.9.p.9"><p>WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the END_STREAM flag. This means that a receiver could receive a WINDOW_UPDATE frame on a "half-closed (remote)" or "closed" stream. A receiver MUST NOT treat this as an error (see <a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>).</p></div><div id="rfc.section.6.9.p.10"><p>A receiver that receives a flow-controlled frame MUST always account for its contribution against the connection flow-control window, unless the receiver treats this as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>). This is necessary even if the frame is in error. The sender counts the frame toward the flow-control window, but if the receiver does not, the flow-control window at the sender and receiver can become different.</p></div><div id="rfc.section.6.9.p.11"><p>A WINDOW_UPDATE frame with a length other than 4 octets MUST be treated as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FRAME_SIZE_ERROR" class="smpl">FRAME_SIZE_ERROR</a>.</p></div><div><h4 id="rfc.section.6.9.1"><a href="#rfc.section.6.9.1">6.9.1</a>&nbsp;The Flow-Control Window</h4><div id="rfc.section.6.9.1.p.1"><p>Flow control in HTTP/2 is implemented using a window kept by each sender on every stream. The flow-control window is a simple integer value that indicates how many octets of data the sender is permitted to transmit; as such, its size is a measure of the buffering capacity of the receiver.</p></div><div id="rfc.section.6.9.1.p.2"><p>Two flow-control windows are applicable: the stream flow-control window and the connection flow-control window. The sender MUST NOT send a flow-controlled frame with a length that exceeds the space available in either of the flow-control windows advertised by the receiver. Frames with zero length with the END_STREAM flag set (that is, an empty <a href="#DATA" class="smpl">DATA</a> frame) MAY be sent if there is no available space in either flow-control window.</p></div><div id="rfc.section.6.9.1.p.3"><p>For flow-control calculations, the 9-octet frame header is not counted.</p></div><div id="rfc.section.6.9.1.p.4"><p>After sending a flow-controlled frame, the sender reduces the space available in both windows by the length of the transmitted frame.</p></div><div id="rfc.section.6.9.1.p.5"><p>The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up space in flow-control windows. Separate WINDOW_UPDATE frames are sent for the stream- and connection-level flow-control windows.</p></div><div id="rfc.section.6.9.1.p.6"><p>A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the amount specified in the frame.</p></div><div id="rfc.section.6.9.1.p.7"><p>A sender MUST NOT allow a flow-control window to exceed 2<sup>31</sup>-1 octets. If a sender receives a WINDOW_UPDATE that causes a flow-control window to exceed this maximum, it MUST terminate either the stream or the connection, as appropriate. For streams, the sender sends a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> with an error code of <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a>; for the connection, a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame with an error code of <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a> is sent.</p></div><div id="rfc.section.6.9.1.p.8"><p>Flow-controlled frames from the sender and WINDOW_UPDATE frames from the receiver are completely asynchronous with respect to each other. This property allows a receiver to aggressively update the window size kept by the sender to prevent streams from stalling.</p></div></div><div id="InitialWindowSize"><h4 id="rfc.section.6.9.2"><a href="#rfc.section.6.9.2">6.9.2</a>&nbsp;<a href="#InitialWindowSize">Initial Flow-Control Window Size</a></h4><div id="rfc.section.6.9.2.p.1"><p>When an HTTP/2 connection is first established, new streams are created with an initial flow-control window size of 65,535 octets. The connection flow-control window is also 65,535 octets. Both endpoints can adjust the initial window size for new streams by including a value for <a href="#SETTINGS_INITIAL_WINDOW_SIZE" class="smpl">SETTINGS_INITIAL_WINDOW_SIZE</a> in the <a href="#SETTINGS" class="smpl">SETTINGS</a> frame that forms part of the connection preface. The connection flow-control window can only be changed using WINDOW_UPDATE frames.</p></div><div id="rfc.section.6.9.2.p.2"><p>Prior to receiving a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame that sets a value for <a href="#SETTINGS_INITIAL_WINDOW_SIZE" class="smpl">SETTINGS_INITIAL_WINDOW_SIZE</a>, an endpoint can only use the default initial window size when sending flow-controlled frames. Similarly, the connection flow-control window is set to the default initial window size until a WINDOW_UPDATE frame is received.</p></div><div id="rfc.section.6.9.2.p.3"><p>In addition to changing the flow-control window for streams that are not yet active, a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the "open" or "half-closed (remote)" state). When the value of <a href="#SETTINGS_INITIAL_WINDOW_SIZE" class="smpl">SETTINGS_INITIAL_WINDOW_SIZE</a> changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.</p></div><div id="rfc.section.6.9.2.p.4"><p>A change to <a href="#SETTINGS_INITIAL_WINDOW_SIZE" class="smpl">SETTINGS_INITIAL_WINDOW_SIZE</a> can cause the available space in a flow-control window to become negative. A sender MUST track the negative flow-control window and MUST NOT send new flow-controlled frames until it receives WINDOW_UPDATE frames that cause the flow-control window to become positive.</p></div><div id="rfc.section.6.9.2.p.5"><p>For example, if the client sends 60 KB immediately on connection establishment and the server sets the initial window size to be 16 KB, the client will recalculate the available flow-control window to be -44 KB on receipt of the <a href="#SETTINGS" class="smpl">SETTINGS</a> frame. The client retains a negative flow-control window until WINDOW_UPDATE frames restore the window to being positive, after which the client can resume sending.</p></div><div id="rfc.section.6.9.2.p.6"><p>A <a href="#SETTINGS" class="smpl">SETTINGS</a> frame cannot alter the connection flow-control window.</p></div><div id="rfc.section.6.9.2.p.7"><p>An endpoint MUST treat a change to <a href="#SETTINGS_INITIAL_WINDOW_SIZE" class="smpl">SETTINGS_INITIAL_WINDOW_SIZE</a> that causes any flow-control window to exceed the maximum size as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a>.</p></div></div><div><h4 id="rfc.section.6.9.3"><a href="#rfc.section.6.9.3">6.9.3</a>&nbsp;Reducing the Stream Window Size</h4><div id="rfc.section.6.9.3.p.1"><p>A receiver that wishes to use a smaller flow-control window than the current size can send a new <a href="#SETTINGS" class="smpl">SETTINGS</a> frame. However, the receiver MUST be prepared to receive data that exceeds this window size, since the sender might send data that exceeds the lower limit prior to processing the <a href="#SETTINGS" class="smpl">SETTINGS</a> frame.</p></div><div id="rfc.section.6.9.3.p.2"><p>After sending a SETTINGS frame that reduces the initial flow-control window size, a receiver MAY continue to process streams that exceed flow-control limits. Allowing streams to continue does not allow the receiver to immediately reduce the space it reserves for flow-control windows. Progress on these streams can also stall, since <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> frames are needed to allow the sender to resume sending. The receiver MAY instead send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> with an error code of <a href="#FLOW_CONTROL_ERROR" class="smpl">FLOW_CONTROL_ERROR</a> for the affected streams.</p></div></div></div><div id="CONTINUATION"><h3 id="rfc.section.6.10"><a href="#rfc.section.6.10">6.10</a>&nbsp;<a href="#CONTINUATION">CONTINUATION</a></h3><div id="rfc.section.6.10.p.1"><p>The CONTINUATION frame (type=0x9) is used to continue a sequence of header block fragments (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>). Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a>, or CONTINUATION frame without the END_HEADERS flag set.</p></div><div id="CONTINUATIONFramePayload"></div><div id="rfc.figure.15"><pre class="inline"> +---------------------------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 15: CONTINUATION Frame Payload</p><div id="rfc.section.6.10.p.2"><p>The CONTINUATION frame payload contains a header block fragment (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>).</p></div><div id="rfc.section.6.10.p.3"><p>The CONTINUATION frame defines the following flag: </p><dl><dt>END_HEADERS (0x4):</dt><dd><p>When set, bit 2 indicates that this frame ends a header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>).</p><p>If the END_HEADERS bit is not set, this frame MUST be followed by another CONTINUATION frame. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></dd></dl></div><div id="rfc.section.6.10.p.4"><p>The CONTINUATION frame changes the connection state as defined in <a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>.</p></div><div id="rfc.section.6.10.p.5"><p>CONTINUATION frames MUST be associated with a stream. If a CONTINUATION frame is received whose stream identifier field is 0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type PROTOCOL_ERROR.</p></div><div id="rfc.section.6.10.p.6"><p>A CONTINUATION frame MUST be preceded by a <a href="#HEADERS" class="smpl">HEADERS</a>, <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> or CONTINUATION frame without the END_HEADERS flag set. A recipient that observes violation of this rule MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div></div></div><div id="ErrorCodes"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#ErrorCodes">Error Codes</a></h2><div id="rfc.section.7.p.1"><p>Error codes are 32-bit fields that are used in <a href="#RST_STREAM" class="smpl">RST_STREAM</a> and <a href="#GOAWAY" class="smpl">GOAWAY</a> frames to convey the reasons for the stream or connection error.</p></div><div id="rfc.section.7.p.2"><p>Error codes share a common code space. Some error codes apply only to either streams or the entire connection and have no defined semantics in the other context.</p></div><div id="rfc.section.7.p.3"><p>The following error codes are defined: </p><dl><dt id="NO_ERROR">NO_ERROR (0x0):</dt><dd>The associated condition is not a result of an error. For example, a <a href="#GOAWAY" class="smpl">GOAWAY</a> might include this code to indicate graceful shutdown of a connection.</dd><dt id="PROTOCOL_ERROR">PROTOCOL_ERROR (0x1):</dt><dd>The endpoint detected an unspecific protocol error. This error is for use when a more specific error code is not available.</dd><dt id="INTERNAL_ERROR">INTERNAL_ERROR (0x2):</dt><dd>The endpoint encountered an unexpected internal error.</dd><dt id="FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR (0x3):</dt><dd>The endpoint detected that its peer violated the flow-control protocol.</dd><dt id="SETTINGS_TIMEOUT">SETTINGS_TIMEOUT (0x4):</dt><dd>The endpoint sent a <a href="#SETTINGS" class="smpl">SETTINGS</a> frame but did not receive a response in a timely manner. See <a href="#SettingsSync" title="Settings Synchronization">Section&nbsp;6.5.3</a> ("Settings Synchronization").</dd><dt id="STREAM_CLOSED">STREAM_CLOSED (0x5):</dt><dd>The endpoint received a frame after a stream was half-closed.</dd><dt id="FRAME_SIZE_ERROR">FRAME_SIZE_ERROR (0x6):</dt><dd>The endpoint received a frame with an invalid size.</dd><dt id="REFUSED_STREAM">REFUSED_STREAM (0x7):</dt><dd>The endpoint refused the stream prior to performing any application processing (see <a href="#Reliability" title="Request Reliability Mechanisms in HTTP/2">Section&nbsp;8.1.4</a> for details).</dd><dt id="CANCEL">CANCEL (0x8):</dt><dd>Used by the endpoint to indicate that the stream is no longer needed.</dd><dt id="COMPRESSION_ERROR">COMPRESSION_ERROR (0x9):</dt><dd>The endpoint is unable to maintain the header compression context for the connection.</dd><dt id="CONNECT_ERROR">CONNECT_ERROR (0xa):</dt><dd>The connection established in response to a CONNECT request (<a href="#CONNECT" title="The CONNECT Method">Section&nbsp;8.3</a>) was reset or abnormally closed.</dd><dt id="ENHANCE_YOUR_CALM">ENHANCE_YOUR_CALM (0xb):</dt><dd>The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.</dd><dt id="INADEQUATE_SECURITY">INADEQUATE_SECURITY (0xc):</dt><dd>The underlying transport has properties that do not meet minimum security requirements (see <a href="#TLSUsage" title="Use of TLS Features">Section&nbsp;9.2</a>).</dd><dt id="HTTP_1_1_REQUIRED">HTTP_1_1_REQUIRED (0xd):</dt><dd>The endpoint requires that HTTP/1.1 be used instead of HTTP/2.</dd></dl></div><div id="rfc.section.7.p.4"><p>Unknown or unsupported error codes MUST NOT trigger any special behavior. These MAY be treated by an implementation as being equivalent to <a href="#INTERNAL_ERROR" class="smpl">INTERNAL_ERROR</a>.</p></div></div><div id="HTTPLayer"><h2 id="rfc.section.8"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#HTTPLayer">HTTP Message Exchanges</a></h2><div id="rfc.section.8.p.1"><p>HTTP/2 is intended to be as compatible as possible with current uses of HTTP. This means that, from the application perspective, the features of the protocol are largely unchanged. To achieve this, all request and response semantics are preserved, although the syntax of conveying those semantics has changed.</p></div><div id="rfc.section.8.p.2"><p>Thus, the specification and requirements of HTTP/1.1 Semantics and Content <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Conditional Requests <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, Range Requests <a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a>, Caching <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, and Authentication <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a> are applicable to HTTP/2. Selected portions of HTTP/1.1 Message Syntax and Routing <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, such as the HTTP and HTTPS URI schemes, are also applicable in HTTP/2, but the expression of those semantics for this protocol are defined in the sections below.</p></div><div id="HttpSequence"><h3 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1</a>&nbsp;<a href="#HttpSequence">HTTP Request/Response Exchange</a></h3><div id="rfc.section.8.1.p.1"><p>A client sends an HTTP request on a new stream, using a previously unused stream identifier (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>). A server sends an HTTP response on the same stream as the request.</p></div><div id="rfc.section.8.1.p.2"><p>An HTTP message (request or response) consists of: </p><ol><li>for a response only, zero or more <a href="#HEADERS" class="smpl">HEADERS</a> frames (each followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames) containing the message headers of informational (1xx) HTTP responses (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.fields" title="Header Fields">Section 3.2</a> and <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#status.1xx" title="Informational 1xx">Section 6.2</a>),</li><li>one <a href="#HEADERS" class="smpl">HEADERS</a> frame (followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames) containing the message headers (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.fields" title="Header Fields">Section 3.2</a>),</li><li>zero or more <a href="#DATA" class="smpl">DATA</a> frames containing the payload body (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#message.body" title="Message Body">Section 3.3</a>), and</li><li>optionally, one <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames containing the trailer-part, if present (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#chunked.trailer.part" title="Chunked Trailer Part">Section 4.1.2</a>).</li></ol><p> The last frame in the sequence bears an END_STREAM flag, noting that a <a href="#HEADERS" class="smpl">HEADERS</a> frame bearing the END_STREAM flag can be followed by <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames that carry any remaining portions of the header block.</p></div><div id="rfc.section.8.1.p.3"><p>Other frames (from any stream) MUST NOT occur between the <a href="#HEADERS" class="smpl">HEADERS</a> frame and any <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames that might follow.</p></div><div id="rfc.section.8.1.p.4"><p>HTTP/2 uses DATA frames to carry message payloads. The <tt>chunked</tt> transfer encoding defined in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#chunked.encoding" title="Chunked Transfer Coding">Section 4.1</a> of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> MUST NOT be used in HTTP/2.</p></div><div id="rfc.section.8.1.p.5"><p>Trailing header fields are carried in a header block that also terminates the stream. Such a header block is a sequence starting with a <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames, where the <a href="#HEADERS" class="smpl">HEADERS</a> frame bears an END_STREAM flag. Header blocks after the first that do not terminate the stream are not part of an HTTP request or response.</p></div><div id="rfc.section.8.1.p.6"><p>A <a href="#HEADERS" class="smpl">HEADERS</a> frame (and associated <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames) can only appear at the start or end of a stream. An endpoint that receives a <a href="#HEADERS" class="smpl">HEADERS</a> frame without the END_STREAM flag set after receiving a final (non-informational) status code MUST treat the corresponding request or response as malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>).</p></div><div id="rfc.section.8.1.p.7"><p>An HTTP request/response exchange fully consumes a single stream. A request starts with the <a href="#HEADERS" class="smpl">HEADERS</a> frame that puts the stream into an "open" state. The request ends with a frame bearing END_STREAM, which causes the stream to become "half-closed (local)" for the client and "half-closed (remote)" for the server. A response starts with a <a href="#HEADERS" class="smpl">HEADERS</a> frame and ends with a frame bearing END_STREAM, which places the stream in the "closed" state.</p></div><div id="rfc.section.8.1.p.8"><p>An HTTP response is complete after the server sends — or the client receives — a frame with the END_STREAM flag set (including any <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames needed to complete a header block). A server can send a complete response prior to the client sending an entire request if the response does not depend on any portion of the request that has not been sent and received. When this is true, a server MAY request that the client abort transmission of a request without error by sending a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> with an error code of <a href="#NO_ERROR" class="smpl">NO_ERROR</a> after sending a complete response (i.e., a frame with the END_STREAM flag). Clients MUST NOT discard responses as a result of receiving such a <a href="#RST_STREAM" class="smpl">RST_STREAM</a>, though clients can always discard responses at their discretion for other reasons.</p></div><div id="informational-responses"><h4 id="rfc.section.8.1.1"><a href="#rfc.section.8.1.1">8.1.1</a>&nbsp;<a href="#informational-responses">Upgrading from HTTP/2</a></h4><div id="rfc.section.8.1.1.p.1"><p>HTTP/2 removes support for the 101 (Switching Protocols) informational status code (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#status.101" title="101 Switching Protocols">Section 6.2.2</a>).</p></div><div id="rfc.section.8.1.1.p.2"><p>The semantics of 101 (Switching Protocols) aren't applicable to a multiplexed protocol. Alternative protocols are able to use the same mechanisms that HTTP/2 uses to negotiate their use (see <a href="#starting" title="Starting HTTP/2">Section&nbsp;3</a>).</p></div></div><div id="HttpHeaders"><h4 id="rfc.section.8.1.2"><a href="#rfc.section.8.1.2">8.1.2</a>&nbsp;<a href="#HttpHeaders">HTTP Header Fields</a></h4><div id="rfc.section.8.1.2.p.1"><p>HTTP header fields carry information as a series of key-value pairs. For a listing of registered HTTP headers, see the "Message Header Field" registry maintained at &lt;<a href="https://www.iana.org/assignments/message-headers">https://www.iana.org/assignments/message-headers</a>&gt;.</p></div><div id="rfc.section.8.1.2.p.2"><p>Just as in HTTP/1.x, header field names are strings of ASCII characters that are compared in a case-insensitive fashion. However, header field names MUST be converted to lowercase prior to their encoding in HTTP/2. A request or response containing uppercase header field names MUST be treated as malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>).</p></div><div id="PseudoHeaderFields"><h5 id="rfc.section.8.1.2.1"><a href="#rfc.section.8.1.2.1">8.1.2.1</a>&nbsp;<a href="#PseudoHeaderFields">Pseudo-Header Fields</a></h5><div id="rfc.section.8.1.2.1.p.1"><p>While HTTP/1.x used the message start-line (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#start.line" title="Start Line">Section 3.1</a>) to convey the target URI, the method of the request, and the status code for the response, HTTP/2 uses special pseudo-header fields beginning with ':' character (ASCII 0x3a) for this purpose.</p></div><div id="rfc.section.8.1.2.1.p.2"><p>Pseudo-header fields are not HTTP header fields. Endpoints MUST NOT generate pseudo-header fields other than those defined in this document.</p></div><div id="rfc.section.8.1.2.1.p.3"><p>Pseudo-header fields are only valid in the context in which they are defined. Pseudo-header fields defined for requests MUST NOT appear in responses; pseudo-header fields defined for responses MUST NOT appear in requests. Pseudo-header fields MUST NOT appear in trailers. Endpoints MUST treat a request or response that contains undefined or invalid pseudo-header fields as malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>).</p></div><div id="rfc.section.8.1.2.1.p.4"><p>All pseudo-header fields MUST appear in the header block before regular header fields. Any request or response that contains a pseudo-header field that appears in a header block after a regular header field MUST be treated as malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>).</p></div></div><div><h5 id="rfc.section.8.1.2.2"><a href="#rfc.section.8.1.2.2">8.1.2.2</a>&nbsp;Connection-Specific Header Fields</h5><div id="rfc.section.8.1.2.2.p.1"><p>HTTP/2 does not use the <tt>Connection</tt> header field to indicate connection-specific header fields; in this protocol, connection-specific metadata is conveyed by other means. An endpoint MUST NOT generate an HTTP/2 message containing connection-specific header fields; any message containing connection-specific header fields MUST be treated as malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>).</p></div><div id="rfc.section.8.1.2.2.p.2"><p>The only exception to this is the TE header field, which MAY be present in an HTTP/2 request; when it is, it MUST NOT contain any value other than "trailers".</p></div><div id="rfc.section.8.1.2.2.p.3"><p>This means that an intermediary transforming an HTTP/1.x message to HTTP/2 will need to remove any header fields nominated by the Connection header field, along with the Connection header field itself. Such intermediaries SHOULD also remove other connection-specific header fields, such as Keep-Alive, Proxy-Connection, Transfer-Encoding, and Upgrade, even if they are not nominated by the Connection header field.</p></div><div class="alert alert-warning"><div id="rfc.section.8.1.2.2.p.4"><p><b>Note:</b> HTTP/2 purposefully does not support upgrade to another protocol. The handshake methods described in <a href="#starting" title="Starting HTTP/2">Section&nbsp;3</a> are believed sufficient to negotiate the use of alternative protocols.</p></div></div></div><div id="HttpRequest"><h5 id="rfc.section.8.1.2.3"><a href="#rfc.section.8.1.2.3">8.1.2.3</a>&nbsp;<a href="#HttpRequest">Request Pseudo-Header Fields</a></h5><div id="rfc.section.8.1.2.3.p.1"><p>The following pseudo-header fields are defined for HTTP/2 requests: </p><ul><li><p>The <tt>:method</tt> pseudo-header field includes the HTTP method (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#methods" title="Request Methods">Section 4</a>).</p></li><li><p>The <tt>:scheme</tt> pseudo-header field includes the scheme portion of the target URI (<a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="https://tools.ietf.org/html/rfc3986#section-3.1">Section 3.1</a>).</p><p><tt>:scheme</tt> is not restricted to <tt>http</tt> and <tt>https</tt> schemed URIs. A proxy or gateway can translate requests for non-HTTP schemes, enabling the use of HTTP to interact with non-HTTP services.</p></li><li><p>The <tt>:authority</tt> pseudo-header field includes the authority portion of the target URI (<a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="https://tools.ietf.org/html/rfc3986#section-3.2">Section 3.2</a>). The authority MUST NOT include the deprecated <tt>userinfo</tt> subcomponent for <tt>http</tt> or <tt>https</tt> schemed URIs.</p><p>To ensure that the HTTP/1.1 request line can be reproduced accurately, this pseudo-header field MUST be omitted when translating from an HTTP/1.1 request that has a request target in origin or asterisk form (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#request-target" title="Request Target">Section 5.3</a>). Clients that generate HTTP/2 requests directly SHOULD use the <tt>:authority</tt> pseudo-header field instead of the <tt>Host</tt> header field. An intermediary that converts an HTTP/2 request to HTTP/1.1 MUST create a <tt>Host</tt> header field if one is not present in a request by copying the value of the <tt>:authority</tt> pseudo-header field.</p></li><li><p>The <tt>:path</tt> pseudo-header field includes the path and query parts of the target URI (the <tt>path-absolute</tt> production and optionally a '?' character followed by the <tt>query</tt> production (see Sections <a href="https://tools.ietf.org/html/rfc3986#section-3.3">3.3</a> and <a href="https://tools.ietf.org/html/rfc3986#section-3.4">3.4</a> of <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>). A request in asterisk form includes the value '*' for the <tt>:path</tt> pseudo-header field.</p><p>This pseudo-header field MUST NOT be empty for <tt>http</tt> or <tt>https</tt> URIs; <tt>http</tt> or <tt>https</tt> URIs that do not contain a path component MUST include a value of '/'. The exception to this rule is an OPTIONS request for an <tt>http</tt> or <tt>https</tt> URI that does not include a path component; these MUST include a <tt>:path</tt> pseudo-header field with a value of '*' (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#asterisk-form" title="asterisk-form">Section 5.3.4</a>).</p></li></ul></div><div id="rfc.section.8.1.2.3.p.2"><p>All HTTP/2 requests MUST include exactly one valid value for the <tt>:method</tt>, <tt>:scheme</tt>, and <tt>:path</tt> pseudo-header fields, unless it is a CONNECT request (<a href="#CONNECT" title="The CONNECT Method">Section&nbsp;8.3</a>). An HTTP request that omits mandatory pseudo-header fields is malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>).</p></div><div id="rfc.section.8.1.2.3.p.3"><p>HTTP/2 does not define a way to carry the version identifier that is included in the HTTP/1.1 request line.</p></div></div><div id="HttpResponse"><h5 id="rfc.section.8.1.2.4"><a href="#rfc.section.8.1.2.4">8.1.2.4</a>&nbsp;<a href="#HttpResponse">Response Pseudo-Header Fields</a></h5><div id="rfc.section.8.1.2.4.p.1"><p>For HTTP/2 responses, a single <tt>:status</tt> pseudo-header field is defined that carries the HTTP status code field (see <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#status.codes" title="Response Status Codes">Section 6</a>). This pseudo-header field MUST be included in all responses; otherwise, the response is malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>).</p></div><div id="rfc.section.8.1.2.4.p.2"><p>HTTP/2 does not define a way to carry the version or reason phrase that is included in an HTTP/1.1 status line.</p></div></div><div id="CompressCookie"><h5 id="rfc.section.8.1.2.5"><a href="#rfc.section.8.1.2.5">8.1.2.5</a>&nbsp;<a href="#CompressCookie">Compressing the Cookie Header Field</a></h5><div id="rfc.section.8.1.2.5.p.1"><p>The <a href="#COOKIE">Cookie header field</a> <cite title="HTTP State Management Mechanism">[COOKIE]</cite> uses a semi-colon (";") to delimit cookie-pairs (or "crumbs"). This header field doesn't follow the list construction rules in HTTP (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#field.order" title="Field Order">Section 3.2.2</a>), which prevents cookie-pairs from being separated into different name-value pairs. This can significantly reduce compression efficiency as individual cookie-pairs are updated.</p></div><div id="rfc.section.8.1.2.5.p.2"><p>To allow for better compression efficiency, the Cookie header field MAY be split into separate header fields, each with one or more cookie-pairs. If there are multiple Cookie header fields after decompression, these MUST be concatenated into a single octet string using the two-octet delimiter of 0x3B, 0x20 (the ASCII string "; ") before being passed into a non-HTTP/2 context, such as an HTTP/1.1 connection, or a generic HTTP server application.</p></div><div id="rfc.figure.u.6"><p>Therefore, the following two lists of Cookie header fields are semantically equivalent.</p><pre class="inline">  cookie: a=b; c=d; e=f

  cookie: a=b
  cookie: c=d
  cookie: e=f
</pre></div></div><div id="malformed"><h5 id="rfc.section.8.1.2.6"><a href="#rfc.section.8.1.2.6">8.1.2.6</a>&nbsp;<a href="#malformed">Malformed Requests and Responses</a></h5><div id="rfc.section.8.1.2.6.p.1"><p>A malformed request or response is one that is an otherwise valid sequence of HTTP/2 frames but is invalid due to the presence of extraneous frames, prohibited header fields, the absence of mandatory header fields, or the inclusion of uppercase header field names.</p></div><div id="rfc.section.8.1.2.6.p.2"><p>A request or response that includes a payload body can include a <tt>content-length</tt> header field. A request or response is also malformed if the value of a <tt>content-length</tt> header field does not equal the sum of the <a href="#DATA" class="smpl">DATA</a> frame payload lengths that form the body. A response that is defined to have no payload, as described in <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.content-length" title="Content-Length">Section 3.3.2</a>, can have a non-zero <tt>content-length</tt> header field, even though no content is included in <a href="#DATA" class="smpl">DATA</a> frames.</p></div><div id="rfc.section.8.1.2.6.p.3"><p>Intermediaries that process HTTP requests or responses (i.e., any intermediary not acting as a tunnel) MUST NOT forward a malformed request or response. Malformed requests or responses that are detected MUST be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.8.1.2.6.p.4"><p>For malformed requests, a server MAY send an HTTP response prior to closing or resetting the stream. Clients MUST NOT accept a malformed response. Note that these requirements are intended to protect against several types of common attacks against HTTP; they are deliberately strict because being permissive can expose implementations to these vulnerabilities.</p></div></div></div><div><h4 id="rfc.section.8.1.3"><a href="#rfc.section.8.1.3">8.1.3</a>&nbsp;Examples</h4><div id="rfc.section.8.1.3.p.1"><p>This section shows HTTP/1.1 requests and responses, with illustrations of equivalent HTTP/2 requests and responses.</p></div><div id="rfc.section.8.1.3.p.2"><p>An HTTP GET request includes request header fields and no payload body and is therefore transmitted as a single <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames containing the serialized block of request header fields. The <a href="#HEADERS" class="smpl">HEADERS</a> frame in the following has both the END_HEADERS and END_STREAM flags set; no <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames are sent.</p></div><div id="rfc.figure.u.7"><pre class="inline">  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==&gt;     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg
</pre></div><div id="rfc.section.8.1.3.p.3"><p>Similarly, a response that includes only response header fields is transmitted as a <a href="#HEADERS" class="smpl">HEADERS</a> frame (again, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames) containing the serialized block of response header fields.</p></div><div id="rfc.figure.u.8"><pre class="inline">  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==&gt;     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag = "xyzzy"
                                       expires = Thu, 23 Jan ...
</pre></div><div id="rfc.section.8.1.3.p.4" class="avoidbreakafter"><p>An HTTP POST request that includes request header fields and payload data is transmitted as one <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames containing the request header fields, followed by one or more <a href="#DATA" class="smpl">DATA</a> frames, with the last <a href="#CONTINUATION" class="smpl">CONTINUATION</a> (or <a href="#HEADERS" class="smpl">HEADERS</a>) frame having the END_HEADERS flag set and the final <a href="#DATA" class="smpl">DATA</a> frame having the END_STREAM flag set:</p></div><div id="rfc.figure.u.9"><pre class="inline">  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==&gt;     - END_STREAM
  Content-Type: image/jpeg           - END_HEADERS
  Content-Length: 123                  :method = POST
                                       :path = /resource
  {binary data}                        :scheme = https

                                   CONTINUATION
                                     + END_HEADERS
                                       content-type = image/jpeg
                                       host = example.org
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
</pre><p>Note that data contributing to any given header field could be spread between header block fragments. The allocation of header fields to frames in this example is illustrative only.</p></div><div id="rfc.section.8.1.3.p.5" class="avoidbreakafter"><p>A response that includes header fields and payload data is transmitted as a <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames, followed by one or more <a href="#DATA" class="smpl">DATA</a> frames, with the last <a href="#DATA" class="smpl">DATA</a> frame in the sequence having the END_STREAM flag set:</p></div><div id="rfc.figure.u.10"><pre class="inline">  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==&gt;     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
</pre></div><div id="rfc.section.8.1.3.p.6"><p>An informational response using a 1xx status code other than 101 is transmitted as a <a href="#HEADERS" class="smpl">HEADERS</a> frame, followed by zero or more <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames.</p></div><div id="rfc.section.8.1.3.p.7"><p>Trailing header fields are sent as a header block after both the request or response header block and all the <a href="#DATA" class="smpl">DATA</a> frames have been sent. The <a href="#HEADERS" class="smpl">HEADERS</a> frame starting the trailers header block has the END_STREAM flag set.</p></div><div id="rfc.figure.u.11"><p>The following example includes both a 100 (Continue) status code, which is sent in response to a request containing a "100-continue" token in the Expect header field, and trailing header fields:</p><pre class="inline">  HTTP/1.1 100 Continue            HEADERS
  Extension-Field: bar       ==&gt;     - END_STREAM
                                     + END_HEADERS
                                       :status = 100
                                       extension-field = bar

  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==&gt;     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status = 200
                                       content-length = 123
  123                                  content-type = image/jpeg
  {binary data}                        trailer = Foo
  0
  Foo: bar                         DATA
                                     - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo = bar
</pre></div></div><div id="Reliability"><h4 id="rfc.section.8.1.4"><a href="#rfc.section.8.1.4">8.1.4</a>&nbsp;<a href="#Reliability">Request Reliability Mechanisms in HTTP/2</a></h4><div id="rfc.section.8.1.4.p.1"><p>In HTTP/1.1, an HTTP client is unable to retry a non-idempotent request when an error occurs because there is no means to determine the nature of the error. It is possible that some server processing occurred prior to the error, which could result in undesirable effects if the request were reattempted.</p></div><div id="rfc.section.8.1.4.p.2"><p>HTTP/2 provides two mechanisms for providing a guarantee to a client that a request has not been processed: </p><ul><li>The <a href="#GOAWAY" class="smpl">GOAWAY</a> frame indicates the highest stream number that might have been processed. Requests on streams with higher numbers are therefore guaranteed to be safe to retry.</li><li>The <a href="#REFUSED_STREAM" class="smpl">REFUSED_STREAM</a> error code can be included in a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame to indicate that the stream is being closed prior to any processing having occurred. Any request that was sent on the reset stream can be safely retried.</li></ul></div><div id="rfc.section.8.1.4.p.3"><p>Requests that have not been processed have not failed; clients MAY automatically retry them, even those with non-idempotent methods.</p></div><div id="rfc.section.8.1.4.p.4"><p>A server MUST NOT indicate that a stream has not been processed unless it can guarantee that fact. If frames that are on a stream are passed to the application layer for any stream, then <a href="#REFUSED_STREAM" class="smpl">REFUSED_STREAM</a> MUST NOT be used for that stream, and a <a href="#GOAWAY" class="smpl">GOAWAY</a> frame MUST include a stream identifier that is greater than or equal to the given stream identifier.</p></div><div id="rfc.section.8.1.4.p.5"><p>In addition to these mechanisms, the <a href="#PING" class="smpl">PING</a> frame provides a way for a client to easily test a connection. Connections that remain idle can become broken as some middleboxes (for instance, network address translators or load balancers) silently discard connection bindings. The <a href="#PING" class="smpl">PING</a> frame allows a client to safely test whether a connection is still active without sending a request.</p></div></div></div><div id="PushResources"><h3 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2</a>&nbsp;<a href="#PushResources">Server Push</a></h3><div id="rfc.section.8.2.p.1"><p>HTTP/2 allows a server to pre-emptively send (or "push") responses (along with corresponding "promised" requests) to a client in association with a previous client-initiated request. This can be useful when the server knows the client will need to have those responses available in order to fully process the response to the original request.</p></div><div id="rfc.section.8.2.p.2"><p>A client can request that server push be disabled, though this is negotiated for each hop independently. The <a href="#SETTINGS_ENABLE_PUSH" class="smpl">SETTINGS_ENABLE_PUSH</a> setting can be set to 0 to indicate that server push is disabled.</p></div><div id="rfc.section.8.2.p.3"><p>Promised requests MUST be cacheable (see <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#cacheable.methods" title="Cacheable Methods">Section 4.2.3</a>), MUST be safe (see <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#safe.methods" title="Safe Methods">Section 4.2.1</a>), and MUST NOT include a request body. Clients that receive a promised request that is not cacheable, that is not known to be safe, or that indicates the presence of a request body MUST reset the promised stream with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. Note this could result in the promised stream being reset if the client does not recognize a newly defined method as being safe.</p></div><div id="rfc.section.8.2.p.4"><p>Pushed responses that are cacheable (see <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7234.html#response.cacheability" title="Storing Responses in Caches">Section 3</a>) can be stored by the client, if it implements an HTTP cache. Pushed responses are considered successfully validated on the origin server (e.g., if the "no-cache" cache response directive is present (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7234.html#cache-response-directive" title="Response Cache-Control Directives">Section 5.2.2</a>)) while the stream identified by the promised stream ID is still open.</p></div><div id="rfc.section.8.2.p.5"><p>Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY be made available to the application separately.</p></div><div id="rfc.section.8.2.p.6"><p>The server MUST include a value in the <tt>:authority</tt> pseudo-header field for which the server is authoritative (see <a href="#authority" title="Server Authority">Section&nbsp;10.1</a>). A client MUST treat a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> for which the server is not authoritative as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.8.2.p.7"><p>An intermediary can receive pushes from the server and choose not to forward them on to the client. In other words, how to make use of the pushed information is up to that intermediary. Equally, the intermediary might choose to make additional pushes to the client, without any action taken by the server.</p></div><div id="rfc.section.8.2.p.8"><p>A client cannot push. Thus, servers MUST treat the receipt of a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. Clients MUST reject any attempt to change the <a href="#SETTINGS_ENABLE_PUSH" class="smpl">SETTINGS_ENABLE_PUSH</a> setting to a value other than 0 by treating the message as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="PushRequests"><h4 id="rfc.section.8.2.1"><a href="#rfc.section.8.2.1">8.2.1</a>&nbsp;<a href="#PushRequests">Push Requests</a></h4><div id="rfc.section.8.2.1.p.1"><p>Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame.</p></div><div id="rfc.section.8.2.1.p.2"><p>The <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame includes a header block that contains a complete set of request header fields that the server attributes to the request. It is not possible to push a response to a request that includes a request body.</p></div><div id="rfc.section.8.2.1.p.3"><p>Pushed responses are always associated with an explicit request from the client. The <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames sent by the server are sent on that explicit request's stream. The <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame also includes a promised stream identifier, chosen from the stream identifiers available to the server (see <a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>).</p></div><div id="rfc.section.8.2.1.p.4"><p>The header fields in <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> and any subsequent <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames MUST be a valid and complete set of request header fields (<a href="#HttpRequest" title="Request Pseudo-Header Fields">Section&nbsp;8.1.2.3</a>). The server MUST include a method in the <tt>:method</tt> pseudo-header field that is safe and cacheable. If a client receives a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> that does not include a complete and valid set of header fields or the <tt>:method</tt> pseudo-header field identifies a method that is not safe, it MUST respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>.</p></div><div id="rfc.section.8.2.1.p.5"><p>The server SHOULD send <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section&nbsp;6.6</a>) frames prior to sending any frames that reference the promised responses. This avoids a race where clients issue requests prior to receiving any <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames.</p></div><div id="rfc.section.8.2.1.p.6"><p>For example, if the server receives a request for a document containing embedded links to multiple image files and the server chooses to push those additional images to the client, sending <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames before the <a href="#DATA" class="smpl">DATA</a> frames that contain the image links ensures that the client is able to see that a resource will be pushed before discovering embedded links. Similarly, if the server pushes responses referenced by the header block (for instance, in Link header fields), sending a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> before sending the header block ensures that clients do not request those resources.</p></div><div id="rfc.section.8.2.1.p.7"><p><a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames MUST NOT be sent by the client.</p></div><div id="rfc.section.8.2.1.p.8"><p><a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames can be sent by the server in response to any client-initiated stream, but the stream MUST be in either the "open" or "half-closed (remote)" state with respect to the server. <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames are interspersed with the frames that comprise a response, though they cannot be interspersed with <a href="#HEADERS" class="smpl">HEADERS</a> and <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frames that comprise a single header block.</p></div><div id="rfc.section.8.2.1.p.9"><p>Sending a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame creates a new stream and puts the stream into the “reserved (local)” state for the server and the “reserved (remote)” state for the client.</p></div></div><div id="PushResponses"><h4 id="rfc.section.8.2.2"><a href="#rfc.section.8.2.2">8.2.2</a>&nbsp;<a href="#PushResponses">Push Responses</a></h4><div id="rfc.section.8.2.2.p.1"><p>After sending the <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame, the server can begin delivering the pushed response as a response (<a href="#HttpResponse" title="Response Pseudo-Header Fields">Section&nbsp;8.1.2.4</a>) on a server-initiated stream that uses the promised stream identifier. The server uses this stream to transmit an HTTP response, using the same sequence of frames as defined in <a href="#HttpSequence" title="HTTP Request/Response Exchange">Section&nbsp;8.1</a>. This stream becomes "half-closed" to the client (<a href="#StreamStates" title="Stream States">Section&nbsp;5.1</a>) after the initial <a href="#HEADERS" class="smpl">HEADERS</a> frame is sent.</p></div><div id="rfc.section.8.2.2.p.2"><p>Once a client receives a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame and chooses to accept the pushed response, the client SHOULD NOT issue any requests for the promised response until after the promised stream has closed.</p></div><div id="rfc.section.8.2.2.p.3"><p>If the client determines, for any reason, that it does not wish to receive the pushed response from the server or if the server takes too long to begin sending the promised response, the client can send a <a href="#RST_STREAM" class="smpl">RST_STREAM</a> frame, using either the <a href="#CANCEL" class="smpl">CANCEL</a> or <a href="#REFUSED_STREAM" class="smpl">REFUSED_STREAM</a> code and referencing the pushed stream's identifier.</p></div><div id="rfc.section.8.2.2.p.4"><p>A client can use the <a href="#SETTINGS_MAX_CONCURRENT_STREAMS" class="smpl">SETTINGS_MAX_CONCURRENT_STREAMS</a> setting to limit the number of responses that can be concurrently pushed by a server. Advertising a <a href="#SETTINGS_MAX_CONCURRENT_STREAMS" class="smpl">SETTINGS_MAX_CONCURRENT_STREAMS</a> value of zero disables server push by preventing the server from creating the necessary streams. This does not prohibit a server from sending <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames; clients need to reset any promised streams that are not wanted.</p></div><div id="rfc.section.8.2.2.p.5"><p>Clients receiving a pushed response MUST validate that either the server is authoritative (see <a href="#authority" title="Server Authority">Section&nbsp;10.1</a>) or the proxy that provided the pushed response is configured for the corresponding request. For example, a server that offers a certificate for only the <tt>example.com</tt> DNS-ID or Common Name is not permitted to push a response for <tt>https://www.example.org/doc</tt>.</p></div><div id="rfc.section.8.2.2.p.6"><p>The response for a <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> stream begins with a <a href="#HEADERS" class="smpl">HEADERS</a> frame, which immediately puts the stream into the "half-closed (remote)" state for the server and "half-closed (local)" state for the client, and ends with a frame bearing END_STREAM, which places the stream in the "closed" state.</p></div><div class="alert alert-warning"><div id="rfc.section.8.2.2.p.7"><p><b>Note:</b> The client never sends a frame with the END_STREAM flag for a server push.</p></div></div></div></div><div id="CONNECT"><h3 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3</a>&nbsp;<a href="#CONNECT">The CONNECT Method</a></h3><div id="rfc.section.8.3.p.1"><p>In HTTP/1.x, the pseudo-method CONNECT (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#CONNECT" title="CONNECT">Section 4.3.6</a>) is used to convert an HTTP connection into a tunnel to a remote host. CONNECT is primarily used with HTTP proxies to establish a TLS session with an origin server for the purposes of interacting with <tt>https</tt> resources.</p></div><div id="rfc.section.8.3.p.2"><p>In HTTP/2, the CONNECT method is used to establish a tunnel over a single HTTP/2 stream to a remote host for similar purposes. The HTTP header field mapping works as defined in <a href="#HttpRequest" title="Request Pseudo-Header Fields">Section&nbsp;8.1.2.3</a> ("<a href="#HttpRequest" title="Request Pseudo-Header Fields">Request Pseudo-Header Fields</a>"), with a few differences. Specifically: </p><ul><li>The <tt>:method</tt> pseudo-header field is set to <tt>CONNECT</tt>.</li><li>The <tt>:scheme</tt> and <tt>:path</tt> pseudo-header fields MUST be omitted.</li><li>The <tt>:authority</tt> pseudo-header field contains the host and port to connect to (equivalent to the authority-form of the request-target of CONNECT requests (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#request-target" title="Request Target">Section 5.3</a>)).</li></ul></div><div id="rfc.section.8.3.p.3"><p>A CONNECT request that does not conform to these restrictions is malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>).</p></div><div id="rfc.section.8.3.p.4"><p>A proxy that supports CONNECT establishes a <a href="#TCP">TCP connection</a> <cite title="Transmission Control Protocol">[TCP]</cite> to the server identified in the <tt>:authority</tt> pseudo-header field. Once this connection is successfully established, the proxy sends a <a href="#HEADERS" class="smpl">HEADERS</a> frame containing a 2xx series status code to the client, as defined in <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#CONNECT" title="CONNECT">Section 4.3.6</a>.</p></div><div id="rfc.section.8.3.p.5"><p>After the initial <a href="#HEADERS" class="smpl">HEADERS</a> frame sent by each peer, all subsequent <a href="#DATA" class="smpl">DATA</a> frames correspond to data sent on the TCP connection. The payload of any <a href="#DATA" class="smpl">DATA</a> frames sent by the client is transmitted by the proxy to the TCP server; data received from the TCP server is assembled into <a href="#DATA" class="smpl">DATA</a> frames by the proxy. Frame types other than <a href="#DATA" class="smpl">DATA</a> or stream management frames (<a href="#RST_STREAM" class="smpl">RST_STREAM</a>, <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a>, and <a href="#PRIORITY" class="smpl">PRIORITY</a>) MUST NOT be sent on a connected stream and MUST be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) if received.</p></div><div id="rfc.section.8.3.p.6"><p>The TCP connection can be closed by either peer. The END_STREAM flag on a <a href="#DATA" class="smpl">DATA</a> frame is treated as being equivalent to the TCP FIN bit. A client is expected to send a <a href="#DATA" class="smpl">DATA</a> frame with the END_STREAM flag set after receiving a frame bearing the END_STREAM flag. A proxy that receives a <a href="#DATA" class="smpl">DATA</a> frame with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP segment. A proxy that receives a TCP segment with the FIN bit set sends a <a href="#DATA" class="smpl">DATA</a> frame with the END_STREAM flag set. Note that the final TCP segment or <a href="#DATA" class="smpl">DATA</a> frame could be empty.</p></div><div id="rfc.section.8.3.p.7"><p>A TCP connection error is signaled with <a href="#RST_STREAM" class="smpl">RST_STREAM</a>. A proxy treats any error in the TCP connection, which includes receiving a TCP segment with the RST bit set, as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#CONNECT_ERROR" class="smpl">CONNECT_ERROR</a>. Correspondingly, a proxy MUST send a TCP segment with the RST bit set if it detects an error with the stream or the HTTP/2 connection.</p></div></div></div><div id="HttpExtra"><h2 id="rfc.section.9"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#HttpExtra">Additional HTTP Requirements/Considerations</a></h2><div id="rfc.section.9.p.1"><p>This section outlines attributes of the HTTP protocol that improve interoperability, reduce exposure to known security vulnerabilities, or reduce the potential for implementation variation.</p></div><div><h3 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1</a>&nbsp;Connection Management</h3><div id="rfc.section.9.1.p.1"><p>HTTP/2 connections are persistent. For best performance, it is expected that clients will not close connections until it is determined that no further communication with a server is necessary (for example, when a user navigates away from a particular web page) or until the server closes the connection.</p></div><div id="rfc.section.9.1.p.2"><p>Clients SHOULD NOT open more than one HTTP/2 connection to a given host and port pair, where the host is derived from a URI, a selected <a href="#ALT-SVC">alternative service</a> <cite title="HTTP Alternative Services">[ALT-SVC]</cite>, or a configured proxy.</p></div><div id="rfc.section.9.1.p.3"><p>A client can create additional connections as replacements, either to replace connections that are near to exhausting the available stream identifier space (<a href="#StreamIdentifiers" title="Stream Identifiers">Section&nbsp;5.1.1</a>), to refresh the keying material for a TLS connection, or to replace connections that have encountered errors (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>).</p></div><div id="rfc.section.9.1.p.4"><p>A client MAY open multiple connections to the same IP address and TCP port using different <a href="#TLS-EXT">Server Name Indication</a> <cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite> values or to provide different TLS client certificates but SHOULD avoid creating multiple connections with the same configuration.</p></div><div id="rfc.section.9.1.p.5"><p>Servers are encouraged to maintain open connections for as long as possible but are permitted to terminate idle connections if necessary. When either endpoint chooses to close the transport-layer TCP connection, the terminating endpoint SHOULD first send a <a href="#GOAWAY" class="smpl">GOAWAY</a> (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;6.8</a>) frame so that both endpoints can reliably determine whether previously sent frames have been processed and gracefully complete or terminate any necessary remaining tasks.</p></div><div id="reuse"><h4 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1</a>&nbsp;<a href="#reuse">Connection Reuse</a></h4><div id="rfc.section.9.1.1.p.1"><p>Connections that are made to an origin server, either directly or through a tunnel created using the CONNECT method (<a href="#CONNECT" title="The CONNECT Method">Section&nbsp;8.3</a>), MAY be reused for requests with multiple different URI authority components. A connection can be reused as long as the origin server is authoritative (<a href="#authority" title="Server Authority">Section&nbsp;10.1</a>). For TCP connections without TLS, this depends on the host having resolved to the same IP address.</p></div><div id="rfc.section.9.1.1.p.2"><p>For <tt>https</tt> resources, connection reuse additionally depends on having a certificate that is valid for the host in the URI. The certificate presented by the server MUST satisfy any checks that the client would perform when forming a new TLS connection for the host in the URI.</p></div><div id="rfc.section.9.1.1.p.3"><p>An origin server might offer a certificate with multiple <tt>subjectAltName</tt> attributes or names with wildcards, one of which is valid for the authority in the URI. For example, a certificate with a <tt>subjectAltName</tt> of <tt>*.example.com</tt> might permit the use of the same connection for requests to URIs starting with <tt>https://a.example.com/</tt> and <tt>https://b.example.com/</tt>.</p></div><div id="rfc.section.9.1.1.p.4"><p>In some deployments, reusing a connection for multiple origins can result in requests being directed to the wrong origin server. For example, TLS termination might be performed by a middlebox that uses the TLS <a href="#TLS-EXT">Server Name Indication (SNI)</a> <cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite> extension to select an origin server. This means that it is possible for clients to send confidential information to servers that might not be the intended target for the request, even though the server is otherwise authoritative.</p></div><div id="rfc.section.9.1.1.p.5"><p>A server that does not wish clients to reuse connections can indicate that it is not authoritative for a request by sending a 421 (Misdirected Request) status code in response to the request (see <a href="#MisdirectedRequest" title="The 421 (Misdirected Request) Status Code">Section&nbsp;9.1.2</a>).</p></div><div id="rfc.section.9.1.1.p.6"><p>A client that is configured to use a proxy over HTTP/2 directs requests to that proxy through a single connection. That is, all requests sent via a proxy reuse the connection to the proxy.</p></div></div><div id="MisdirectedRequest"><h4 id="rfc.section.9.1.2"><a href="#rfc.section.9.1.2">9.1.2</a>&nbsp;<a href="#MisdirectedRequest">The 421 (Misdirected Request) Status Code</a></h4><div id="rfc.section.9.1.2.p.1"><p>The 421 (Misdirected Request) status code indicates that the request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.</p></div><div id="rfc.section.9.1.2.p.2"><p>Clients receiving a 421 (Misdirected Request) response from a server MAY retry the request — whether the request method is idempotent or not — over a different connection. This is possible if a connection is reused (<a href="#reuse" title="Connection Reuse">Section&nbsp;9.1.1</a>) or if an alternative service is selected <a href="#ALT-SVC"><cite title="HTTP Alternative Services">[ALT-SVC]</cite></a>.</p></div><div id="rfc.section.9.1.2.p.3"><p>This status code MUST NOT be generated by proxies.</p></div><div id="rfc.section.9.1.2.p.4"><p>A 421 response is cacheable by default, i.e., unless otherwise indicated by the method definition or explicit cache controls (see <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7234.html#heuristic.freshness" title="Calculating Heuristic Freshness">Section 4.2.2</a> of <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>).</p></div></div></div><div id="TLSUsage"><h3 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2</a>&nbsp;<a href="#TLSUsage">Use of TLS Features</a></h3><div id="rfc.section.9.2.p.1"><p>Implementations of HTTP/2 MUST use <a href="#TLS12">TLS version 1.2</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite> or higher for HTTP/2 over TLS. The general TLS usage guidance in <a href="#TLSBCP"><cite title="Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)">[TLSBCP]</cite></a> SHOULD be followed, with some additional restrictions that are specific to HTTP/2.</p></div><div id="rfc.section.9.2.p.2"><p>The TLS implementation MUST support the <a href="#TLS-EXT">Server Name Indication (SNI)</a> <cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite> extension to TLS. HTTP/2 clients MUST indicate the target domain name when negotiating TLS.</p></div><div id="rfc.section.9.2.p.3"><p>Deployments of HTTP/2 that negotiate TLS 1.3 or higher need only support and use the SNI extension; deployments of TLS 1.2 are subject to the requirements in the following sections. Implementations are encouraged to provide defaults that comply, but it is recognized that deployments are ultimately responsible for compliance.</p></div><div><h4 id="rfc.section.9.2.1"><a href="#rfc.section.9.2.1">9.2.1</a>&nbsp;TLS 1.2 Features</h4><div id="rfc.section.9.2.1.p.1"><p>This section describes restrictions on the TLS 1.2 feature set that can be used with HTTP/2. Due to deployment limitations, it might not be possible to fail TLS negotiation when these restrictions are not met. An endpoint MAY immediately terminate an HTTP/2 connection that does not meet these TLS requirements with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#INADEQUATE_SECURITY" class="smpl">INADEQUATE_SECURITY</a>.</p></div><div id="rfc.section.9.2.1.p.2"><p>A deployment of HTTP/2 over TLS 1.2 MUST disable compression. TLS compression can lead to the exposure of information that would not otherwise be revealed <a href="#RFC3749"><cite title="Transport Layer Security Protocol Compression Methods">[RFC3749]</cite></a>. Generic compression is unnecessary since HTTP/2 provides compression features that are more aware of context and therefore likely to be more appropriate for use for performance, security, or other reasons.</p></div><div id="rfc.section.9.2.1.p.3"><p>A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation. An endpoint MUST treat a TLS renegotiation as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#PROTOCOL_ERROR" class="smpl">PROTOCOL_ERROR</a>. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</p></div><div id="rfc.section.9.2.1.p.4"><p>An endpoint MAY use renegotiation to provide confidentiality protection for client credentials offered in the handshake, but any renegotiation MUST occur prior to sending the connection preface. A server SHOULD request a client certificate if it sees a renegotiation request immediately after establishing a connection.</p></div><div id="rfc.section.9.2.1.p.5"><p>This effectively prevents the use of renegotiation in response to a request for a specific protected resource. A future specification might provide a way to support this use case. Alternatively, a server might use an error (<a href="#ErrorHandler" title="Error Handling">Section&nbsp;5.4</a>) of type <a href="#HTTP_1_1_REQUIRED" class="smpl">HTTP_1_1_REQUIRED</a> to request the client use a protocol that supports renegotiation.</p></div><div id="rfc.section.9.2.1.p.6"><p>Implementations MUST support ephemeral key exchange sizes of at least 2048 bits for cipher suites that use ephemeral finite field Diffie-Hellman (DHE) <a href="#TLS12"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite></a> and 224 bits for cipher suites that use ephemeral elliptic curve Diffie-Hellman (ECDHE) <a href="#RFC4492"><cite title="Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)">[RFC4492]</cite></a>. Clients MUST accept DHE sizes of up to 4096 bits. Endpoints MAY treat negotiation of key sizes smaller than the lower limits as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#INADEQUATE_SECURITY" class="smpl">INADEQUATE_SECURITY</a>.</p></div></div><div><h4 id="rfc.section.9.2.2"><a href="#rfc.section.9.2.2">9.2.2</a>&nbsp;TLS 1.2 Cipher Suites</h4><div id="rfc.section.9.2.2.p.1"><p>A deployment of HTTP/2 over TLS 1.2 SHOULD NOT use any of the cipher suites that are listed in the cipher suite black list (<a href="#BadCipherSuites" title="TLS 1.2 Cipher Suite Black List">Appendix&nbsp;A</a>).</p></div><div id="rfc.section.9.2.2.p.2"><p>Endpoints MAY choose to generate a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#INADEQUATE_SECURITY" class="smpl">INADEQUATE_SECURITY</a> if one of the cipher suites from the black list is negotiated. A deployment that chooses to use a black-listed cipher suite risks triggering a connection error unless the set of potential peers is known to accept that cipher suite.</p></div><div id="rfc.section.9.2.2.p.3"><p>Implementations MUST NOT generate this error in reaction to the negotiation of a cipher suite that is not on the black list. Consequently, when clients offer a cipher suite that is not on the black list, they have to be prepared to use that cipher suite with HTTP/2.</p></div><div id="rfc.section.9.2.2.p.4"><p>The black list includes the cipher suite that TLS 1.2 makes mandatory, which means that TLS 1.2 deployments could have non-intersecting sets of permitted cipher suites. To avoid this problem causing TLS handshake failures, deployments of HTTP/2 that use TLS 1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 <a href="#TLS-ECDHE"><cite title="TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)">[TLS-ECDHE]</cite></a> with the P-256 elliptic curve <a href="#FIPS186"><cite title="Digital Signature Standard (DSS)">[FIPS186]</cite></a>.</p></div><div id="rfc.section.9.2.2.p.5"><p>Note that clients might advertise support of cipher suites that are on the black list in order to allow for connection to servers that do not support HTTP/2. This allows servers to select HTTP/1.1 with a cipher suite that is on the HTTP/2 black list. However, this can result in HTTP/2 being negotiated with a black-listed cipher suite if the application protocol and cipher suite are independently selected.</p></div></div></div></div><div id="security"><h2 id="rfc.section.10"><a href="#rfc.section.10">10.</a>&nbsp;<a href="#security">Security Considerations</a></h2><div id="authority"><h3 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1</a>&nbsp;<a href="#authority">Server Authority</a></h3><div id="rfc.section.10.1.p.1"><p>HTTP/2 relies on the HTTP/1.1 definition of authority for determining whether a server is authoritative in providing a given response (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#establishing.authority" title="Establishing Authority">Section 9.1</a>). This relies on local name resolution for the "http" URI scheme and the authenticated server identity for the "https" scheme (see <a href="#RFC2818"><cite title="HTTP Over TLS">[RFC2818]</cite></a>, <a href="https://tools.ietf.org/html/rfc2818#section-3">Section 3</a>).</p></div></div><div><h3 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2</a>&nbsp;Cross-Protocol Attacks</h3><div id="rfc.section.10.2.p.1"><p>In a cross-protocol attack, an attacker causes a client to initiate a transaction in one protocol toward a server that understands a different protocol. An attacker might be able to cause the transaction to appear as a valid transaction in the second protocol. In combination with the capabilities of the web context, this can be used to interact with poorly protected servers in private networks.</p></div><div id="rfc.section.10.2.p.2"><p>Completing a TLS handshake with an ALPN identifier for HTTP/2 can be considered sufficient protection against cross-protocol attacks. ALPN provides a positive indication that a server is willing to proceed with HTTP/2, which prevents attacks on other TLS-based protocols.</p></div><div id="rfc.section.10.2.p.3"><p>The encryption in TLS makes it difficult for attackers to control the data that could be used in a cross-protocol attack on a cleartext protocol.</p></div><div id="rfc.section.10.2.p.4"><p>The cleartext version of HTTP/2 has minimal protection against cross-protocol attacks. The connection preface (<a href="#ConnectionHeader" title="HTTP/2 Connection Preface">Section&nbsp;3.5</a>) contains a string that is designed to confuse HTTP/1.1 servers, but no special protection is offered for other protocols. A server that is willing to ignore parts of an HTTP/1.1 request containing an Upgrade header field in addition to the client connection preface could be exposed to a cross-protocol attack.</p></div></div><div><h3 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3</a>&nbsp;Intermediary Encapsulation Attacks</h3><div id="rfc.section.10.3.p.1"><p>The HTTP/2 header field encoding allows the expression of names that are not valid field names in the Internet Message Syntax used by HTTP/1.1. Requests or responses containing invalid header field names MUST be treated as malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>). An intermediary therefore cannot translate an HTTP/2 request or response containing an invalid field name into an HTTP/1.1 message.</p></div><div id="rfc.section.10.3.p.2"><p>Similarly, HTTP/2 allows header field values that are not valid. While most of the values that can be encoded will not alter header field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII 0x0) might be exploited by an attacker if they are translated verbatim. Any request or response that contains a character not permitted in a header field value MUST be treated as malformed (<a href="#malformed" title="Malformed Requests and Responses">Section&nbsp;8.1.2.6</a>). Valid characters are defined by the <tt>field-content</tt> ABNF rule in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.fields" title="Header Fields">Section 3.2</a> of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div></div><div><h3 id="rfc.section.10.4"><a href="#rfc.section.10.4">10.4</a>&nbsp;Cacheability of Pushed Responses</h3><div id="rfc.section.10.4.p.1"><p>Pushed responses do not have an explicit request from the client; the request is provided by the server in the <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frame.</p></div><div id="rfc.section.10.4.p.2"><p>Caching responses that are pushed is possible based on the guidance provided by the origin server in the Cache-Control header field. However, this can cause issues if a single server hosts more than one tenant. For example, a server might offer multiple users each a small portion of its URI space.</p></div><div id="rfc.section.10.4.p.3"><p>Where multiple tenants share space on the same server, that server MUST ensure that tenants are not able to push representations of resources that they do not have authority over. Failure to enforce this would allow a tenant to provide a representation that would be served out of cache, overriding the actual representation that the authoritative tenant provides.</p></div><div id="rfc.section.10.4.p.4"><p>Pushed responses for which an origin server is not authoritative (see <a href="#authority" title="Server Authority">Section&nbsp;10.1</a>) MUST NOT be used or cached.</p></div></div><div id="dos"><h3 id="rfc.section.10.5"><a href="#rfc.section.10.5">10.5</a>&nbsp;<a href="#dos">Denial-of-Service Considerations</a></h3><div id="rfc.section.10.5.p.1"><p>An HTTP/2 connection can demand a greater commitment of resources to operate than an HTTP/1.1 connection. The use of header compression and flow control depend on a commitment of resources for storing a greater amount of state. Settings for these features ensure that memory commitments for these features are strictly bounded.</p></div><div id="rfc.section.10.5.p.2"><p>The number of <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames is not constrained in the same fashion. A client that accepts server push SHOULD limit the number of streams it allows to be in the "reserved (remote)" state. An excessive number of server push streams can be treated as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;5.4.2</a>) of type <a href="#ENHANCE_YOUR_CALM" class="smpl">ENHANCE_YOUR_CALM</a>.</p></div><div id="rfc.section.10.5.p.3"><p>Processing capacity cannot be guarded as effectively as state capacity.</p></div><div id="rfc.section.10.5.p.4"><p>The <a href="#SETTINGS" class="smpl">SETTINGS</a> frame can be abused to cause a peer to expend additional processing time. This might be done by pointlessly changing SETTINGS parameters, setting multiple undefined parameters, or changing the same setting multiple times in the same frame. <a href="#WINDOW_UPDATE" class="smpl">WINDOW_UPDATE</a> or <a href="#PRIORITY" class="smpl">PRIORITY</a> frames can be abused to cause an unnecessary waste of resources.</p></div><div id="rfc.section.10.5.p.5"><p>Large numbers of small or empty frames can be abused to cause a peer to expend time processing frame headers. Note, however, that some uses are entirely legitimate, such as the sending of an empty <a href="#DATA" class="smpl">DATA</a> or <a href="#CONTINUATION" class="smpl">CONTINUATION</a> frame at the end of a stream.</p></div><div id="rfc.section.10.5.p.6"><p>Header compression also offers some opportunities to waste processing resources; see <a href="https://tools.ietf.org/html/rfc7541#section-7" title="Security Considerations">Section 7</a> of <a href="#COMPRESSION"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a> for more details on potential abuses.</p></div><div id="rfc.section.10.5.p.7"><p>Limits in <a href="#SETTINGS" class="smpl">SETTINGS</a> parameters cannot be reduced instantaneously, which leaves an endpoint exposed to behavior from a peer that could exceed the new limits. In particular, immediately after establishing a connection, limits set by a server are not known to clients and could be exceeded without being an obvious protocol violation.</p></div><div id="rfc.section.10.5.p.8"><p>All these features — i.e., <a href="#SETTINGS" class="smpl">SETTINGS</a> changes, small frames, header compression — have legitimate uses. These features become a burden only when they are used unnecessarily or to excess.</p></div><div id="rfc.section.10.5.p.9"><p>An endpoint that doesn't monitor this behavior exposes itself to a risk of denial-of-service attack. Implementations SHOULD track the use of these features and set limits on their use. An endpoint MAY treat activity that is suspicious as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#ENHANCE_YOUR_CALM" class="smpl">ENHANCE_YOUR_CALM</a>.</p></div><div id="MaxHeaderBlock"><h4 id="rfc.section.10.5.1"><a href="#rfc.section.10.5.1">10.5.1</a>&nbsp;<a href="#MaxHeaderBlock">Limits on Header Block Size</a></h4><div id="rfc.section.10.5.1.p.1"><p>A large header block (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>) can cause an implementation to commit a large amount of state. Header fields that are critical for routing can appear toward the end of a header block, which prevents streaming of header fields to their ultimate destination. This ordering and other reasons, such as ensuring cache correctness, mean that an endpoint might need to buffer the entire header block. Since there is no hard limit to the size of a header block, some endpoints could be forced to commit a large amount of available memory for header fields.</p></div><div id="rfc.section.10.5.1.p.2"><p>An endpoint can use the <a href="#SETTINGS_MAX_HEADER_LIST_SIZE" class="smpl">SETTINGS_MAX_HEADER_LIST_SIZE</a> to advise peers of limits that might apply on the size of header blocks. This setting is only advisory, so endpoints MAY choose to send header blocks that exceed this limit and risk having the request or response being treated as malformed. This setting is specific to a connection, so any request or response could encounter a hop with a lower, unknown limit. An intermediary can attempt to avoid this problem by passing on values presented by different peers, but they are not obligated to do so.</p></div><div id="rfc.section.10.5.1.p.3"><p>A server that receives a larger header block than it is willing to handle can send an HTTP 431 (Request Header Fields Too Large) status code <a href="#RFC6585"><cite title="Additional HTTP Status Codes">[RFC6585]</cite></a>. A client can discard responses that it cannot process. The header block MUST be processed to ensure a consistent connection state, unless the connection is closed.</p></div></div><div id="connectDos"><h4 id="rfc.section.10.5.2"><a href="#rfc.section.10.5.2">10.5.2</a>&nbsp;<a href="#connectDos">CONNECT Issues</a></h4><div id="rfc.section.10.5.2.p.1"><p>The CONNECT method can be used to create disproportionate load on an proxy, since stream creation is relatively inexpensive when compared to the creation and maintenance of a TCP connection. A proxy might also maintain some resources for a TCP connection beyond the closing of the stream that carries the CONNECT request, since the outgoing TCP connection remains in the TIME_WAIT state. Therefore, a proxy cannot rely on <a href="#SETTINGS_MAX_CONCURRENT_STREAMS" class="smpl">SETTINGS_MAX_CONCURRENT_STREAMS</a> alone to limit the resources consumed by CONNECT requests.</p></div></div></div><div><h3 id="rfc.section.10.6"><a href="#rfc.section.10.6">10.6</a>&nbsp;Use of Compression</h3><div id="rfc.section.10.6.p.1"><p>Compression can allow an attacker to recover secret data when it is compressed in the same context as data under attacker control. HTTP/2 enables compression of header fields (<a href="#HeaderBlock" title="Header Compression and Decompression">Section&nbsp;4.3</a>); the following concerns also apply to the use of HTTP compressed content-codings (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#content.codings" title="Content Codings">Section 3.1.2.1</a>).</p></div><div id="rfc.section.10.6.p.2"><p>There are demonstrable attacks on compression that exploit the characteristics of the web (e.g., <a href="#BREACH"><cite title="BREACH: Reviving the CRIME Attack">[BREACH]</cite></a>). The attacker induces multiple requests containing varying plaintext, observing the length of the resulting ciphertext in each, which reveals a shorter length when a guess about the secret is correct.</p></div><div id="rfc.section.10.6.p.3"><p>Implementations communicating on a secure channel MUST NOT compress content that includes both confidential and attacker-controlled data unless separate compression dictionaries are used for each source of data. Compression MUST NOT be used if the source of data cannot be reliably determined. Generic stream compression, such as that provided by TLS, MUST NOT be used with HTTP/2 (see <a href="#TLSUsage" title="Use of TLS Features">Section&nbsp;9.2</a>).</p></div><div id="rfc.section.10.6.p.4"><p>Further considerations regarding the compression of header fields are described in <a href="#COMPRESSION"><cite title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>.</p></div></div><div id="padding"><h3 id="rfc.section.10.7"><a href="#rfc.section.10.7">10.7</a>&nbsp;<a href="#padding">Use of Padding</a></h3><div id="rfc.section.10.7.p.1"><p>Padding within HTTP/2 is not intended as a replacement for general purpose padding, such as might be provided by <a href="#TLS12">TLS</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite>. Redundant padding could even be counterproductive. Correct application can depend on having specific knowledge of the data that is being padded.</p></div><div id="rfc.section.10.7.p.2"><p>To mitigate attacks that rely on compression, disabling or limiting compression might be preferable to padding as a countermeasure.</p></div><div id="rfc.section.10.7.p.3"><p>Padding can be used to obscure the exact size of frame content and is provided to mitigate specific attacks within HTTP, for example, attacks where compressed content includes both attacker-controlled plaintext and secret data (e.g., <a href="#BREACH"><cite title="BREACH: Reviving the CRIME Attack">[BREACH]</cite></a>).</p></div><div id="rfc.section.10.7.p.4"><p>Use of padding can result in less protection than might seem immediately obvious. At best, padding only makes it more difficult for an attacker to infer length information by increasing the number of frames an attacker has to observe. Incorrectly implemented padding schemes can be easily defeated. In particular, randomized padding with a predictable distribution provides very little protection; similarly, padding payloads to a fixed size exposes information as payload sizes cross the fixed-sized boundary, which could be possible if an attacker can control plaintext.</p></div><div id="rfc.section.10.7.p.5"><p>Intermediaries SHOULD retain padding for <a href="#DATA" class="smpl">DATA</a> frames but MAY drop padding for <a href="#HEADERS" class="smpl">HEADERS</a> and <a href="#PUSH_PROMISE" class="smpl">PUSH_PROMISE</a> frames. A valid reason for an intermediary to change the amount of padding of frames is to improve the protections that padding provides.</p></div></div><div><h3 id="rfc.section.10.8"><a href="#rfc.section.10.8">10.8</a>&nbsp;Privacy Considerations</h3><div id="rfc.section.10.8.p.1"><p>Several characteristics of HTTP/2 provide an observer an opportunity to correlate actions of a single client or server over time. These include the value of settings, the manner in which flow-control windows are managed, the way priorities are allocated to streams, the timing of reactions to stimulus, and the handling of any features that are controlled by settings.</p></div><div id="rfc.section.10.8.p.2"><p>As far as these create observable differences in behavior, they could be used as a basis for fingerprinting a specific client, as defined in <a href="http://www.w3.org/TR/2014/REC-html5-20141028/introduction.html#fingerprint">Section 1.8</a> of <a href="#HTML5"><cite title="HTML5">[HTML5]</cite></a>.</p></div><div id="rfc.section.10.8.p.3"><p>HTTP/2's preference for using a single TCP connection allows correlation of a user's activity on a site. Reusing connections for different origins allows tracking across those origins.</p></div><div id="rfc.section.10.8.p.4"><p>Because the PING and SETTINGS frames solicit immediate responses, they can be used by an endpoint to measure latency to their peer. This might have privacy implications in certain scenarios.</p></div></div></div><div id="iana"><h2 id="rfc.section.11"><a href="#rfc.section.11">11.</a>&nbsp;<a href="#iana">IANA Considerations</a></h2><div id="rfc.section.11.p.1"><p>A string for identifying HTTP/2 is entered into the "Application-Layer Protocol Negotiation (ALPN) Protocol IDs" registry established in <a href="#TLS-ALPN"><cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite></a>.</p></div><div id="rfc.section.11.p.2"><p>This document establishes a registry for frame types, settings, and error codes. These new registries appear in the new "Hypertext Transfer Protocol version 2 (HTTP/2) Parameters" section.</p></div><div id="rfc.section.11.p.3"><p>This document registers the <tt>HTTP2-Settings</tt> header field for use in HTTP; it also registers the 421 (Misdirected Request) status code.</p></div><div id="rfc.section.11.p.4"><p>This document registers the <tt>PRI</tt> method for use in HTTP to avoid collisions with the connection preface (<a href="#ConnectionHeader" title="HTTP/2 Connection Preface">Section&nbsp;3.5</a>).</p></div><div id="iana-alpn"><h3 id="rfc.section.11.1"><a href="#rfc.section.11.1">11.1</a>&nbsp;<a href="#iana-alpn">Registration of HTTP/2 Identification Strings</a></h3><div id="rfc.section.11.1.p.1"><p>This document creates two registrations for the identification of HTTP/2 (see <a href="#discover-https" title="Starting HTTP/2 for &#34;https&#34; URIs">Section&nbsp;3.3</a>) in the "Application-Layer Protocol Negotiation (ALPN) Protocol IDs" registry established in <a href="#TLS-ALPN"><cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite></a>.</p></div><div id="rfc.section.11.1.p.2"><p>The "h2" string identifies HTTP/2 when used over TLS: </p><dl><dt>Protocol:</dt><dd>HTTP/2 over TLS</dd><dt>Identification Sequence:</dt><dd>0x68 0x32 ("h2")</dd><dt>Specification:</dt><dd>This document</dd></dl></div><div id="rfc.section.11.1.p.3"><p>The "h2c" string identifies HTTP/2 when used over cleartext TCP: </p><dl><dt>Protocol:</dt><dd>HTTP/2 over TCP</dd><dt>Identification Sequence:</dt><dd>0x68 0x32 0x63 ("h2c")</dd><dt>Specification:</dt><dd>This document</dd></dl></div></div><div id="iana-frames"><h3 id="rfc.section.11.2"><a href="#rfc.section.11.2">11.2</a>&nbsp;<a href="#iana-frames">Frame Type Registry</a></h3><div id="rfc.section.11.2.p.1"><p>This document establishes a registry for HTTP/2 frame type codes. The "HTTP/2 Frame Type" registry manages an 8-bit space. The "HTTP/2 Frame Type" registry operates under either of the <a href="#RFC5226">"IETF Review" or "IESG Approval" policies</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite> for values between 0x00 and 0xef, with values between 0xf0 and 0xff being reserved for Experimental Use.</p></div><div id="rfc.section.11.2.p.2"><p>New entries in this registry require the following information: </p><dl><dt>Frame Type:</dt><dd>A name or label for the frame type.</dd><dt>Code:</dt><dd>The 8-bit code assigned to the frame type.</dd><dt>Specification:</dt><dd>A reference to a specification that includes a description of the frame layout, its semantics, and flags that the frame type uses, including any parts of the frame that are conditionally present based on the value of flags.</dd></dl></div><div id="rfc.section.11.2.p.3"><p>The entries in the following table are registered by this document.</p></div><div id="rfc.table.u.1"><table class="table table-condensed table-striped full text-left" cellpadding="3" cellspacing="0"><thead><tr><th>Frame Type</th><th>Code</th><th>Section</th></tr></thead><tbody><tr><td class="left">DATA</td><td class="left">0x0</td><td class="left"><a href="#DATA" title="DATA">Section&nbsp;6.1</a></td></tr><tr><td class="left">HEADERS</td><td class="left">0x1</td><td class="left"><a href="#HEADERS" title="HEADERS">Section&nbsp;6.2</a></td></tr><tr><td class="left">PRIORITY</td><td class="left">0x2</td><td class="left"><a href="#PRIORITY" title="PRIORITY">Section&nbsp;6.3</a></td></tr><tr><td class="left">RST_STREAM</td><td class="left">0x3</td><td class="left"><a href="#RST_STREAM" title="RST_STREAM">Section&nbsp;6.4</a></td></tr><tr><td class="left">SETTINGS</td><td class="left">0x4</td><td class="left"><a href="#SETTINGS" title="SETTINGS">Section&nbsp;6.5</a></td></tr><tr><td class="left">PUSH_PROMISE</td><td class="left">0x5</td><td class="left"><a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section&nbsp;6.6</a></td></tr><tr><td class="left">PING</td><td class="left">0x6</td><td class="left"><a href="#PING" title="PING">Section&nbsp;6.7</a></td></tr><tr><td class="left">GOAWAY</td><td class="left">0x7</td><td class="left"><a href="#GOAWAY" title="GOAWAY">Section&nbsp;6.8</a></td></tr><tr><td class="left">WINDOW_UPDATE</td><td class="left">0x8</td><td class="left"><a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section&nbsp;6.9</a></td></tr><tr><td class="left">CONTINUATION</td><td class="left">0x9</td><td class="left"><a href="#CONTINUATION" title="CONTINUATION">Section&nbsp;6.10</a></td></tr></tbody></table></div></div><div id="iana-settings"><h3 id="rfc.section.11.3"><a href="#rfc.section.11.3">11.3</a>&nbsp;<a href="#iana-settings">Settings Registry</a></h3><div id="rfc.section.11.3.p.1"><p>This document establishes a registry for HTTP/2 settings. The "HTTP/2 Settings" registry manages a 16-bit space. The "HTTP/2 Settings" registry operates under the <a href="#RFC5226">"Expert Review" policy</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite> for values in the range from 0x0000 to 0xefff, with values between and 0xf000 and 0xffff being reserved for Experimental Use.</p></div><div id="rfc.section.11.3.p.2"><p>New registrations are advised to provide the following information: </p><dl><dt>Name:</dt><dd>A symbolic name for the setting. Specifying a setting name is optional.</dd><dt>Code:</dt><dd>The 16-bit code assigned to the setting.</dd><dt>Initial Value:</dt><dd>An initial value for the setting.</dd><dt>Specification:</dt><dd>An optional reference to a specification that describes the use of the setting.</dd></dl></div><div id="rfc.section.11.3.p.3"><p>The entries in the following table are registered by this document.</p></div><div id="rfc.table.u.2"><table class="table table-condensed table-striped full text-left" cellpadding="3" cellspacing="0"><thead><tr><th>Name</th><th>Code</th><th>Initial Value</th><th>Specification</th></tr></thead><tbody><tr><td class="left">HEADER_TABLE_SIZE</td><td class="left">0x1</td><td class="left">4096</td><td class="left"><a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a></td></tr><tr><td class="left">ENABLE_PUSH</td><td class="left">0x2</td><td class="left">1</td><td class="left"><a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a></td></tr><tr><td class="left">MAX_CONCURRENT_STREAMS</td><td class="left">0x3</td><td class="left">(infinite)</td><td class="left"><a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a></td></tr><tr><td class="left">INITIAL_WINDOW_SIZE</td><td class="left">0x4</td><td class="left">65535</td><td class="left"><a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a></td></tr><tr><td class="left">MAX_FRAME_SIZE</td><td class="left">0x5</td><td class="left">16384</td><td class="left"><a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a></td></tr><tr><td class="left">MAX_HEADER_LIST_SIZE</td><td class="left">0x6</td><td class="left">(infinite)</td><td class="left"><a href="#SettingValues" title="Defined SETTINGS Parameters">Section&nbsp;6.5.2</a></td></tr></tbody></table></div></div><div id="iana-errors"><h3 id="rfc.section.11.4"><a href="#rfc.section.11.4">11.4</a>&nbsp;<a href="#iana-errors">Error Code Registry</a></h3><div id="rfc.section.11.4.p.1"><p>This document establishes a registry for HTTP/2 error codes. The "HTTP/2 Error Code" registry manages a 32-bit space. The "HTTP/2 Error Code" registry operates under the <a href="#RFC5226">"Expert Review" policy</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite>.</p></div><div id="rfc.section.11.4.p.2"><p>Registrations for error codes are required to include a description of the error code. An expert reviewer is advised to examine new registrations for possible duplication with existing error codes. Use of existing registrations is to be encouraged, but not mandated.</p></div><div id="rfc.section.11.4.p.3"><p>New registrations are advised to provide the following information: </p><dl><dt>Name:</dt><dd>A name for the error code. Specifying an error code name is optional.</dd><dt>Code:</dt><dd>The 32-bit error code value.</dd><dt>Description:</dt><dd>A brief description of the error code semantics, longer if no detailed specification is provided.</dd><dt>Specification:</dt><dd>An optional reference for a specification that defines the error code.</dd></dl></div><div id="rfc.section.11.4.p.4"><p>The entries in the following table are registered by this document.</p></div><div id="rfc.table.u.3"><table class="table table-condensed table-striped full text-left" cellpadding="3" cellspacing="0"><thead><tr><th>Name</th><th>Code</th><th>Description</th><th>Specification</th></tr></thead><tbody><tr><td class="left">NO_ERROR</td><td class="left">0x0</td><td class="left">Graceful shutdown</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">PROTOCOL_ERROR</td><td class="left">0x1</td><td class="left">Protocol error detected</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">INTERNAL_ERROR</td><td class="left">0x2</td><td class="left">Implementation fault</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">FLOW_CONTROL_ERROR</td><td class="left">0x3</td><td class="left">Flow-control limits exceeded</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">SETTINGS_TIMEOUT</td><td class="left">0x4</td><td class="left">Settings not acknowledged</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">STREAM_CLOSED</td><td class="left">0x5</td><td class="left">Frame received for closed stream</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">FRAME_SIZE_ERROR</td><td class="left">0x6</td><td class="left">Frame size incorrect</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">REFUSED_STREAM</td><td class="left">0x7</td><td class="left">Stream not processed</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">CANCEL</td><td class="left">0x8</td><td class="left">Stream cancelled</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">COMPRESSION_ERROR</td><td class="left">0x9</td><td class="left">Compression state not updated</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">CONNECT_ERROR</td><td class="left">0xa</td><td class="left">TCP connection error for CONNECT method</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">ENHANCE_YOUR_CALM</td><td class="left">0xb</td><td class="left">Processing capacity exceeded</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">INADEQUATE_SECURITY</td><td class="left">0xc</td><td class="left">Negotiated TLS parameters not acceptable</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr><tr><td class="left">HTTP_1_1_REQUIRED</td><td class="left">0xd</td><td class="left">Use HTTP/1.1 for the request</td><td class="left"><a href="#ErrorCodes" title="Error Codes">Section&nbsp;7</a></td></tr></tbody></table></div></div><div><h3 id="rfc.section.11.5"><a href="#rfc.section.11.5">11.5</a>&nbsp;HTTP2-Settings Header Field Registration</h3><div id="rfc.section.11.5.p.1"><p>This section registers the <tt>HTTP2-Settings</tt> header field in the "Permanent Message Header Field Names" registry <a href="#BCP90"><cite title="Registration Procedures for Message Header Fields">[BCP90]</cite></a>. </p><dl><dt>Header field name:</dt><dd>HTTP2-Settings</dd><dt>Applicable protocol:</dt><dd>http</dd><dt>Status:</dt><dd>standard</dd><dt>Author/Change controller:</dt><dd>IETF</dd><dt>Specification document(s):</dt><dd><a href="#Http2SettingsHeader" title="HTTP2-Settings Header Field">Section&nbsp;3.2.1</a> of this document</dd><dt>Related information:</dt><dd>This header field is only used by an HTTP/2 client for Upgrade-based negotiation.</dd></dl></div></div><div><h3 id="rfc.section.11.6"><a href="#rfc.section.11.6">11.6</a>&nbsp;PRI Method Registration</h3><div id="rfc.section.11.6.p.1"><p>This section registers the <tt>PRI</tt> method in the "HTTP Method Registry" (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#method.registry" title="Method Registry">Section 8.1</a>). </p><dl><dt>Method Name:</dt><dd>PRI</dd><dt>Safe:</dt><dd>Yes</dd><dt>Idempotent:</dt><dd>Yes</dd><dt>Specification document(s):</dt><dd><a href="#ConnectionHeader" title="HTTP/2 Connection Preface">Section&nbsp;3.5</a> of this document</dd><dt>Related information:</dt><dd>This method is never used by an actual client. This method will appear to be used when an HTTP/1.1 server or intermediary attempts to parse an HTTP/2 connection preface.</dd></dl></div></div><div id="iana-MisdirectedRequest"><h3 id="rfc.section.11.7"><a href="#rfc.section.11.7">11.7</a>&nbsp;<a href="#iana-MisdirectedRequest">The 421 (Misdirected Request) HTTP Status Code</a></h3><div id="rfc.section.11.7.p.1"><p>This document registers the 421 (Misdirected Request) HTTP status code in the "HTTP Status Codes" registry (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#status.code.registry" title="Status Code Registry">Section 8.2</a>).</p></div><div id="rfc.section.11.7.p.2"><dl><dt>Status Code:</dt><dd>421</dd><dt>Short Description:</dt><dd>Misdirected Request</dd><dt>Specification:</dt><dd><a href="#MisdirectedRequest" title="The 421 (Misdirected Request) Status Code">Section&nbsp;9.1.2</a> of this document</dd></dl></div></div><div id="iana-h2c"><h3 id="rfc.section.11.8"><a href="#rfc.section.11.8">11.8</a>&nbsp;<a href="#iana-h2c">The h2c Upgrade Token</a></h3><div id="rfc.section.11.8.p.1"><p>This document registers the "h2c" upgrade token in the "HTTP Upgrade Tokens" registry (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#upgrade.token.registry" title="Upgrade Token Registry">Section 8.6</a>).</p></div><div id="rfc.section.11.8.p.2"><dl><dt>Value:</dt><dd>h2c</dd><dt>Description:</dt><dd>Hypertext Transfer Protocol version 2 (HTTP/2)</dd><dt>Expected Version Tokens:</dt><dd>None</dd><dt>Reference:</dt><dd><a href="#discover-http" title="Starting HTTP/2 for &#34;http&#34; URIs">Section&nbsp;3.2</a> of this document</dd></dl></div></div></div><h2 id="rfc.references"><a id="rfc.section.12" href="#rfc.section.12">12.</a> References</h2><h3 id="rfc.references.1"><a href="#rfc.section.12.1" id="rfc.section.12.1">12.1</a> Normative References</h3><table><tr><td class="reference"><b id="COMPRESSION">[COMPRESSION]</b></td><td class="top">Peon, R. and H. Ruellan, “<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>”, RFC&nbsp;7541, <a href="http://dx.doi.org/10.17487/RFC7541">DOI&nbsp;10.17487/RFC7541</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7541">http://www.rfc-editor.org/info/rfc7541</a>&gt;.</td></tr><tr><td class="reference"><b id="COOKIE">[COOKIE]</b></td><td class="top">Barth, A., “<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>”, RFC&nbsp;6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI&nbsp;10.17487/RFC6265</a>, April&nbsp;2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6265">http://www.rfc-editor.org/info/rfc6265</a>&gt;.</td></tr><tr><td class="reference"><b id="FIPS186">[FIPS186]</b></td><td class="top">NIST, “<a href="http://dx.doi.org/10.6028/NIST.FIPS.186-4">Digital Signature Standard (DSS)</a>”, FIPS&nbsp;PUB 186-4, July&nbsp;2013, &lt;<a href="http://dx.doi.org/10.6028/NIST.FIPS.186-4">http://dx.doi.org/10.6028/NIST.FIPS.186-4</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top">Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC2818">[RFC2818]</b></td><td class="top">Rescorla, E., “<a href="https://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>”, RFC&nbsp;2818, <a href="http://dx.doi.org/10.17487/RFC2818">DOI&nbsp;10.17487/RFC2818</a>, May&nbsp;2000, &lt;<a href="http://www.rfc-editor.org/info/rfc2818">http://www.rfc-editor.org/info/rfc2818</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC3986">[RFC3986]</b></td><td class="top">Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD&nbsp;66, RFC&nbsp;3986, <a href="http://dx.doi.org/10.17487/RFC3986">DOI&nbsp;10.17487/RFC3986</a>, January&nbsp;2005, &lt;<a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC4648">[RFC4648]</b></td><td class="top">Josefsson, S., “<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>”, RFC&nbsp;4648, <a href="http://dx.doi.org/10.17487/RFC4648">DOI&nbsp;10.17487/RFC4648</a>, October&nbsp;2006, &lt;<a href="http://www.rfc-editor.org/info/rfc4648">http://www.rfc-editor.org/info/rfc4648</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC5226">[RFC5226]</b></td><td class="top">Narten, T. and H. Alvestrand, “<a href="https://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>”, BCP&nbsp;26, RFC&nbsp;5226, <a href="http://dx.doi.org/10.17487/RFC5226">DOI&nbsp;10.17487/RFC5226</a>, May&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5226">http://www.rfc-editor.org/info/rfc5226</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC5234">[RFC5234]</b></td><td class="top">Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI&nbsp;10.17487/RFC5234</a>, January&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5234">http://www.rfc-editor.org/info/rfc5234</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7230">[RFC7230]</b></td><td class="top">Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7231">[RFC7231]</b></td><td class="top">Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7232">[RFC7232]</b></td><td class="top">Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7232">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>”, RFC&nbsp;7232, <a href="http://dx.doi.org/10.17487/RFC7232">DOI&nbsp;10.17487/RFC7232</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7232">http://www.rfc-editor.org/info/rfc7232</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7233">[RFC7233]</b></td><td class="top">Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7233">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, RFC&nbsp;7233, <a href="http://dx.doi.org/10.17487/RFC7233">DOI&nbsp;10.17487/RFC7233</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7233">http://www.rfc-editor.org/info/rfc7233</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7234">[RFC7234]</b></td><td class="top">Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI&nbsp;10.17487/RFC7234</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7235">[RFC7235]</b></td><td class="top">Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7235">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>”, RFC&nbsp;7235, <a href="http://dx.doi.org/10.17487/RFC7235">DOI&nbsp;10.17487/RFC7235</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7235">http://www.rfc-editor.org/info/rfc7235</a>&gt;.</td></tr><tr><td class="reference"><b id="TCP">[TCP]</b></td><td class="top">Postel, J., “<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>”, STD&nbsp;7, RFC&nbsp;793, <a href="http://dx.doi.org/10.17487/RFC0793">DOI&nbsp;10.17487/RFC0793</a>, September&nbsp;1981, &lt;<a href="http://www.rfc-editor.org/info/rfc793">http://www.rfc-editor.org/info/rfc793</a>&gt;.</td></tr><tr><td class="reference"><b id="TLS-ALPN">[TLS-ALPN]</b></td><td class="top">Friedl, S., Popov, A., Langley, A., and E. Stephan, “<a href="https://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>”, RFC&nbsp;7301, <a href="http://dx.doi.org/10.17487/RFC7301">DOI&nbsp;10.17487/RFC7301</a>, July&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7301">http://www.rfc-editor.org/info/rfc7301</a>&gt;.</td></tr><tr><td class="reference"><b id="TLS-ECDHE">[TLS-ECDHE]</b></td><td class="top">Rescorla, E., “<a href="https://tools.ietf.org/html/rfc5289">TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)</a>”, RFC&nbsp;5289, <a href="http://dx.doi.org/10.17487/RFC5289">DOI&nbsp;10.17487/RFC5289</a>, August&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5289">http://www.rfc-editor.org/info/rfc5289</a>&gt;.</td></tr><tr><td class="reference"><b id="TLS-EXT">[TLS-EXT]</b></td><td class="top">Eastlake 3rd, D., “<a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>”, RFC&nbsp;6066, <a href="http://dx.doi.org/10.17487/RFC6066">DOI&nbsp;10.17487/RFC6066</a>, January&nbsp;2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6066">http://www.rfc-editor.org/info/rfc6066</a>&gt;.</td></tr><tr><td class="reference"><b id="TLS12">[TLS12]</b></td><td class="top">Dierks, T. and E. Rescorla, “<a href="https://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>”, RFC&nbsp;5246, <a href="http://dx.doi.org/10.17487/RFC5246">DOI&nbsp;10.17487/RFC5246</a>, August&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5246">http://www.rfc-editor.org/info/rfc5246</a>&gt;.</td></tr></table><h3 id="rfc.references.2"><a href="#rfc.section.12.2" id="rfc.section.12.2">12.2</a> Informative References</h3><table><tr><td class="reference"><b id="ALT-SVC">[ALT-SVC]</b></td><td class="top">Nottingham, M., McManus, P., and J. Reschke, “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-06">HTTP Alternative Services</a>”, Work in Progress, draft-ietf-httpbis-alt-svc-06, February&nbsp;2015.</td></tr><tr><td class="reference"><b id="BCP90">[BCP90]</b></td><td class="top">Klyne, G., Nottingham, M., and J. Mogul, “<a href="https://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>”, BCP&nbsp;90, RFC&nbsp;3864, September&nbsp;2004, &lt;<a href="http://www.rfc-editor.org/info/bcp90">http://www.rfc-editor.org/info/bcp90</a>&gt;.</td></tr><tr><td class="reference"><b id="BREACH">[BREACH]</b></td><td class="top">Gluck, Y., Harris, N., and A. Prado, “<a href="http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">BREACH: Reviving the CRIME Attack</a>”, July&nbsp;2013, &lt;<a href="http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf</a>&gt;.</td></tr><tr><td class="reference"><b id="HTML5">[HTML5]</b></td><td class="top">Hickson, I., Berjon, R., Faulkner, S., Leithead, T., Doyle Navara, E., O'Connor, E., and S. Pfeiffer, “<a href="http://www.w3.org/TR/2014/REC-html5-20141028/">HTML5</a>”, W3C Recommendation&nbsp;REC-html5-20141028, October&nbsp;2014, &lt;<a href="http://www.w3.org/TR/2014/REC-html5-20141028/">http://www.w3.org/TR/2014/REC-html5-20141028/</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC3749">[RFC3749]</b></td><td class="top">Hollenbeck, S., “<a href="https://tools.ietf.org/html/rfc3749">Transport Layer Security Protocol Compression Methods</a>”, RFC&nbsp;3749, <a href="http://dx.doi.org/10.17487/RFC3749">DOI&nbsp;10.17487/RFC3749</a>, May&nbsp;2004, &lt;<a href="http://www.rfc-editor.org/info/rfc3749">http://www.rfc-editor.org/info/rfc3749</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC4492">[RFC4492]</b></td><td class="top">Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, “<a href="https://tools.ietf.org/html/rfc4492">Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</a>”, RFC&nbsp;4492, <a href="http://dx.doi.org/10.17487/RFC4492">DOI&nbsp;10.17487/RFC4492</a>, May&nbsp;2006, &lt;<a href="http://www.rfc-editor.org/info/rfc4492">http://www.rfc-editor.org/info/rfc4492</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC6585">[RFC6585]</b></td><td class="top">Nottingham, M. and R. Fielding, “<a href="https://tools.ietf.org/html/rfc6585">Additional HTTP Status Codes</a>”, RFC&nbsp;6585, <a href="http://dx.doi.org/10.17487/RFC6585">DOI&nbsp;10.17487/RFC6585</a>, April&nbsp;2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6585">http://www.rfc-editor.org/info/rfc6585</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7323">[RFC7323]</b></td><td class="top">Borman, D., Braden, B., Jacobson, V., and R. Scheffenegger, Ed., “<a href="https://tools.ietf.org/html/rfc7323">TCP Extensions for High Performance</a>”, RFC&nbsp;7323, <a href="http://dx.doi.org/10.17487/RFC7323">DOI&nbsp;10.17487/RFC7323</a>, September&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7323">http://www.rfc-editor.org/info/rfc7323</a>&gt;.</td></tr><tr><td class="reference"><b id="TALKING">[TALKING]</b></td><td class="top">Huang, L., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “<a href="http://w2spconf.com/2011/papers/websocket.pdf">Talking to Yourself for Fun and Profit</a>”, 2011, &lt;<a href="http://w2spconf.com/2011/papers/websocket.pdf">http://w2spconf.com/2011/papers/websocket.pdf</a>&gt;.</td></tr><tr><td class="reference"><b id="TLSBCP">[TLSBCP]</b></td><td class="top">Sheffer, Y., Holz, R., and P. Saint-Andre, “<a href="https://tools.ietf.org/html/rfc7525">Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>”, BCP&nbsp;195, RFC&nbsp;7525, <a href="http://dx.doi.org/10.17487/RFC7525">DOI&nbsp;10.17487/RFC7525</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7525">http://www.rfc-editor.org/info/rfc7525</a>&gt;.</td></tr></table><div id="BadCipherSuites"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#BadCipherSuites">TLS 1.2 Cipher Suite Black List</a></h2><div id="rfc.section.A.p.1"><p>An HTTP/2 implementation MAY treat the negotiation of any of the following cipher suites with TLS 1.2 as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;5.4.1</a>) of type <a href="#INADEQUATE_SECURITY" class="smpl">INADEQUATE_SECURITY</a>: </p><ul><li>TLS_NULL_WITH_NULL_NULL</li><li>TLS_RSA_WITH_NULL_MD5</li><li>TLS_RSA_WITH_NULL_SHA</li><li>TLS_RSA_EXPORT_WITH_RC4_40_MD5</li><li>TLS_RSA_WITH_RC4_128_MD5</li><li>TLS_RSA_WITH_RC4_128_SHA</li><li>TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5</li><li>TLS_RSA_WITH_IDEA_CBC_SHA</li><li>TLS_RSA_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_RSA_WITH_DES_CBC_SHA</li><li>TLS_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DH_DSS_WITH_DES_CBC_SHA</li><li>TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DH_RSA_WITH_DES_CBC_SHA</li><li>TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DHE_DSS_WITH_DES_CBC_SHA</li><li>TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DHE_RSA_WITH_DES_CBC_SHA</li><li>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DH_anon_EXPORT_WITH_RC4_40_MD5</li><li>TLS_DH_anon_WITH_RC4_128_MD5</li><li>TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA</li><li>TLS_DH_anon_WITH_DES_CBC_SHA</li><li>TLS_DH_anon_WITH_3DES_EDE_CBC_SHA</li><li>TLS_KRB5_WITH_DES_CBC_SHA</li><li>TLS_KRB5_WITH_3DES_EDE_CBC_SHA</li><li>TLS_KRB5_WITH_RC4_128_SHA</li><li>TLS_KRB5_WITH_IDEA_CBC_SHA</li><li>TLS_KRB5_WITH_DES_CBC_MD5</li><li>TLS_KRB5_WITH_3DES_EDE_CBC_MD5</li><li>TLS_KRB5_WITH_RC4_128_MD5</li><li>TLS_KRB5_WITH_IDEA_CBC_MD5</li><li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</li><li>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA</li><li>TLS_KRB5_EXPORT_WITH_RC4_40_SHA</li><li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</li><li>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5</li><li>TLS_KRB5_EXPORT_WITH_RC4_40_MD5</li><li>TLS_PSK_WITH_NULL_SHA</li><li>TLS_DHE_PSK_WITH_NULL_SHA</li><li>TLS_RSA_PSK_WITH_NULL_SHA</li><li>TLS_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_DH_DSS_WITH_AES_128_CBC_SHA</li><li>TLS_DH_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_DHE_DSS_WITH_AES_128_CBC_SHA</li><li>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_DH_anon_WITH_AES_128_CBC_SHA</li><li>TLS_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_DH_DSS_WITH_AES_256_CBC_SHA</li><li>TLS_DH_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_DHE_DSS_WITH_AES_256_CBC_SHA</li><li>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_DH_anon_WITH_AES_256_CBC_SHA</li><li>TLS_RSA_WITH_NULL_SHA256</li><li>TLS_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_RSA_WITH_AES_256_CBC_SHA256</li><li>TLS_DH_DSS_WITH_AES_128_CBC_SHA256</li><li>TLS_DH_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_AES_128_CBC_SHA256</li><li>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA</li><li>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_DH_DSS_WITH_AES_256_CBC_SHA256</li><li>TLS_DH_RSA_WITH_AES_256_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_AES_256_CBC_SHA256</li><li>TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</li><li>TLS_DH_anon_WITH_AES_128_CBC_SHA256</li><li>TLS_DH_anon_WITH_AES_256_CBC_SHA256</li><li>TLS_RSA_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA</li><li>TLS_PSK_WITH_RC4_128_SHA</li><li>TLS_PSK_WITH_3DES_EDE_CBC_SHA</li><li>TLS_PSK_WITH_AES_128_CBC_SHA</li><li>TLS_PSK_WITH_AES_256_CBC_SHA</li><li>TLS_DHE_PSK_WITH_RC4_128_SHA</li><li>TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA</li><li>TLS_DHE_PSK_WITH_AES_128_CBC_SHA</li><li>TLS_DHE_PSK_WITH_AES_256_CBC_SHA</li><li>TLS_RSA_PSK_WITH_RC4_128_SHA</li><li>TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA</li><li>TLS_RSA_PSK_WITH_AES_128_CBC_SHA</li><li>TLS_RSA_PSK_WITH_AES_256_CBC_SHA</li><li>TLS_RSA_WITH_SEED_CBC_SHA</li><li>TLS_DH_DSS_WITH_SEED_CBC_SHA</li><li>TLS_DH_RSA_WITH_SEED_CBC_SHA</li><li>TLS_DHE_DSS_WITH_SEED_CBC_SHA</li><li>TLS_DHE_RSA_WITH_SEED_CBC_SHA</li><li>TLS_DH_anon_WITH_SEED_CBC_SHA</li><li>TLS_RSA_WITH_AES_128_GCM_SHA256</li><li>TLS_RSA_WITH_AES_256_GCM_SHA384</li><li>TLS_DH_RSA_WITH_AES_128_GCM_SHA256</li><li>TLS_DH_RSA_WITH_AES_256_GCM_SHA384</li><li>TLS_DH_DSS_WITH_AES_128_GCM_SHA256</li><li>TLS_DH_DSS_WITH_AES_256_GCM_SHA384</li><li>TLS_DH_anon_WITH_AES_128_GCM_SHA256</li><li>TLS_DH_anon_WITH_AES_256_GCM_SHA384</li><li>TLS_PSK_WITH_AES_128_GCM_SHA256</li><li>TLS_PSK_WITH_AES_256_GCM_SHA384</li><li>TLS_RSA_PSK_WITH_AES_128_GCM_SHA256</li><li>TLS_RSA_PSK_WITH_AES_256_GCM_SHA384</li><li>TLS_PSK_WITH_AES_128_CBC_SHA256</li><li>TLS_PSK_WITH_AES_256_CBC_SHA384</li><li>TLS_PSK_WITH_NULL_SHA256</li><li>TLS_PSK_WITH_NULL_SHA384</li><li>TLS_DHE_PSK_WITH_AES_128_CBC_SHA256</li><li>TLS_DHE_PSK_WITH_AES_256_CBC_SHA384</li><li>TLS_DHE_PSK_WITH_NULL_SHA256</li><li>TLS_DHE_PSK_WITH_NULL_SHA384</li><li>TLS_RSA_PSK_WITH_AES_128_CBC_SHA256</li><li>TLS_RSA_PSK_WITH_AES_256_CBC_SHA384</li><li>TLS_RSA_PSK_WITH_NULL_SHA256</li><li>TLS_RSA_PSK_WITH_NULL_SHA384</li><li>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256</li><li>TLS_EMPTY_RENEGOTIATION_INFO_SCSV</li><li>TLS_ECDH_ECDSA_WITH_NULL_SHA</li><li>TLS_ECDH_ECDSA_WITH_RC4_128_SHA</li><li>TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA</li><li>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA</li><li>TLS_ECDHE_ECDSA_WITH_NULL_SHA</li><li>TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</li><li>TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</li><li>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</li><li>TLS_ECDH_RSA_WITH_NULL_SHA</li><li>TLS_ECDH_RSA_WITH_RC4_128_SHA</li><li>TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_ECDHE_RSA_WITH_NULL_SHA</li><li>TLS_ECDHE_RSA_WITH_RC4_128_SHA</li><li>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_ECDH_anon_WITH_NULL_SHA</li><li>TLS_ECDH_anon_WITH_RC4_128_SHA</li><li>TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDH_anon_WITH_AES_128_CBC_SHA</li><li>TLS_ECDH_anon_WITH_AES_256_CBC_SHA</li><li>TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA</li><li>TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA</li><li>TLS_SRP_SHA_WITH_AES_128_CBC_SHA</li><li>TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA</li><li>TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA</li><li>TLS_SRP_SHA_WITH_AES_256_CBC_SHA</li><li>TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA</li><li>TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA</li><li>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256</li><li>TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384</li><li>TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256</li><li>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</li><li>TLS_ECDHE_PSK_WITH_RC4_128_SHA</li><li>TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA</li><li>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA</li><li>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA</li><li>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256</li><li>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384</li><li>TLS_ECDHE_PSK_WITH_NULL_SHA</li><li>TLS_ECDHE_PSK_WITH_NULL_SHA256</li><li>TLS_ECDHE_PSK_WITH_NULL_SHA384</li><li>TLS_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DH_anon_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DH_anon_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384</li><li>TLS_RSA_WITH_ARIA_128_GCM_SHA256</li><li>TLS_RSA_WITH_ARIA_256_GCM_SHA384</li><li>TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256</li><li>TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384</li><li>TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256</li><li>TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384</li><li>TLS_DH_anon_WITH_ARIA_128_GCM_SHA256</li><li>TLS_DH_anon_WITH_ARIA_256_GCM_SHA384</li><li>TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256</li><li>TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384</li><li>TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256</li><li>TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384</li><li>TLS_PSK_WITH_ARIA_128_CBC_SHA256</li><li>TLS_PSK_WITH_ARIA_256_CBC_SHA384</li><li>TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256</li><li>TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384</li><li>TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256</li><li>TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384</li><li>TLS_PSK_WITH_ARIA_128_GCM_SHA256</li><li>TLS_PSK_WITH_ARIA_256_GCM_SHA384</li><li>TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256</li><li>TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384</li><li>TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256</li><li>TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384</li><li>TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256</li><li>TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384</li><li>TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</li><li>TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</li><li>TLS_RSA_WITH_AES_128_CCM</li><li>TLS_RSA_WITH_AES_256_CCM</li><li>TLS_RSA_WITH_AES_128_CCM_8</li><li>TLS_RSA_WITH_AES_256_CCM_8</li><li>TLS_PSK_WITH_AES_128_CCM</li><li>TLS_PSK_WITH_AES_256_CCM</li><li>TLS_PSK_WITH_AES_128_CCM_8</li><li>TLS_PSK_WITH_AES_256_CCM_8</li></ul></div><div class="alert alert-warning"><div id="rfc.section.A.p.2"><p><b>Note:</b> This list was assembled from the set of registered TLS cipher suites at the time of writing. This list includes those cipher suites that do not offer an ephemeral key exchange and those that are based on the TLS null, stream, or block cipher type (as defined in <a href="https://tools.ietf.org/html/rfc5246#section-6.2.3">Section 6.2.3</a> of <a href="#TLS12"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite></a>). Additional cipher suites with these properties could be defined; these would not be explicitly prohibited.</p></div></div></div><div><h2 id="rfc.section.unnumbered-1">Acknowledgements</h2><div id="rfc.section.unnumbered-1.p.1"><p>This document includes substantial input from the following individuals: </p><ul><li>Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang, and Jonathan Leighton (SPDY contributors).</li><li>Gabriel Montenegro and Willy Tarreau (Upgrade mechanism).</li><li>William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto Peon, and Rob Trace (Flow control).</li><li>Mike Bishop (Extensibility).</li><li>Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike Bishop, and Herve Ruellan (Substantial editorial contributions).</li><li>Kari Hurtta, Tatsuhiro Tsujikawa, Greg Wilkins, Poul-Henning Kamp, and Jonathan Thackray.</li><li>Alexey Melnikov, who was an editor of this document in 2013.</li></ul></div><div id="rfc.section.unnumbered-1.p.2"><p>A substantial proportion of Martin's contribution was supported by Microsoft during his employment there.</p></div><div id="rfc.section.unnumbered-1.p.3"><p>The Japanese HTTP/2 community provided invaluable contributions, including a number of implementations as well as numerous technical and editorial contributions.</p></div></div><div class="avoidbreakinside"><h2 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h2><p><b>Mike Belshe</b><br>BitGo<br>Email: mike@belshe.com</p><p><b>Roberto Peon</b><br>Google, Inc<br>Email: fenix@google.com</p><p><b>Martin Thomson</b>
      (editor)
    <br>Mozilla<br>331 E Evelyn Street<br>Mountain View, CA&nbsp;94041<br>United States<br>Email: martin.thomson@gmail.com</p></div></div></div></div><script src="/bower_components/jquery/dist/jquery.min.js"></script><script src="/bower_components/bootstrap/dist/js/bootstrap.min.js"></script></body></html>