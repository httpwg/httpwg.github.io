<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.6.2 (Ruby 3.1.2) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-quic-qpack-latest" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="QPACK">QPACK: Header Compression for HTTP/3</title>
      <seriesInfo name="RFC" value="9204"/>
    <author initials="C." surname="Krasic" fullname="Charles 'Buck' Krasic">
      <organization>Netflix</organization>
      <address>
        <email>ckrasic@netflix.com</email>
      </address>
    </author>
    <author initials="M." surname="Bishop" fullname="Mike Bishop">
      <organization>Akamai Technologies</organization>
      <address>
        <email>mbishop@evequefou.be</email>
      </address>
    </author>
    <author initials="A." surname="Frindell" fullname="Alan Frindell" role="editor">
      <organization>Facebook</organization>
      <address>
        <email>afrind@fb.com</email>
      </address>
    </author>

    <date />

    <area>Transport</area>
    <workgroup>QUIC</workgroup>
    

    <abstract>


<t>This specification defines QPACK, a compression format for efficiently
representing HTTP fields, to be used in HTTP/3. This is a variation of HPACK
compression that seeks to reduce head-of-line blocking.</t>



    </abstract>



  </front>

  <middle>


<section anchor="introduction"><name>Introduction</name>

<t>The QUIC transport protocol (<xref target="QUIC-TRANSPORT"/>) is designed to support HTTP
semantics, and its design subsumes many of the features of HTTP/2
(<xref target="RFC7540"/>). HTTP/2 uses HPACK (<xref target="RFC7541"/>) for compression of the header
and trailer sections.  If HPACK were used for HTTP/3 (<xref target="HTTP3"/>), it would
induce head-of-line blocking for field sections due to built-in assumptions of a
total ordering across frames on all streams.</t>

<t>QPACK reuses core concepts from HPACK, but is redesigned to allow correctness in
the presence of out-of-order delivery, with flexibility for implementations to
balance between resilience against head-of-line blocking and optimal compression
ratio.  The design goals are to closely approach the compression ratio of HPACK
with substantially less head-of-line blocking under the same loss conditions.</t>

<section anchor="conventions-and-definitions"><name>Conventions and Definitions</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
when, and only when, they appear in all capitals, as shown here.</t>

<t>Definitions of terms that are used in this document:</t>

<dl>
  <dt>HTTP fields:</dt>
  <dd>
    <t>Metadata sent as part of an HTTP message.  The term encompasses both header
and trailer fields. Colloquially, the term "headers" has often been used to
refer to HTTP header fields and trailer fields; this document uses "fields"
for generality.</t>
  </dd>
  <dt>HTTP field line:</dt>
  <dd>
    <t>A name-value pair sent as part of an HTTP field section. See Sections <xref target="SEMANTICS" section="6.3" sectionFormat="bare"/> and <xref target="SEMANTICS" section="6.5" sectionFormat="bare"/> of <xref target="SEMANTICS"/>.</t>
  </dd>
  <dt>HTTP field value:</dt>
  <dd>
    <t>Data associated with a field name, composed from all field line values with
that field name in that section, concatenated together with
comma separators.</t>
  </dd>
  <dt>Field section:</dt>
  <dd>
    <t>An ordered collection of HTTP field lines associated with an HTTP message.  A
field section can contain multiple field lines with the same name.  It can
also contain duplicate field lines.  An HTTP message can include both header
and trailer sections.</t>
  </dd>
  <dt>Representation:</dt>
  <dd>
    <t>An instruction that represents a field line, possibly by reference to the
dynamic and static tables.</t>
  </dd>
  <dt>Encoder:</dt>
  <dd>
    <t>An implementation that encodes field sections.</t>
  </dd>
  <dt>Decoder:</dt>
  <dd>
    <t>An implementation that decodes encoded field sections.</t>
  </dd>
  <dt>Absolute Index:</dt>
  <dd>
    <t>A unique index for each entry in the dynamic table.</t>
  </dd>
  <dt>Base:</dt>
  <dd>
    <t>A reference point for relative and post-base indices.  Representations that
reference dynamic table entries are relative to a Base.</t>
  </dd>
  <dt>Insert Count:</dt>
  <dd>
    <t>The total number of entries inserted in the dynamic table.</t>
  </dd>
</dl>

<t>QPACK is a name, not an acronym.</t>

</section>
<section anchor="notational-conventions"><name>Notational Conventions</name>

<t>Diagrams use the format described in <xref section="3.1" sectionFormat="of" target="RFC2360"/>, with the
following additional conventions:</t>

<dl>
  <dt>x (A)</dt>
  <dd>
    <t>Indicates that x is A bits long</t>
  </dd>
  <dt>x (A+)</dt>
  <dd>
    <t>Indicates that x uses the prefixed integer encoding defined in
<xref target="prefixed-integers"/>, beginning with an A-bit prefix.</t>
  </dd>
  <dt>x ...</dt>
  <dd>
    <t>Indicates that x is variable-length and extends to the end of the region.</t>
  </dd>
</dl>

</section>
</section>
<section anchor="compression-process-overview"><name>Compression Process Overview</name>

<t>Like HPACK, QPACK uses two tables for associating field lines ("headers") to
indices.  The static table (<xref target="header-table-static"/>) is predefined and contains
common header field lines (some of them with an empty value).  The dynamic table
(<xref target="header-table-dynamic"/>) is built up over the course of the connection and can
be used by the encoder to index both header and trailer field lines in the
encoded field sections.</t>

<t>QPACK defines unidirectional streams for sending instructions from encoder to
decoder and vice versa.</t>

<section anchor="encoder"><name>Encoder</name>

<t>An encoder converts a header or trailer section into a series of representations
by emitting either an indexed or a literal representation for each field line in
the list; see <xref target="field-line-representations"/>.  Indexed representations achieve
high compression by replacing the literal name and possibly the value with an
index to either the static or dynamic table.  References to the static table and
literal representations do not require any dynamic state and never risk
head-of-line blocking.  References to the dynamic table risk head-of-line
blocking if the encoder has not received an acknowledgment indicating the entry
is available at the decoder.</t>

<t>An encoder MAY insert any entry in the dynamic table it chooses; it is not
limited to field lines it is compressing.</t>

<t>QPACK preserves the ordering of field lines within each field section.  An
encoder MUST emit field representations in the order they appear in the input
field section.</t>

<t>QPACK is designed to contain the more complex state tracking to the encoder,
while the decoder is relatively simple.</t>

<section anchor="blocked-insertion"><name>Limits on Dynamic Table Insertions</name>

<t>Inserting entries into the dynamic table might not be possible if the table
contains entries that cannot be evicted.</t>

<t>A dynamic table entry cannot be evicted immediately after insertion, even if it
has never been referenced. Once the insertion of a dynamic table entry has been
acknowledged and there are no outstanding references to the entry in
unacknowledged representations, the entry becomes evictable.  Note that
references on the encoder stream never preclude the eviction of an entry,
because those references are guaranteed to be processed before the instruction
evicting the entry.</t>

<t>If the dynamic table does not contain enough room for a new entry without
evicting other entries, and the entries that would be evicted are not
evictable, the encoder MUST NOT insert that entry into the dynamic table
(including duplicates of existing entries). In order to avoid this, an encoder
that uses the dynamic table has to keep track of each dynamic table entry
referenced by each field section until those representations are acknowledged by
the decoder; see <xref target="header-acknowledgment"/>.</t>

<section anchor="avoiding-prohibited-insertions"><name>Avoiding Prohibited Insertions</name>

<t>To ensure that the encoder is not prevented from adding new entries, the encoder
can avoid referencing entries that are close to eviction.  Rather than
reference such an entry, the encoder can emit a Duplicate instruction
(<xref target="duplicate"/>), and reference the duplicate instead.</t>

<t>Determining which entries are too close to eviction to reference is an encoder
preference.  One heuristic is to target a fixed amount of available space in the
dynamic table: either unused space or space that can be reclaimed by evicting
non-blocking entries.  To achieve this, the encoder can maintain a draining
index, which is the smallest absolute index (<xref target="indexing"/>) in the dynamic table
that it will emit a reference for.  As new entries are inserted, the encoder
increases the draining index to maintain the section of the table that it will
not reference.  If the encoder does not create new references to entries with an
absolute index lower than the draining index, the number of unacknowledged
references to those entries will eventually become zero, allowing them to be
evicted.</t>

<figure title="Draining Dynamic Table Entries" anchor="fig-draining-index"><sourcecode type="drawing"><![CDATA[
             <-- Newer Entries          Older Entries -->
               (Larger Indicies)      (Smaller Indicies)
   +--------+---------------------------------+----------+
   | Unused |          Referenceable          | Draining |
   | Space  |             Entries             | Entries  |
   +--------+---------------------------------+----------+
            ^                                 ^          ^
            |                                 |          |
      Insertion Point                 Draining Index  Dropping
                                                       Point
]]></sourcecode></figure>

</section>
</section>
<section anchor="blocked-streams"><name>Blocked Streams</name>

<t>Because QUIC does not guarantee order between data on different streams, a
decoder might encounter a representation that references a dynamic table entry
that it has not yet received.</t>

<t>Each encoded field section contains a Required Insert Count (<xref target="header-prefix"/>),
the lowest possible value for the Insert Count with which the field section can
be decoded. For a field section encoded using references to the dynamic table,
the Required Insert Count is one larger than the largest absolute index of all
referenced dynamic table entries. For a field section encoded with no references
to the dynamic table, the Required Insert Count is zero.</t>

<t>When the decoder receives an encoded field section with a Required Insert Count
greater than its own Insert Count, the stream cannot be processed immediately,
and is considered "blocked"; see <xref target="blocked-decoding"/>.</t>

<t>The decoder specifies an upper bound on the number of streams that can be
blocked using the SETTINGS_QPACK_BLOCKED_STREAMS setting; see <xref target="configuration"/>.
An encoder MUST limit the number of streams that could become blocked to the
value of SETTINGS_QPACK_BLOCKED_STREAMS at all times. If a decoder encounters
more blocked streams than it promised to support, it MUST treat this as a
connection error of type QPACK_DECOMPRESSION_FAILED.</t>

<t>Note that the decoder might not become blocked on every stream that risks
becoming blocked.</t>

<t>An encoder can decide whether to risk having a stream become blocked. If
permitted by the value of SETTINGS_QPACK_BLOCKED_STREAMS, compression efficiency
can often be improved by referencing dynamic table entries that are still in
transit, but if there is loss or reordering the stream can become blocked at the
decoder.  An encoder can avoid the risk of blocking by only referencing dynamic
table entries that have been acknowledged, but this could mean using literals.
Since literals make the encoded field section larger, this can result in the
encoder becoming blocked on congestion or flow control limits.</t>

</section>
<section anchor="avoiding-flow-control-deadlocks"><name>Avoiding Flow Control Deadlocks</name>

<t>Writing instructions on streams that are limited by flow control can produce
deadlocks.</t>

<t>A decoder might stop issuing flow control credit on the stream that carries an
encoded field section until the necessary updates are received on the encoder
stream. If the granting of flow control credit on the encoder stream (or the
connection as a whole) depends on the consumption and release of data on the
stream carrying the encoded field section, a deadlock might result.</t>

<t>More generally, a stream containing a large instruction can become deadlocked if
the decoder withholds flow control credit until the instruction is completely
received.</t>

<t>To avoid these deadlocks, an encoder SHOULD NOT write an instruction unless
sufficient stream and connection flow control credit is available for the entire
instruction.</t>

</section>
<section anchor="known-received-count"><name>Known Received Count</name>

<t>The Known Received Count is the total number of dynamic table insertions and
duplications acknowledged by the decoder.  The encoder tracks the Known Received
Count in order to identify which dynamic table entries can be referenced without
potentially blocking a stream.  The decoder tracks the Known Received Count in
order to be able to send Insert Count Increment instructions.</t>

<t>A Section Acknowledgment instruction (<xref target="header-acknowledgment"/>) implies that
the decoder has received all dynamic table state necessary to decode the field
section.  If the Required Insert Count of the acknowledged field section is
greater than the current Known Received Count, Known Received Count is updated
to that Required Insert Count value.</t>

<t>An Insert Count Increment instruction (<xref target="insert-count-increment"/>) increases the
Known Received Count by its Increment parameter.  See <xref target="new-table-entries"/> for
guidance.</t>

</section>
</section>
<section anchor="decoder"><name>Decoder</name>

<t>As in HPACK, the decoder processes a series of representations and emits the
corresponding field sections. It also processes instructions received on the
encoder stream that modify the dynamic table.  Note that encoded field sections
and encoder stream instructions arrive on separate streams.  This is unlike
HPACK, where encoded field sections (header blocks) can contain instructions
that modify the dynamic table, and there is no dedicated stream of HPACK
instructions.</t>

<t>The decoder MUST emit field lines in the order their representations appear in
the encoded field section.</t>

<section anchor="blocked-decoding"><name>Blocked Decoding</name>

<t>Upon receipt of an encoded field section, the decoder examines the Required
Insert Count. When the Required Insert Count is less than or equal to the
decoder's Insert Count, the field section can be processed immediately.
Otherwise, the stream on which the field section was received becomes blocked.</t>

<t>While blocked, encoded field section data SHOULD remain in the blocked stream's
flow control window. This data is unusable until the stream becomes unblocked,
and releasing the flow control prematurely makes the decoder vulnerable to
memory exhaustion attacks. A stream becomes unblocked when the Insert Count
becomes greater than or equal to the Required Insert Count for all encoded
field sections the decoder has started reading from the stream.</t>

<t>When processing encoded field sections, the decoder expects the Required Insert
Count to equal the lowest possible value for the Insert Count with which the
field section can be decoded, as prescribed in <xref target="blocked-streams"/>. If it
encounters a Required Insert Count smaller than expected, it MUST treat this as
a connection error of type QPACK_DECOMPRESSION_FAILED; see
<xref target="invalid-references"/>. If it encounters a Required Insert Count larger than
expected, it MAY treat this as a connection error of type
QPACK_DECOMPRESSION_FAILED.</t>

</section>
<section anchor="state-synchronization"><name>State Synchronization</name>

<t>The decoder signals the following events by emitting decoder instructions
(<xref target="decoder-instructions"/>) on the decoder stream.</t>

<section anchor="completed-processing-of-a-field-section"><name>Completed Processing of a Field Section</name>

<t>After the decoder finishes decoding a field section encoded using
representations containing dynamic table references, it MUST emit a Section
Acknowledgment instruction (<xref target="header-acknowledgment"/>).  A stream may carry
multiple field sections in the case of intermediate responses, trailers, and
pushed requests.  The encoder interprets each Section Acknowledgment
instruction as acknowledging the earliest unacknowledged field section
containing dynamic table references sent on the given stream.</t>

</section>
<section anchor="abandonment-of-a-stream"><name>Abandonment of a Stream</name>

<t>When an endpoint receives a stream reset before the end of a stream or before
all encoded field sections are processed on that stream, or when it abandons
reading of a stream, it generates a Stream Cancellation instruction; see
<xref target="stream-cancellation"/>.  This signals to the encoder that all references to the
dynamic table on that stream are no longer outstanding.  A decoder with a
maximum dynamic table capacity (<xref target="maximum-dynamic-table-capacity"/>) equal to
zero MAY omit sending Stream Cancellations, because the encoder cannot have any
dynamic table references.  An encoder cannot infer from this instruction that
any updates to the dynamic table have been received.</t>

<t>The Section Acknowledgment and Stream Cancellation instructions permit the
encoder to remove references to entries in the dynamic table.  When an entry
with absolute index lower than the Known Received Count has zero references,
then it is considered evictable; see <xref target="blocked-insertion"/>.</t>

</section>
<section anchor="new-table-entries"><name>New Table Entries</name>

<t>After receiving new table entries on the encoder stream, the decoder chooses
when to emit Insert Count Increment instructions; see
<xref target="insert-count-increment"/>. Emitting this instruction after adding each new
dynamic table entry will provide the timeliest feedback to the encoder, but
could be redundant with other decoder feedback. By delaying an Insert Count
Increment instruction, the decoder might be able to coalesce multiple Insert
Count Increment instructions, or replace them entirely with Section
Acknowledgments; see <xref target="header-acknowledgment"/>. However, delaying too long
may lead to compression inefficiencies if the encoder waits for an entry to be
acknowledged before using it.</t>

</section>
</section>
<section anchor="invalid-references"><name>Invalid References</name>

<t>If the decoder encounters a reference in a field line representation to a
dynamic table entry that has already been evicted or that has an absolute
index greater than or equal to the declared Required Insert Count
(<xref target="header-prefix"/>), it MUST treat this as a connection error of type
QPACK_DECOMPRESSION_FAILED.</t>

<t>If the decoder encounters a reference in an encoder instruction to a dynamic
table entry that has already been evicted, it MUST treat this as a connection
error of type QPACK_ENCODER_STREAM_ERROR.</t>

</section>
</section>
</section>
<section anchor="reference-tables"><name>Reference Tables</name>

<t>Unlike in HPACK, entries in the QPACK static and dynamic tables are addressed
separately.  The following sections describe how entries in each table are
addressed.</t>

<section anchor="header-table-static"><name>Static Table</name>

<t>The static table consists of a predefined list of field lines, each of which has
a fixed index over time.  Its entries are defined in <xref target="static-table"/>.</t>

<t>All entries in the static table have a name and a value.  However, values can be
empty (that is, have a length of 0).  Each entry is identified by a unique
index.</t>

<t>Note that the QPACK static table is indexed from 0, whereas the HPACK static
table is indexed from 1.</t>

<t>When the decoder encounters an invalid static table index in a field line
representation it MUST treat this as a connection error of type
QPACK_DECOMPRESSION_FAILED.  If this index is received on the encoder stream,
this MUST be treated as a connection error of type QPACK_ENCODER_STREAM_ERROR.</t>

</section>
<section anchor="header-table-dynamic"><name>Dynamic Table</name>

<t>The dynamic table consists of a list of field lines maintained in first-in,
first-out order.  A QPACK encoder and decoder share a dynamic table that is
initially empty.  The encoder adds entries to the dynamic table and sends them
to the decoder via instructions on the encoder stream; see
<xref target="encoder-instructions"/>.</t>

<t>The dynamic table can contain duplicate entries (i.e., entries with the same
name and same value).  Therefore, duplicate entries MUST NOT be treated as an
error by the decoder.</t>

<t>Dynamic table entries can have empty values.</t>

<section anchor="dynamic-table-size"><name>Dynamic Table Size</name>

<t>The size of the dynamic table is the sum of the size of its entries.</t>

<t>The size of an entry is the sum of its name's length in bytes, its value's
length in bytes, and 32 additional bytes.  The size of an entry is calculated
using the length of its name and value without Huffman encoding applied.</t>

</section>
<section anchor="eviction"><name>Dynamic Table Capacity and Eviction</name>

<t>The encoder sets the capacity of the dynamic table, which serves as the upper
limit on its size.  The initial capacity of the dynamic table is zero.  The
encoder sends a Set Dynamic Table Capacity instruction
(<xref target="set-dynamic-capacity"/>) with a non-zero capacity to begin using the dynamic
table.</t>

<t>Before a new entry is added to the dynamic table, entries are evicted from the
end of the dynamic table until the size of the dynamic table is less than or
equal to (table capacity - size of new entry). The encoder MUST NOT cause a
dynamic table entry to be evicted unless that entry is evictable; see
<xref target="blocked-insertion"/>.  The new entry is then added to the table.  It is an
error if the encoder attempts to add an entry that is larger than the dynamic
table capacity; the decoder MUST treat this as a connection error of type
QPACK_ENCODER_STREAM_ERROR.</t>

<t>A new entry can reference an entry in the dynamic table that will be evicted
when adding this new entry into the dynamic table.  Implementations are
cautioned to avoid deleting the referenced name or value if the referenced entry
is evicted from the dynamic table prior to inserting the new entry.</t>

<t>Whenever the dynamic table capacity is reduced by the encoder
(<xref target="set-dynamic-capacity"/>), entries are evicted from the end of the dynamic
table until the size of the dynamic table is less than or equal to the new table
capacity.  This mechanism can be used to completely clear entries from the
dynamic table by setting a capacity of 0, which can subsequently be restored.</t>

</section>
<section anchor="maximum-dynamic-table-capacity"><name>Maximum Dynamic Table Capacity</name>

<t>To bound the memory requirements of the decoder, the decoder limits the maximum
value the encoder is permitted to set for the dynamic table capacity.  In
HTTP/3, this limit is determined by the value of
SETTINGS_QPACK_MAX_TABLE_CAPACITY sent by the decoder; see <xref target="configuration"/>.
The encoder MUST NOT set a dynamic table capacity that exceeds this maximum, but
it can choose to use a lower dynamic table capacity; see
<xref target="set-dynamic-capacity"/>.</t>

<t>For clients using 0-RTT data in HTTP/3, the server's maximum table capacity is
the remembered value of the setting, or zero if the value was not previously
sent.  When the client's 0-RTT value of the SETTING is zero, the server MAY set
it to a non-zero value in its SETTINGS frame. If the remembered value is
non-zero, the server MUST send the same non-zero value in its SETTINGS frame. If
it specifies any other value, or omits SETTINGS_QPACK_MAX_TABLE_CAPACITY from
SETTINGS, the encoder must treat this as a connection error of type
QPACK_DECODER_STREAM_ERROR.</t>

<t>For HTTP/3 servers and HTTP/3 clients when 0-RTT is not attempted or is
rejected, the maximum table capacity is 0 until the encoder processes a SETTINGS
frame with a non-zero value of SETTINGS_QPACK_MAX_TABLE_CAPACITY.</t>

<t>When the maximum table capacity is zero, the encoder MUST NOT insert entries
into the dynamic table, and MUST NOT send any encoder instructions on the
encoder stream.</t>

</section>
<section anchor="indexing"><name>Absolute Indexing</name>

<t>Each entry possesses an absolute index that is fixed for the lifetime of that
entry. The first entry inserted has an absolute index of 0; indices increase
by one with each insertion.</t>

</section>
<section anchor="relative-indexing"><name>Relative Indexing</name>

<t>Relative indices begin at zero and increase in the opposite direction from the
absolute index.  Determining which entry has a relative index of 0 depends on
the context of the reference.</t>

<t>In encoder instructions (<xref target="encoder-instructions"/>), a relative index of 0
refers to the most recently inserted value in the dynamic table.  Note that this
means the entry referenced by a given relative index will change while
interpreting instructions on the encoder stream.</t>

<figure title="Example Dynamic Table Indexing - Encoder Stream"><sourcecode type="drawing"><![CDATA[
      +-----+---------------+-------+
      | n-1 |      ...      |   d   |  Absolute Index
      + - - +---------------+ - - - +
      |  0  |      ...      | n-d-1 |  Relative Index
      +-----+---------------+-------+
      ^                             |
      |                             V
Insertion Point               Dropping Point

n = count of entries inserted
d = count of entries dropped
]]></sourcecode></figure>

<t>Unlike in encoder instructions, relative indices in field line representations
are relative to the Base at the beginning of the encoded field section; see
<xref target="header-prefix"/>. This ensures that references are stable even if encoded field
sections and dynamic table updates are processed out of order.</t>

<t>In a field line representation, a relative index of 0 refers to the entry with
absolute index equal to Base - 1.</t>

<figure title="Example Dynamic Table Indexing - Relative Index in Representation"><sourcecode type="drawing"><![CDATA[
               Base
                |
                V
    +-----+-----+-----+-----+-------+
    | n-1 | n-2 | n-3 | ... |   d   |  Absolute Index
    +-----+-----+  -  +-----+   -   +
                |  0  | ... | n-d-3 |  Relative Index
                +-----+-----+-------+

n = count of entries inserted
d = count of entries dropped
In this example, Base = n - 2
]]></sourcecode></figure>

</section>
<section anchor="post-base"><name>Post-Base Indexing</name>

<t>Post-Base indices are used in field line representations for entries with
absolute indices greater than or equal to Base, starting at 0 for the entry with
absolute index equal to Base, and increasing in the same direction as the
absolute index.</t>

<t>Post-Base indices allow an encoder to process a field section in a single pass
and include references to entries added while processing this (or other) field
sections.</t>

<figure title="Example Dynamic Table Indexing - Post-Base Index in Representation"><sourcecode type="drawing"><![CDATA[
               Base
                |
                V
    +-----+-----+-----+-----+-----+
    | n-1 | n-2 | n-3 | ... |  d  |  Absolute Index
    +-----+-----+-----+-----+-----+
    |  1  |  0  |                    Post-Base Index
    +-----+-----+

n = count of entries inserted
d = count of entries dropped
In this example, Base = n - 2
]]></sourcecode></figure>

</section>
</section>
</section>
<section anchor="wire-format"><name>Wire Format</name>

<section anchor="primitives"><name>Primitives</name>

<section anchor="prefixed-integers"><name>Prefixed Integers</name>

<t>The prefixed integer from <xref section="5.1" sectionFormat="of" target="RFC7541"/> is used heavily throughout
this document.  The format from <xref target="RFC7541"/> is used unmodified.  Note, however,
that QPACK uses some prefix sizes not actually used in HPACK.</t>

<t>QPACK implementations MUST be able to decode integers up to and including 62
bits long.</t>

</section>
<section anchor="string-literals"><name>String Literals</name>

<t>The string literal defined by <xref section="5.2" sectionFormat="of" target="RFC7541"/> is also used
throughout. This string format includes optional Huffman encoding.</t>

<t>HPACK defines string literals to begin on a byte boundary.  They begin with a
single bit flag, denoted as 'H' in this document (indicating whether the string
is Huffman-coded), followed by the Length encoded as a 7-bit prefix integer, and
finally Length bytes of data. When Huffman encoding is enabled, the Huffman
table from <xref section="B" sectionFormat="of" target="RFC7541"/> is used without modification and Length
indicates the size of the string after encoding.</t>

<t>This document expands the definition of string literals by permitting them to
begin other than on a byte boundary.  An "N-bit prefix string literal" begins
mid-byte, with the first (8-N) bits allocated to a previous field. The string
uses one bit for the Huffman flag, followed by the Length encoded as an
(N-1)-bit prefix integer.  The prefix size, N, can have a value between 2 and 8
inclusive. The remainder of the string literal is unmodified.</t>

<t>A string literal without a prefix length noted is an 8-bit prefix string literal
and follows the definitions in <xref target="RFC7541"/> without modification.</t>

</section>
</section>
<section anchor="enc-dec-stream-def"><name>Encoder and Decoder Streams</name>

<t>QPACK defines two unidirectional stream types:</t>

<t><list style="symbols">
  <t>An encoder stream is a unidirectional stream of type 0x02.
It carries an unframed sequence of encoder instructions from encoder
to decoder.</t>
  <t>A decoder stream is a unidirectional stream of type 0x03.
It carries an unframed sequence of decoder instructions from decoder
to encoder.</t>
</list></t>

<t>HTTP/3 endpoints contain a QPACK encoder and decoder. Each endpoint MUST
initiate at most one encoder stream and at most one decoder stream. Receipt of a
second instance of either stream type MUST be treated as a connection error of
type H3_STREAM_CREATION_ERROR.</t>

<t>These streams MUST NOT be closed. Closure of either unidirectional stream type
MUST be treated as a connection error of type H3_CLOSED_CRITICAL_STREAM.</t>

<t>An endpoint MAY avoid creating an encoder stream if it will not be used (for
example if its encoder does not wish to use the dynamic table, or if the maximum
size of the dynamic table permitted by the peer is zero).</t>

<t>An endpoint MAY avoid creating a decoder stream if its decoder sets the maximum
capacity of the dynamic table to zero.</t>

<t>An endpoint MUST allow its peer to create an encoder stream and a decoder stream
even if the connection's settings prevent their use.</t>

</section>
<section anchor="encoder-instructions"><name>Encoder Instructions</name>

<t>An encoder sends encoder instructions on the encoder stream to set the capacity
of the dynamic table and add dynamic table entries.  Instructions adding table
entries can use existing entries to avoid transmitting redundant information.
The name can be transmitted as a reference to an existing entry in the static or
the dynamic table or as a string literal.  For entries that already exist in
the dynamic table, the full entry can also be used by reference, creating a
duplicate entry.</t>

<section anchor="set-dynamic-capacity"><name>Set Dynamic Table Capacity</name>

<t>An encoder informs the decoder of a change to the dynamic table capacity using
an instruction that starts with the '001' 3-bit pattern.  This is followed
by the new dynamic table capacity represented as an integer with a 5-bit prefix;
see <xref target="prefixed-integers"/>.</t>

<figure title="Set Dynamic Table Capacity" anchor="fig-set-capacity"><sourcecode type="drawing"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Capacity (5+)   |
+---+---+---+-------------------+
]]></sourcecode></figure>

<t>The new capacity MUST be lower than or equal to the limit described in
<xref target="maximum-dynamic-table-capacity"/>.  In HTTP/3, this limit is the value of the
SETTINGS_QPACK_MAX_TABLE_CAPACITY parameter (<xref target="configuration"/>) received from
the decoder.  The decoder MUST treat a new dynamic table capacity value that
exceeds this limit as a connection error of type QPACK_ENCODER_STREAM_ERROR.</t>

<t>Reducing the dynamic table capacity can cause entries to be evicted; see
<xref target="eviction"/>.  This MUST NOT cause the eviction of entries that are not
evictable; see <xref target="blocked-insertion"/>.  Changing the capacity of the dynamic
table is not acknowledged as this instruction does not insert an entry.</t>

</section>
<section anchor="insert-with-name-reference"><name>Insert With Name Reference</name>

<t>An encoder adds an entry to the dynamic table where the field name matches the
field name of an entry stored in the static or the dynamic table using an
instruction that starts with the '1' 1-bit pattern.  The second ('T') bit
indicates whether the reference is to the static or dynamic table. The 6-bit
prefix integer (<xref target="prefixed-integers"/>) that follows is used to locate the table
entry for the field name.  When T=1, the number represents the static table
index; when T=0, the number is the relative index of the entry in the dynamic
table.</t>

<t>The field name reference is followed by the field value represented as a string
literal; see <xref target="string-literals"/>.</t>

<figure title="Insert Field Line -- Indexed Name"><sourcecode type="drawing"><![CDATA[
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 | T |    Name Index (6+)    |
   +---+---+-----------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
]]></sourcecode></figure>

</section>
<section anchor="insert-with-literal-name"><name>Insert With Literal Name</name>

<t>An encoder adds an entry to the dynamic table where both the field name and the
field value are represented as string literals using an instruction that starts
with the '01' 2-bit pattern.</t>

<t>This is followed by the name represented as a 6-bit prefix string literal, and
the value represented as an 8-bit prefix string literal; see
<xref target="string-literals"/>.</t>

<figure title="Insert Field Line -- New Name"><sourcecode type="drawing"><![CDATA[
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | H | Name Length (5+)  |
   +---+---+---+-------------------+
   |  Name String (Length bytes)   |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
]]></sourcecode></figure>

</section>
<section anchor="duplicate"><name>Duplicate</name>

<t>An encoder duplicates an existing entry in the dynamic table using an
instruction that starts with the '000' 3-bit pattern.  This is followed by
the relative index of the existing entry represented as an integer with a 5-bit
prefix; see <xref target="prefixed-integers"/>.</t>

<figure title="Duplicate" anchor="fig-index-with-duplication"><sourcecode type="drawing"><![CDATA[
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 0 |    Index (5+)     |
   +---+---+---+-------------------+
]]></sourcecode></figure>

<t>The existing entry is re-inserted into the dynamic table without resending
either the name or the value. This is useful to avoid adding a reference to an
older entry, which might block inserting new entries.</t>

</section>
</section>
<section anchor="decoder-instructions"><name>Decoder Instructions</name>

<t>A decoder sends decoder instructions on the decoder stream to inform the encoder
about the processing of field sections and table updates to ensure consistency
of the dynamic table.</t>

<section anchor="header-acknowledgment"><name>Section Acknowledgment</name>

<t>After processing an encoded field section whose declared Required Insert Count
is not zero, the decoder emits a Section Acknowledgment instruction.  The
instruction starts with the '1' 1-bit pattern, followed by the field
section's associated stream ID encoded as a 7-bit prefix integer; see
<xref target="prefixed-integers"/>.</t>

<t>This instruction is used as described in <xref target="known-received-count"/> and
in <xref target="state-synchronization"/>.</t>

<figure title="Section Acknowledgment" anchor="fig-header-ack"><sourcecode type="drawing"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |      Stream ID (7+)       |
+---+---------------------------+
]]></sourcecode></figure>

<t>If an encoder receives a Section Acknowledgment instruction referring to a
stream on which every encoded field section with a non-zero Required Insert
Count has already been acknowledged, this MUST be treated as a connection error
of type QPACK_DECODER_STREAM_ERROR.</t>

<t>The Section Acknowledgment instruction might increase the Known Received Count;
see <xref target="known-received-count"/>.</t>

</section>
<section anchor="stream-cancellation"><name>Stream Cancellation</name>

<t>When a stream is reset or reading is abandoned, the decoder emits a Stream
Cancellation instruction. The instruction starts with the '01' 2-bit
pattern, followed by the stream ID of the affected stream encoded as a
6-bit prefix integer.</t>

<t>This instruction is used as described in <xref target="state-synchronization"/>.</t>

<figure title="Stream Cancellation" anchor="fig-stream-cancel"><sourcecode type="drawing"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |     Stream ID (6+)    |
+---+---+-----------------------+
]]></sourcecode></figure>

</section>
<section anchor="insert-count-increment"><name>Insert Count Increment</name>

<t>The Insert Count Increment instruction starts with the '00' 2-bit pattern,
followed by the Increment encoded as a 6-bit prefix integer.  This instruction
increases the Known Received Count (<xref target="known-received-count"/>) by the value of
the Increment parameter.  The decoder should send an Increment value that
increases the Known Received Count to the total number of dynamic table
insertions and duplications processed so far.</t>

<figure title="Insert Count Increment" anchor="fig-size-sync"><sourcecode type="drawing"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |     Increment (6+)    |
+---+---+-----------------------+
]]></sourcecode></figure>

<t>An encoder that receives an Increment field equal to zero, or one that increases
the Known Received Count beyond what the encoder has sent MUST treat this as a
connection error of type QPACK_DECODER_STREAM_ERROR.</t>

</section>
</section>
<section anchor="field-line-representations"><name>Field Line Representations</name>

<t>An encoded field section consists of a prefix and a possibly empty sequence of
representations defined in this section.  Each representation corresponds to a
single field line.  These representations reference the static table or the
dynamic table in a particular state, but do not modify that state.</t>

<t>Encoded field sections are carried in frames on streams defined by the enclosing
protocol.</t>

<section anchor="header-prefix"><name>Encoded Field Section Prefix</name>

<t>Each encoded field section is prefixed with two integers.  The Required Insert
Count is encoded as an integer with an 8-bit prefix using the encoding described
in <xref target="ric"/>.  The Base is encoded as a sign bit ('S') and a Delta Base value
with a 7-bit prefix; see <xref target="base"/>.</t>

<figure title="Encoded Field Section" anchor="fig-base-index"><sourcecode type="drawing"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   Required Insert Count (8+)  |
+---+---------------------------+
| S |      Delta Base (7+)      |
+---+---------------------------+
|      Encoded Field Lines    ...
+-------------------------------+
]]></sourcecode></figure>

<section anchor="ric"><name>Required Insert Count</name>

<t>Required Insert Count identifies the state of the dynamic table needed to
process the encoded field section.  Blocking decoders use the Required Insert
Count to determine when it is safe to process the rest of the field section.</t>

<t>The encoder transforms the Required Insert Count as follows before encoding:</t>

<figure><artwork><![CDATA[
   if ReqInsertCount == 0:
      EncInsertCount = 0
   else:
      EncInsertCount = (ReqInsertCount mod (2 * MaxEntries)) + 1
]]></artwork></figure>

<t>Here <spanx style="verb">MaxEntries</spanx> is the maximum number of entries that the dynamic table can
have.  The smallest entry has empty name and value strings and has the size of
32.  Hence <spanx style="verb">MaxEntries</spanx> is calculated as</t>

<figure><artwork><![CDATA[
   MaxEntries = floor( MaxTableCapacity / 32 )
]]></artwork></figure>

<t><spanx style="verb">MaxTableCapacity</spanx> is the maximum capacity of the dynamic table as specified by
the decoder; see <xref target="maximum-dynamic-table-capacity"/>.</t>

<t>This encoding limits the length of the prefix on long-lived connections.</t>

<t>The decoder can reconstruct the Required Insert Count using an algorithm such as
the following.  If the decoder encounters a value of EncodedInsertCount that
could not have been produced by a conformant encoder, it MUST treat this as a
connection error of type QPACK_DECOMPRESSION_FAILED.</t>

<t>TotalNumberOfInserts is the total number of inserts into the decoder's dynamic
table.</t>

<figure><artwork><![CDATA[
   FullRange = 2 * MaxEntries
   if EncodedInsertCount == 0:
      ReqInsertCount = 0
   else:
      if EncodedInsertCount > FullRange:
         Error
      MaxValue = TotalNumberOfInserts + MaxEntries

      # MaxWrapped is the largest possible value of
      # ReqInsertCount that is 0 mod 2 * MaxEntries
      MaxWrapped = floor(MaxValue / FullRange) * FullRange
      ReqInsertCount = MaxWrapped + EncodedInsertCount - 1

      # If ReqInsertCount exceeds MaxValue, the Encoder's value
      # must have wrapped one fewer time
      if ReqInsertCount > MaxValue:
         if ReqInsertCount <= FullRange:
            Error
         ReqInsertCount -= FullRange

      # Value of 0 must be encoded as 0.
      if ReqInsertCount == 0:
         Error
]]></artwork></figure>

<t>For example, if the dynamic table is 100 bytes, then the Required Insert Count
will be encoded modulo 6.  If a decoder has received 10 inserts, then an encoded
value of 4 indicates that the Required Insert Count is 9 for the field section.</t>

</section>
<section anchor="base"><name>Base</name>

<t>The Base is used to resolve references in the dynamic table as described in
<xref target="relative-indexing"/>.</t>

<t>To save space, the Base is encoded relative to the Required Insert Count using a
one-bit sign ('S') and the Delta Base value.  A sign bit of 0 indicates that the
Base is greater than or equal to the value of the Required Insert Count; the
decoder adds the value of Delta Base to the Required Insert Count to determine
the value of the Base.  A sign bit of 1 indicates that the Base is less than the
Required Insert Count; the decoder subtracts the value of Delta Base from the
Required Insert Count and also subtracts one to determine the value of the Base.
That is:</t>

<figure><artwork><![CDATA[
   if S == 0:
      Base = ReqInsertCount + DeltaBase
   else:
      Base = ReqInsertCount - DeltaBase - 1
]]></artwork></figure>

<t>A single-pass encoder determines the Base before encoding a field section.  If
the encoder inserted entries in the dynamic table while encoding the field
section and is referencing them, Required Insert Count will be greater than the
Base, so the encoded difference is negative and the sign bit is set to 1.  If
the field section was not encoded using representations that reference the most
recent entry in the table and did not insert any new entries, the Base will be
greater than the Required Insert Count, so the delta will be positive and the
sign bit is set to 0.</t>

<t>An encoder that produces table updates before encoding a field section might set
Base to the value of Required Insert Count.  In such case, both the sign bit and
the Delta Base will be set to zero.</t>

<t>A field section that was encoded without references to the dynamic table can use
any value for the Base; setting Delta Base to zero is one of the most efficient
encodings.</t>

<t>For example, with a Required Insert Count of 9, a decoder receives an S bit of 1
and a Delta Base of 2.  This sets the Base to 6 and enables post-base indexing
for three entries.  In this example, a relative index of 1 refers to the 5th
entry that was added to the table; a post-base index of 1 refers to the 8th
entry.</t>

</section>
</section>
<section anchor="indexed-field-line"><name>Indexed Field Line</name>

<t>An indexed field line representation identifies an entry in the static table,
or an entry in the dynamic table with an absolute index less than the value of
the Base.</t>

<figure title="Indexed Field Line"><sourcecode type="drawing"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 | T |      Index (6+)       |
+---+---+-----------------------+
]]></sourcecode></figure>

<t>This representation starts with the '1' 1-bit pattern, followed by the 'T' bit
indicating whether the reference is into the static or dynamic table.  The 6-bit
prefix integer (<xref target="prefixed-integers"/>) that follows is used to locate the
table entry for the field line.  When T=1, the number represents the static
table index; when T=0, the number is the relative index of the entry in the
dynamic table.</t>

</section>
<section anchor="indexed-field-line-with-post-base-index"><name>Indexed Field Line With Post-Base Index</name>

<t>An indexed field line with post-base index representation identifies an entry
in the dynamic table with an absolute index greater than or equal to the value
of the Base.</t>

<figure title="Indexed Field Line with Post-Base Index"><sourcecode type="drawing"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |  Index (4+)   |
+---+---+---+---+---------------+
]]></sourcecode></figure>

<t>This representation starts with the '0001' 4-bit pattern.  This is followed
by the post-base index (<xref target="post-base"/>) of the matching field line, represented
as an integer with a 4-bit prefix; see <xref target="prefixed-integers"/>.</t>

</section>
<section anchor="literal-name-reference"><name>Literal Field Line With Name Reference</name>

<t>A literal field line with name reference representation encodes a field line
where the field name matches the field name of an entry in the static table, or
the field name of an entry in the dynamic table with an absolute index less than
the value of the Base.</t>

<figure title="Literal Field Line With Name Reference"><sourcecode type="drawing"><![CDATA[
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | N | T |Name Index (4+)|
   +---+---+---+---+---------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
]]></sourcecode></figure>

<t>This representation starts with the '01' 2-bit pattern.  The following bit,
'N', indicates whether an intermediary is permitted to add this field line to
the dynamic table on subsequent hops. When the 'N' bit is set, the encoded field
line MUST always be encoded with a literal representation. In particular, when a
peer sends a field line that it received represented as a literal field line
with the 'N' bit set, it MUST use a literal representation to forward this field
line.  This bit is intended for protecting field values that are not to be put
at risk by compressing them; see <xref target="probing-dynamic-table-state"/> for more
details.</t>

<t>The fourth ('T') bit indicates whether the reference is to the static or dynamic
table.  The 4-bit prefix integer (<xref target="prefixed-integers"/>) that follows is used to
locate the table entry for the field name.  When T=1, the number represents the
static table index; when T=0, the number is the relative index of the entry in
the dynamic table.</t>

<t>Only the field name is taken from the dynamic table entry; the field value is
encoded as an 8-bit prefix string literal; see <xref target="string-literals"/>.</t>

</section>
<section anchor="literal-field-line-with-post-base-name-reference"><name>Literal Field Line With Post-Base Name Reference</name>

<t>A literal field line with post-base name reference representation encodes a
field line where the field name matches the field name of a dynamic table entry
with an absolute index greater than or equal to the value of the Base.</t>

<figure title="Literal Field Line With Post-Base Name Reference"><sourcecode type="drawing"><![CDATA[
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 0 | 0 | N |NameIdx(3+)|
   +---+---+---+---+---+-----------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
]]></sourcecode></figure>

<t>This representation starts with the '0000' 4-bit pattern.  The fifth bit is
the 'N' bit as described in <xref target="literal-name-reference"/>.  This is followed by a
post-base index of the dynamic table entry (<xref target="post-base"/>) encoded as an
integer with a 3-bit prefix; see <xref target="prefixed-integers"/>.</t>

<t>Only the field name is taken from the dynamic table entry; the field value is
encoded as an 8-bit prefix string literal; see <xref target="string-literals"/>.</t>

</section>
<section anchor="literal-field-line-with-literal-name"><name>Literal Field Line With Literal Name</name>

<t>The literal field line with literal name representation encodes a
field name and a field value as string literals.</t>

<figure title="Literal Field Line With Literal Name"><sourcecode type="drawing"><![CDATA[
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 1 | N | H |NameLen(3+)|
   +---+---+---+---+---+-----------+
   |  Name String (Length bytes)   |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
]]></sourcecode></figure>

<t>This representation starts with the '001' 3-bit pattern.  The fourth bit is
the 'N' bit as described in <xref target="literal-name-reference"/>.  The name follows,
represented as a 4-bit prefix string literal, then the value, represented as an
8-bit prefix string literal; see <xref target="string-literals"/>.</t>

</section>
</section>
</section>
<section anchor="configuration"><name>Configuration</name>

<t>QPACK defines two settings for the HTTP/3 SETTINGS frame:</t>

<dl>
  <dt>SETTINGS_QPACK_MAX_TABLE_CAPACITY (0x01):</dt>
  <dd>
    <t>The default value is zero.  See <xref target="header-table-dynamic"/> for usage.  This is
the equivalent of the SETTINGS_HEADER_TABLE_SIZE from HTTP/2.</t>
  </dd>
  <dt>SETTINGS_QPACK_BLOCKED_STREAMS (0x07):</dt>
  <dd>
    <t>The default value is zero.  See <xref target="blocked-streams"/>.</t>
  </dd>
</dl>

</section>
<section anchor="error-handling"><name>Error Handling</name>

<t>The following error codes are defined for HTTP/3 to indicate failures of
QPACK that prevent the stream or connection from continuing:</t>

<dl>
  <dt>QPACK_DECOMPRESSION_FAILED (0x0200):</dt>
  <dd>
    <t>The decoder failed to interpret an encoded field section and is not able to
continue decoding that field section.</t>
  </dd>
  <dt>QPACK_ENCODER_STREAM_ERROR (0x0201):</dt>
  <dd>
    <t>The decoder failed to interpret an encoder instruction received on the
encoder stream.</t>
  </dd>
  <dt>QPACK_DECODER_STREAM_ERROR (0x0202):</dt>
  <dd>
    <t>The encoder failed to interpret a decoder instruction received on the
decoder stream.</t>
  </dd>
</dl>

</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t>This section describes potential areas of security concern with QPACK:</t>

<t><list style="symbols">
  <t>Use of compression as a length-based oracle for verifying guesses about
secrets that are compressed into a shared compression context.</t>
  <t>Denial of service resulting from exhausting processing or memory capacity at
a decoder.</t>
</list></t>

<section anchor="probing-dynamic-table-state"><name>Probing Dynamic Table State</name>

<t>QPACK reduces the encoded size of field sections by exploiting the redundancy
inherent in protocols like HTTP. The ultimate goal of this is to reduce the
amount of data that is required to send HTTP requests or responses.</t>

<t>The compression context used to encode header and trailer fields can be probed
by an attacker who can both define fields to be encoded and transmitted and
observe the length of those fields once they are encoded. When an attacker can
do both, they can adaptively modify requests in order to confirm guesses about
the dynamic table state. If a guess is compressed into a shorter length, the
attacker can observe the encoded length and infer that the guess was correct.</t>

<t>This is possible even over the Transport Layer Security Protocol (TLS, see
<xref target="TLS"/>) and the QUIC Transport Protocol (see <xref target="QUIC-TRANSPORT"/>),
because while TLS and QUIC provide confidentiality protection for content, they
only provide a limited amount of protection for the length of that content.</t>

<dl>
  <dt>Note:</dt>
  <dd>
    <t>Padding schemes only provide limited protection against an attacker with these
capabilities, potentially only forcing an increased number of guesses to learn
the length associated with a given guess. Padding schemes also work directly
against compression by increasing the number of bits that are transmitted.</t>
  </dd>
</dl>

<t>Attacks like CRIME (<xref target="CRIME"/>) demonstrated the existence of these general
attacker capabilities. The specific attack exploited the fact that DEFLATE
(<xref target="RFC1951"/>) removes redundancy based on prefix matching. This permitted the
attacker to confirm guesses a character at a time, reducing an exponential-time
attack into a linear-time attack.</t>

<section anchor="applicability-to-qpack-and-http"><name>Applicability to QPACK and HTTP</name>

<t>QPACK mitigates but does not completely prevent attacks modeled on CRIME
(<xref target="CRIME"/>) by forcing a guess to match an entire field line, rather than
individual characters. An attacker can only learn whether a guess is correct or
not, so is reduced to a brute force guess for the field values associated with a
given field name.</t>

<t>The viability of recovering specific field values therefore depends on the
entropy of values. As a result, values with high entropy are unlikely to be
recovered successfully. However, values with low entropy remain vulnerable.</t>

<t>Attacks of this nature are possible any time that two mutually distrustful
entities control requests or responses that are placed onto a single HTTP/3
connection. If the shared QPACK compressor permits one entity to add entries to
the dynamic table, and the other to refer to those entries while encoding
chosen field lines, then the attacker (the second entity) can learn the state
of the table by observing the length of the encoded output.</t>

<t>For example, requests or responses from mutually distrustful entities can occur
when an intermediary either:</t>

<t><list style="symbols">
  <t>sends requests from multiple clients on a single connection toward an origin
server, or</t>
  <t>takes responses from multiple origin servers and places them on a shared
connection toward a client.</t>
</list></t>

<t>Web browsers also need to assume that requests made on the same connection by
different web origins (<xref target="RFC6454"/>) are made by mutually distrustful entities.
Other scenarios involving mutually distrustful entities are also possible.</t>

</section>
<section anchor="mitigation"><name>Mitigation</name>

<t>Users of HTTP that require confidentiality for header or trailer fields can use
values with entropy sufficient to make guessing infeasible. However, this is
impractical as a general solution because it forces all users of HTTP to take
steps to mitigate attacks. It would impose new constraints on how HTTP is used.</t>

<t>Rather than impose constraints on users of HTTP, an implementation of QPACK can
instead constrain how compression is applied in order to limit the potential for
dynamic table probing.</t>

<t>An ideal solution segregates access to the dynamic table based on the entity
that is constructing the message. Field values that are added to the table are
attributed to an entity, and only the entity that created a particular value can
extract that value.</t>

<t>To improve compression performance of this option, certain entries might be
tagged as being public. For example, a web browser might make the values of the
Accept-Encoding header field available in all requests.</t>

<t>An encoder without good knowledge of the provenance of field values might
instead introduce a penalty for many field lines with the same field name and
different values.  This penalty could cause a large number of attempts to guess
a field value to result in the field not being compared to the dynamic table
entries in future messages, effectively preventing further guesses.</t>

<t>This response might be made inversely proportional to the length of the
field value. Disabling access to the dynamic table for a given field name might
occur for shorter values more quickly or with higher probability than for longer
values.</t>

<t>This mitigation is most effective between two endpoints. If messages are
re-encoded by an intermediary without knowledge of which entity constructed a
given message, the intermediary could inadvertently merge compression contexts
that the original encoder had specifically kept separate.</t>

<dl>
  <dt>Note:</dt>
  <dd>
    <t>Simply removing entries corresponding to the field from the dynamic table can
be ineffectual if the attacker has a reliable way of causing values to be
reinstalled. For example, a request to load an image in a web browser
typically includes the Cookie header field (a potentially highly valued target
for this sort of attack), and web sites can easily force an image to be
loaded, thereby refreshing the entry in the dynamic table.</t>
  </dd>
</dl>

</section>
<section anchor="never-indexed-literals"><name>Never-Indexed Literals</name>

<t>Implementations can also choose to protect sensitive fields by not compressing
them and instead encoding their value as literals.</t>

<t>Refusing to insert a field line into the dynamic table is only effective if
doing so is avoided on all hops. The never-indexed literal bit (see
<xref target="literal-name-reference"/>) can be used to signal to intermediaries that a
particular value was intentionally sent as a literal.</t>

<t>An intermediary MUST NOT re-encode a value that uses a literal representation
with the 'N' bit set with another representation that would index it. If QPACK
is used for re-encoding, a literal representation with the 'N' bit set MUST be
used.  If HPACK is used for re-encoding, the never-indexed literal
representation (see <xref section="6.2.3" sectionFormat="of" target="RFC7541"/>) MUST be used.</t>

<t>The choice to mark that a field value should never be indexed depends on several
factors. Since QPACK does not protect against guessing an entire field value,
short or low-entropy values are more readily recovered by an adversary.
Therefore, an encoder might choose not to index values with low entropy.</t>

<t>An encoder might also choose not to index values for fields that are considered
to be highly valuable or sensitive to recovery, such as the Cookie or
Authorization header fields.</t>

<t>On the contrary, an encoder might prefer indexing values for fields that have
little or no value if they were exposed. For instance, a User-Agent header field
does not commonly vary between requests and is sent to any server. In that case,
confirmation that a particular User-Agent value has been used provides little
value.</t>

<t>Note that these criteria for deciding to use a never-indexed literal
representation will evolve over time as new attacks are discovered.</t>

</section>
</section>
<section anchor="static-huffman-encoding"><name>Static Huffman Encoding</name>

<t>There is no currently known attack against a static Huffman encoding. A study
has shown that using a static Huffman encoding table created an information
leakage, however this same study concluded that an attacker could not take
advantage of this information leakage to recover any meaningful amount of
information (see <xref target="PETAL"/>).</t>

</section>
<section anchor="memory-consumption"><name>Memory Consumption</name>

<t>An attacker can try to cause an endpoint to exhaust its memory. QPACK is
designed to limit both the peak and stable amounts of memory allocated by an
endpoint.</t>

<t>QPACK uses the definition of the maximum size of the dynamic table and the
maximum number of blocking streams to limit the amount of memory the encoder can
cause the decoder to consume. In HTTP/3, these values are controlled by the
decoder through the settings parameters SETTINGS_QPACK_MAX_TABLE_CAPACITY and
SETTINGS_QPACK_BLOCKED_STREAMS, respectively (see
<xref target="maximum-dynamic-table-capacity"/> and <xref target="blocked-streams"/>). The limit on the
size of the dynamic table takes into account the size of the data stored in the
dynamic table, plus a small allowance for overhead.  The limit on the number of
blocked streams is only a proxy for the maximum amount of memory required by the
decoder.  The actual maximum amount of memory will depend on how much memory the
decoder uses to track each blocked stream.</t>

<t>A decoder can limit the amount of state memory used for the dynamic table by
setting an appropriate value for the maximum size of the dynamic table. In
HTTP/3, this is realized by setting an appropriate value for the
SETTINGS_QPACK_MAX_TABLE_CAPACITY parameter. An encoder can limit the amount of
state memory it uses by choosing a smaller dynamic table size than the decoder
allows and signaling this to the decoder (see <xref target="set-dynamic-capacity"/>).</t>

<t>A decoder can limit the amount of state memory used for blocked streams by
setting an appropriate value for the maximum number of blocked streams.  In
HTTP/3, this is realized by setting an appropriate value for the
SETTINGS_QPACK_BLOCKED_STREAMS parameter.  Streams which risk becoming blocked
consume no additional state memory on the encoder.</t>

<t>An encoder allocates memory to track all dynamic table references in
unacknowledged field sections.  An implementation can directly limit the amount
of state memory by only using as many references to the dynamic table as it
wishes to track; no signaling to the decoder is required.  However, limiting
references to the dynamic table will reduce compression effectiveness.</t>

<t>The amount of temporary memory consumed by an encoder or decoder can be limited
by processing field lines sequentially. A decoder implementation does not need
to retain a complete list of field lines while decoding a field section. An
encoder implementation does not need to retain a complete list of field lines
while encoding a field section if it is using a single-pass algorithm.  Note
that it might be necessary for an application to retain a complete list of field
lines for other reasons; even if QPACK does not force this to occur, application
constraints might make this necessary.</t>

<t>While the negotiated limit on the dynamic table size accounts for much of the
memory that can be consumed by a QPACK implementation, data that cannot be
immediately sent due to flow control is not affected by this limit.
Implementations should limit the size of unsent data, especially on the decoder
stream where flexibility to choose what to send is limited.  Possible responses
to an excess of unsent data might include limiting the ability of the peer to
open new streams, reading only from the encoder stream, or closing the
connection.</t>

</section>
<section anchor="implementation-limits"><name>Implementation Limits</name>

<t>An implementation of QPACK needs to ensure that large values for integers, long
encoding for integers, or long string literals do not create security
weaknesses.</t>

<t>An implementation has to set a limit for the values it accepts for integers, as
well as for the encoded length; see <xref target="prefixed-integers"/>. In the same way, it
has to set a limit to the length it accepts for string literals; see
<xref target="string-literals"/>.  These limits SHOULD be large enough to process the
largest individual field the HTTP implementation can be configured to accept.</t>

<t>If an implementation encounters a value larger than it is able to decode, this
MUST be treated as a stream error of type QPACK_DECOMPRESSION_FAILED if on a
request stream, or a connection error of the appropriate type if on the encoder
or decoder stream.</t>

</section>
</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>This document makes multiple registrations in the registries defined by
<xref target="HTTP3"/>. The allocations created by this document are all assigned permanent
status and list a change controller of the IETF and a contact of the HTTP
working group (ietf-http-wg@w3.org).</t>

<section anchor="settings-registration"><name>Settings Registration</name>

<t>This document specifies two settings. The entries in the following table are
registered in the "HTTP/3 Settings" registry established in <xref target="HTTP3"/>.</t>

<texttable>
      <ttcol align='left'>Setting Name</ttcol>
      <ttcol align='center'>Code</ttcol>
      <ttcol align='left'>Specification</ttcol>
      <ttcol align='left'>Default</ttcol>
      <c>QPACK_MAX_TABLE_CAPACITY</c>
      <c>0x01</c>
      <c><xref target="configuration"/></c>
      <c>0</c>
      <c>QPACK_BLOCKED_STREAMS</c>
      <c>0x07</c>
      <c><xref target="configuration"/></c>
      <c>0</c>
</texttable>

<t>For fomatting reasons, the setting names here are abbreviated by removing the
'SETTING_' prefix.</t>

</section>
<section anchor="stream-type-registration"><name>Stream Type Registration</name>

<t>This document specifies two stream types. The entries in the following table are
registered in the "HTTP/3 Stream Type" registry established in <xref target="HTTP3"/>.</t>

<texttable>
      <ttcol align='left'>Stream Type</ttcol>
      <ttcol align='center'>Code</ttcol>
      <ttcol align='left'>Specification</ttcol>
      <ttcol align='left'>Sender</ttcol>
      <c>QPACK Encoder Stream</c>
      <c>0x02</c>
      <c><xref target="enc-dec-stream-def"/></c>
      <c>Both</c>
      <c>QPACK Decoder Stream</c>
      <c>0x03</c>
      <c><xref target="enc-dec-stream-def"/></c>
      <c>Both</c>
</texttable>

</section>
<section anchor="error-code-registration"><name>Error Code Registration</name>

<t>This document specifies three error codes. The entries in the following table
are registered in the "HTTP/3 Error Code" registry established in <xref target="HTTP3"/>.</t>

<texttable>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Code</ttcol>
      <ttcol align='left'>Description</ttcol>
      <ttcol align='left'>Specification</ttcol>
      <c>QPACK_DECOMPRESSION_FAILED</c>
      <c>0x0200</c>
      <c>Decoding of a field section failed</c>
      <c><xref target="error-handling"/></c>
      <c>QPACK_ENCODER_STREAM_ERROR</c>
      <c>0x0201</c>
      <c>Error on the encoder stream</c>
      <c><xref target="error-handling"/></c>
      <c>QPACK_DECODER_STREAM_ERROR</c>
      <c>0x0202</c>
      <c>Error on the decoder stream</c>
      <c><xref target="error-handling"/></c>
</texttable>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="HTTP3" >
  <front>
    <title>Hypertext Transfer Protocol Version 3 (HTTP/3)</title>
    <author initials="M." surname="Bishop" fullname="Mike Bishop" role="editor">
      <organization>Akamai Technologies</organization>
    </author>
    <date />
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-quic-http-latest"/>
</reference>
<reference anchor="QUIC-TRANSPORT" >
  <front>
    <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
    <author initials="J." surname="Iyengar" fullname="Jana Iyengar" role="editor">
      <organization>Fastly</organization>
    </author>
    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
      <organization>Mozilla</organization>
    </author>
    <date />
  </front>
  <seriesInfo name="RFC" value="9000"/>
  <seriesInfo name="DOI" value="10.17487/RFC9000"/>
</reference>



<reference anchor='SEMANTICS'>
   <front>
      <title>HTTP Semantics</title>
      <author fullname='Roy T. Fielding'>
	 <organization>Adobe</organization>
      </author>
      <author fullname='Mark Nottingham'>
	 <organization>Fastly</organization>
      </author>
      <author fullname='Julian Reschke'>
	 <organization>greenbytes GmbH</organization>
      </author>
      <date day='12' month='September' year='2021'/>
      <abstract>
	 <t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document describes the overall architecture of HTTP, establishes common terminology, and defines aspects of the protocol that are shared by all versions. In this definition are core protocol elements, extensibility mechanisms, and the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes.

 This document updates RFC 3864 and obsoletes RFCs 2818, 7231, 7232, 7233, 7235, 7538, 7615, 7694, and portions of 7230.
	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-semantics-19'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-httpbis-semantics-19.txt' type='TXT'/>
</reference>



<reference anchor='RFC2360' target='https://www.rfc-editor.org/info/rfc2360'>
<front>
<title>Guide for Internet Standards Writers</title>
<author fullname='G. Scott' initials='G.' surname='Scott'><organization/></author>
<date month='June' year='1998'/>
<abstract><t>This document is a guide for Internet standard writers.  It defines those characteristics that make standards coherent, unambiguous, and easy to interpret.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='22'/>
<seriesInfo name='RFC' value='2360'/>
<seriesInfo name='DOI' value='10.17487/RFC2360'/>
</reference>



<reference anchor='RFC7541' target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author fullname='R. Peon' initials='R.' surname='Peon'><organization/></author>
<author fullname='H. Ruellan' initials='H.' surname='Ruellan'><organization/></author>
<date month='May' year='2015'/>
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CRIME" target="http://en.wikipedia.org/w/index.php?title=CRIME&amp;oldid=660948120">
  <front>
    <title>CRIME</title>
    <author >
      <organization>Wikipedia</organization>
    </author>
    <date year="2015" month="May"/>
  </front>
</reference>
<reference anchor="PETAL" target="http://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-106.pdf">
  <front>
    <title>PETAL: Preset Encoding Table Information Leakage</title>
    <author initials="J." surname="Tan" fullname="Jiaqi Tan">
      <organization></organization>
    </author>
    <author initials="J." surname="Nahata" fullname="Jayvardhan Nahata">
      <organization></organization>
    </author>
    <date year="2013" month="April"/>
  </front>
</reference>




<reference anchor='RFC7540' target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author fullname='M. Belshe' initials='M.' surname='Belshe'><organization/></author>
<author fullname='R. Peon' initials='R.' surname='Peon'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2015'/>
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference anchor='TLS' target='https://www.rfc-editor.org/info/rfc8446'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
<author fullname='E. Rescorla' initials='E.' surname='Rescorla'><organization/></author>
<date month='August' year='2018'/>
<abstract><t>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t><t>This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='8446'/>
<seriesInfo name='DOI' value='10.17487/RFC8446'/>
</reference>



<reference anchor='RFC1951' target='https://www.rfc-editor.org/info/rfc1951'>
<front>
<title>DEFLATE Compressed Data Format Specification version 1.3</title>
<author fullname='P. Deutsch' initials='P.' surname='Deutsch'><organization/></author>
<date month='May' year='1996'/>
<abstract><t>This specification defines a lossless compressed data format that compresses data using a combination of the LZ77 algorithm and Huffman coding, with efficiency comparable to the best currently available general-purpose compression methods.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind.</t></abstract>
</front>
<seriesInfo name='RFC' value='1951'/>
<seriesInfo name='DOI' value='10.17487/RFC1951'/>
</reference>



<reference anchor='RFC6454' target='https://www.rfc-editor.org/info/rfc6454'>
<front>
<title>The Web Origin Concept</title>
<author fullname='A. Barth' initials='A.' surname='Barth'><organization/></author>
<date month='December' year='2011'/>
<abstract><t>This document defines the concept of an &quot;origin&quot;, which is often used as the scope of authority or privilege by user agents.  Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites.  In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string.  It also defines an HTTP header field, named &quot;Origin&quot;, that indicates which origins are associated with an HTTP request.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6454'/>
<seriesInfo name='DOI' value='10.17487/RFC6454'/>
</reference>




    </references>


<section anchor="static-table"><name>Static Table</name>

<t>This table was generated by analyzing actual Internet traffic in 2018 and
including the most common header fields, after filtering out some unsupported
and non-standard values. Due to this methodology, some of the entries may be
inconsistent or appear multiple times with similar but not identical values. The
order of the entries is optimized to encode the most common header fields with
the smallest number of bytes.</t>

<texttable>
      <ttcol align='left'>Index</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Value</ttcol>
      <c>0</c>
      <c>:authority</c>
      <c>&#160;</c>
      <c>1</c>
      <c>:path</c>
      <c>/</c>
      <c>2</c>
      <c>age</c>
      <c>0</c>
      <c>3</c>
      <c>content-disposition</c>
      <c>&#160;</c>
      <c>4</c>
      <c>content-length</c>
      <c>0</c>
      <c>5</c>
      <c>cookie</c>
      <c>&#160;</c>
      <c>6</c>
      <c>date</c>
      <c>&#160;</c>
      <c>7</c>
      <c>etag</c>
      <c>&#160;</c>
      <c>8</c>
      <c>if-modified-since</c>
      <c>&#160;</c>
      <c>9</c>
      <c>if-none-match</c>
      <c>&#160;</c>
      <c>10</c>
      <c>last-modified</c>
      <c>&#160;</c>
      <c>11</c>
      <c>link</c>
      <c>&#160;</c>
      <c>12</c>
      <c>location</c>
      <c>&#160;</c>
      <c>13</c>
      <c>referer</c>
      <c>&#160;</c>
      <c>14</c>
      <c>set-cookie</c>
      <c>&#160;</c>
      <c>15</c>
      <c>:method</c>
      <c>CONNECT</c>
      <c>16</c>
      <c>:method</c>
      <c>DELETE</c>
      <c>17</c>
      <c>:method</c>
      <c>GET</c>
      <c>18</c>
      <c>:method</c>
      <c>HEAD</c>
      <c>19</c>
      <c>:method</c>
      <c>OPTIONS</c>
      <c>20</c>
      <c>:method</c>
      <c>POST</c>
      <c>21</c>
      <c>:method</c>
      <c>PUT</c>
      <c>22</c>
      <c>:scheme</c>
      <c>http</c>
      <c>23</c>
      <c>:scheme</c>
      <c>https</c>
      <c>24</c>
      <c>:status</c>
      <c>103</c>
      <c>25</c>
      <c>:status</c>
      <c>200</c>
      <c>26</c>
      <c>:status</c>
      <c>304</c>
      <c>27</c>
      <c>:status</c>
      <c>404</c>
      <c>28</c>
      <c>:status</c>
      <c>503</c>
      <c>29</c>
      <c>accept</c>
      <c>*/*</c>
      <c>30</c>
      <c>accept</c>
      <c>application/dns-message</c>
      <c>31</c>
      <c>accept-encoding</c>
      <c>gzip, deflate, br</c>
      <c>32</c>
      <c>accept-ranges</c>
      <c>bytes</c>
      <c>33</c>
      <c>access-control-allow-headers</c>
      <c>cache-control</c>
      <c>34</c>
      <c>access-control-allow-headers</c>
      <c>content-type</c>
      <c>35</c>
      <c>access-control-allow-origin</c>
      <c>*</c>
      <c>36</c>
      <c>cache-control</c>
      <c>max-age=0</c>
      <c>37</c>
      <c>cache-control</c>
      <c>max-age=2592000</c>
      <c>38</c>
      <c>cache-control</c>
      <c>max-age=604800</c>
      <c>39</c>
      <c>cache-control</c>
      <c>no-cache</c>
      <c>40</c>
      <c>cache-control</c>
      <c>no-store</c>
      <c>41</c>
      <c>cache-control</c>
      <c>public, max-age=31536000</c>
      <c>42</c>
      <c>content-encoding</c>
      <c>br</c>
      <c>43</c>
      <c>content-encoding</c>
      <c>gzip</c>
      <c>44</c>
      <c>content-type</c>
      <c>application/dns-message</c>
      <c>45</c>
      <c>content-type</c>
      <c>application/javascript</c>
      <c>46</c>
      <c>content-type</c>
      <c>application/json</c>
      <c>47</c>
      <c>content-type</c>
      <c>application/x-www-form-urlencoded</c>
      <c>48</c>
      <c>content-type</c>
      <c>image/gif</c>
      <c>49</c>
      <c>content-type</c>
      <c>image/jpeg</c>
      <c>50</c>
      <c>content-type</c>
      <c>image/png</c>
      <c>51</c>
      <c>content-type</c>
      <c>text/css</c>
      <c>52</c>
      <c>content-type</c>
      <c>text/html; charset=utf-8</c>
      <c>53</c>
      <c>content-type</c>
      <c>text/plain</c>
      <c>54</c>
      <c>content-type</c>
      <c>text/plain;charset=utf-8</c>
      <c>55</c>
      <c>range</c>
      <c>bytes=0-</c>
      <c>56</c>
      <c>strict-transport-security</c>
      <c>max-age=31536000</c>
      <c>57</c>
      <c>strict-transport-security</c>
      <c>max-age=31536000; includesubdomains</c>
      <c>58</c>
      <c>strict-transport-security</c>
      <c>max-age=31536000; includesubdomains; preload</c>
      <c>59</c>
      <c>vary</c>
      <c>accept-encoding</c>
      <c>60</c>
      <c>vary</c>
      <c>origin</c>
      <c>61</c>
      <c>x-content-type-options</c>
      <c>nosniff</c>
      <c>62</c>
      <c>x-xss-protection</c>
      <c>1; mode=block</c>
      <c>63</c>
      <c>:status</c>
      <c>100</c>
      <c>64</c>
      <c>:status</c>
      <c>204</c>
      <c>65</c>
      <c>:status</c>
      <c>206</c>
      <c>66</c>
      <c>:status</c>
      <c>302</c>
      <c>67</c>
      <c>:status</c>
      <c>400</c>
      <c>68</c>
      <c>:status</c>
      <c>403</c>
      <c>69</c>
      <c>:status</c>
      <c>421</c>
      <c>70</c>
      <c>:status</c>
      <c>425</c>
      <c>71</c>
      <c>:status</c>
      <c>500</c>
      <c>72</c>
      <c>accept-language</c>
      <c>&#160;</c>
      <c>73</c>
      <c>access-control-allow-credentials</c>
      <c>FALSE</c>
      <c>74</c>
      <c>access-control-allow-credentials</c>
      <c>TRUE</c>
      <c>75</c>
      <c>access-control-allow-headers</c>
      <c>*</c>
      <c>76</c>
      <c>access-control-allow-methods</c>
      <c>get</c>
      <c>77</c>
      <c>access-control-allow-methods</c>
      <c>get, post, options</c>
      <c>78</c>
      <c>access-control-allow-methods</c>
      <c>options</c>
      <c>79</c>
      <c>access-control-expose-headers</c>
      <c>content-length</c>
      <c>80</c>
      <c>access-control-request-headers</c>
      <c>content-type</c>
      <c>81</c>
      <c>access-control-request-method</c>
      <c>get</c>
      <c>82</c>
      <c>access-control-request-method</c>
      <c>post</c>
      <c>83</c>
      <c>alt-svc</c>
      <c>clear</c>
      <c>84</c>
      <c>authorization</c>
      <c>&#160;</c>
      <c>85</c>
      <c>content-security-policy</c>
      <c>script-src 'none'; object-src 'none'; base-uri 'none'</c>
      <c>86</c>
      <c>early-data</c>
      <c>1</c>
      <c>87</c>
      <c>expect-ct</c>
      <c>&#160;</c>
      <c>88</c>
      <c>forwarded</c>
      <c>&#160;</c>
      <c>89</c>
      <c>if-range</c>
      <c>&#160;</c>
      <c>90</c>
      <c>origin</c>
      <c>&#160;</c>
      <c>91</c>
      <c>purpose</c>
      <c>prefetch</c>
      <c>92</c>
      <c>server</c>
      <c>&#160;</c>
      <c>93</c>
      <c>timing-allow-origin</c>
      <c>*</c>
      <c>94</c>
      <c>upgrade-insecure-requests</c>
      <c>1</c>
      <c>95</c>
      <c>user-agent</c>
      <c>&#160;</c>
      <c>96</c>
      <c>x-forwarded-for</c>
      <c>&#160;</c>
      <c>97</c>
      <c>x-frame-options</c>
      <c>deny</c>
      <c>98</c>
      <c>x-frame-options</c>
      <c>sameorigin</c>
</texttable>

<t>Any line breaks that appear within field names or values are due to formatting.</t>

</section>
<section anchor="encoding-and-decoding-examples"><name>Encoding and Decoding Examples</name>

<t>The following examples represent a series of exchanges between an encoder and a
decoder.  The exchanges are designed to exercise most QPACK instructions, and
highlight potentially common patterns and their impact on dynamic table state.
The encoder sends three encoded field sections containing one field line each,
as well as two speculative inserts that are not referenced.</t>

<t>The state of the encoder's dynamic table is shown, along with its
current size.  Each entry is shown with the Absolute Index of the entry (Abs),
the current number of outstanding encoded field sections with references to that
entry (Ref), along with the name and value.  Entries above the 'acknowledged'
line have been acknowledged by the decoder.</t>

<section anchor="literal-field-line-with-name-reference"><name>Literal Field Line With Name Reference</name>

<t>The encoder sends an encoded field section containing a literal representation
of a field with a static name reference.</t>

<figure><artwork><![CDATA[
Data                | Interpretation
                             | Encoder's Dynamic Table

Stream: 0
0000                | Required Insert Count = 0, Base = 0
510b 2f69 6e64 6578 | Literal Field Line with Name Reference
2e68 746d 6c        |  Static Table, Index=1
                    |  (:path=/index.html)

                              Abs Ref Name        Value
                              ^-- acknowledged --^
                              Size=0
]]></artwork></figure>

</section>
<section anchor="dynamic-table"><name>Dynamic Table</name>

<t>The encoder sets the dynamic table capacity, inserts a header with a dynamic
name reference, then sends a potentially blocking, encoded field section
referencing this new entry.  The decoder acknowledges processing the encoded
field section, which implicitly acknowledges all dynamic table insertions up to
the Required Insert Count.</t>

<figure><artwork><![CDATA[
Stream: Encoder
3fbd01              | Set Dynamic Table Capacity=220
c00f 7777 772e 6578 | Insert With Name Reference
616d 706c 652e 636f | Static Table, Index=0
6d                  |  (:authority=www.example.com)
c10c 2f73 616d 706c | Insert With Name Reference
652f 7061 7468      |  Static Table, Index=1
                    |  (:path=/sample/path)

                              Abs Ref Name        Value
                              ^-- acknowledged --^
                               0   0  :authority  www.example.com
                               1   0  :path       /sample/path
                              Size=106

Stream: 4
0381                | Required Insert Count = 2, Base = 0
10                  | Indexed Field Line With Post-Base Index
                    |  Absolute Index = Base(0) + Index(0) = 0
                    |  (:authority=www.example.com)
11                  | Indexed Field Line With Post-Base Index
                    |  Absolute Index = Base(0) + Index(1) = 1
                    |  (:path=/sample/path)

                              Abs Ref Name        Value
                              ^-- acknowledged --^
                               0   1  :authority  www.example.com
                               1   1  :path       /sample/path
                              Size=106

Stream: Decoder
84                  | Section Acknowledgment (stream=4)

                              Abs Ref Name        Value
                               0   0  :authority  www.example.com
                               1   0  :path       /sample/path
                              ^-- acknowledged --^
                              Size=106
]]></artwork></figure>

</section>
<section anchor="speculative-insert"><name>Speculative Insert</name>

<t>The encoder inserts a header into the dynamic table with a literal name.
The decoder acknowledges receipt of the entry.  The encoder does not send
any encoded field sections.</t>

<figure><artwork><![CDATA[
Stream: Encoder
4a63 7573 746f 6d2d | Insert With Literal Name
6b65 790c 6375 7374 |  (custom-key=custom-value)
6f6d 2d76 616c 7565 |

                              Abs Ref Name        Value
                               0   0  :authority  www.example.com
                               1   0  :path       /sample/path
                              ^-- acknowledged --^
                               2   0  custom-key  custom-value
                              Size=160

Stream: Decoder
01                  | Insert Count Increment (1)

                              Abs Ref Name        Value
                               0   0  :authority  www.example.com
                               1   0  :path       /sample/path
                               2   0  custom-key  custom-value
                              ^-- acknowledged --^
                              Size=160

]]></artwork></figure>

</section>
<section anchor="duplicate-instruction-stream-cancellation"><name>Duplicate Instruction, Stream Cancellation</name>

<t>The encoder duplicates an existing entry in the dynamic table, then sends an
encoded field section referencing the dynamic table entries including the
duplicated entry.  The packet containing the encoder stream data is delayed.
Before the packet arrives, the decoder cancels the stream and notifies the
encoder that the encoded field section was not processed.</t>

<figure><artwork><![CDATA[
Stream: Encoder
02                  | Duplicate (Relative Index = 2)
                    |  Absolute Index =
                    |   Insert Count(3) - Index(2) - 1 = 0

                              Abs Ref Name        Value
                               0   0  :authority  www.example.com
                               1   0  :path       /sample/path
                               2   0  custom-key  custom-value
                              ^-- acknowledged --^
                               3   0  :authority  www.example.com
                              Size=217

Stream: 8
0500                | Required Insert Count = 4, Base = 4
80                  | Indexed Field Line, Dynamic Table
                    |  Absolute Index = Base(4) - Index(0) - 1 = 3
                    |  (:authority=www.example.com)
c1                  | Indexed Field Line, Static Table Index = 1
                    |  (:path=/)
81                  | Indexed Field Line, Dynamic Table
                    |  Absolute Index = Base(4) - Index(1) - 1 = 2
                    |  (custom-key=custom-value)

                              Abs Ref Name        Value
                               0   0  :authority  www.example.com
                               1   0  :path       /sample/path
                               2   1  custom-key  custom-value
                              ^-- acknowledged --^
                               3   1  :authority  www.example.com
                              Size=217

Stream: Decoder
48                  | Stream Cancellation (Stream=8)

                              Abs Ref Name        Value
                               0   0  :authority  www.example.com
                               1   0  :path       /sample/path
                               2   0  custom-key  custom-value
                              ^-- acknowledged --^
                               3   0  :authority  www.example.com
                              Size=217
]]></artwork></figure>

</section>
<section anchor="dynamic-table-insert-eviction"><name>Dynamic Table Insert, Eviction</name>

<t>The encoder inserts another header into the dynamic table, which evicts the
oldest entry.  The encoder does not send any encoded field sections.</t>

<figure><artwork><![CDATA[
Stream: Encoder
810d 6375 7374 6f6d | Insert With Name Reference
2d76 616c 7565 32   |  Dynamic Table, Relative Index = 1
                    |  Absolute Index =
                    |   Insert Count(4) - Index(1) - 1 = 2
                    |  (custom-key=custom-value2)

                              Abs Ref Name        Value
                               1   0  :path       /sample/path
                               2   0  custom-key  custom-value
                              ^-- acknowledged --^
                               3   0  :authority  www.example.com
                               4   0  custom-key  custom-value2
                              Size=215
]]></artwork></figure>

</section>
</section>
<section anchor="sample-one-pass-encoding-algorithm"><name>Sample One Pass Encoding Algorithm</name>

<t>Pseudo-code for single pass encoding, excluding handling of duplicates,
non-blocking mode, available encoder stream flow control and reference tracking.</t>

<figure><artwork><![CDATA[
# Helper functions:
# ====
# Encode an interger with the specified prefix and length
encodeInteger(buffer, prefix, value, prefixLength)

# Encode a dynamic table insert instruction with optional static
# or dynamic name index (but not both)
encodeInsert(buffer, staticNameIndex, dynamicNameIndex, fieldLine)

# Encode a static index reference
encodeStaticIndexReference(buffer, staticIndex)

# Encode a dynamic index reference relative to base
encodeDynamicIndexReference(buffer, dynamicIndex, base)

# Encode a literal with an optional static name index
encodeLiteral(buffer, staticNameIndex, fieldLine)

# Encode a literal with a dynamic name index relative to base
encodeDynamicLiteral(buffer, dynamicNameIndex, base, fieldLine)

# Encoding Algorithm
# ====
base = dynamicTable.getInsertCount()
requiredInsertCount = 0
for line in fieldLines:
  staticIndex = staticTable.findIndex(line)
  if staticIndex is not None:
    encodeStaticIndexReference(streamBuffer, staticIndex)
    continue

  dynamicIndex = dynamicTable.findIndex(line)
  if dynamicIndex is None:
    # No matching entry.  Either insert+index or encode literal
    staticNameIndex = staticTable.findName(line.name)
    if staticNameIndex is None:
       dynamicNameIndex = dynamicTable.findName(line.name)

    if shouldIndex(line) and dynamicTable.canIndex(line):
      encodeInsert(encoderBuffer, staticNameIndex,
                   dynamicNameIndex, line)
      dynamicIndex = dynamicTable.add(line)

  if dynamicIndex is None:
    # Could not index it, literal
    if dynamicNameIndex is not None:
      # Encode literal with dynamic name, possibly above base
      encodeDynamicLiteral(streamBuffer, dynamicNameIndex,
                           base, line)
      requiredInsertCount = max(requiredInsertCount,
                                dynamicNameIndex)
    else:
      # Encodes a literal with a static name or literal name
      encodeLiteral(streamBuffer, staticNameIndex, line)
  else:
    # Dynamic index reference
    assert(dynamicIndex is not None)
    requiredInsertCount = max(requiredInsertCount, dynamicIndex)
    # Encode dynamicIndex, possibly above base
    encodeDynamicIndexReference(streamBuffer, dynamicIndex, base)

# encode the prefix
if requiredInsertCount == 0:
  encodeInteger(prefixBuffer, 0x00, 0, 8)
  encodeInteger(prefixBuffer, 0x00, 0, 7)
else:
  wireRIC = (
    requiredInsertCount
    % (2 * getMaxEntries(maxTableCapacity))
  ) + 1;
  encodeInteger(prefixBuffer, 0x00, wireRIC, 8)
  if base >= requiredInsertCount:
    encodeInteger(prefixBuffer, 0x00,
                  base - requiredInsertCount, 7)
  else:
    encodeInteger(prefixBuffer, 0x80,
                  requiredInsertCount - base - 1, 7)

return encoderBuffer, prefixBuffer + streamBuffer
]]></artwork></figure>

</section>
<section numbered="false" anchor="acknowledgments"><name>Acknowledgments</name>

<t>The IETF QUIC Working Group received an enormous amount of support from many
people.</t>

<t>The compression design team did substantial work exploring the problem space and
influencing the initial draft.  The contributions of design team members Roberto
Peon, Martin Thomson, and Dmitri Tikhonov are gratefully acknowledged.</t>

<t>The following people also provided substantial contributions to this document:</t>

<t><list style="symbols">
  <t>Bence Bky</t>
  <t>Alessandro Ghedini</t>
  <t>Ryan Hamilton</t>
  <t>Robin Marx</t>
  <t>Patrick McManus</t>
  <t>      <t>        <contact asciiFullname="Kazuho Oku" fullname=" " />
</t>
  </t>
  <t>Lucas Pardue</t>
  <t>Biren Roy</t>
  <t>Ian Swett</t>
</list></t>

<t>This draft draws heavily on the text of <xref target="RFC7541"/>.  The indirect input of
those authors is also gratefully acknowledged.</t>

<t>Buck's contribution was supported by Google during his employment there.</t>

<t>A portion of Mike's contribution was supported by Microsoft during his
employment there.</t>

</section>


  </back>

<!-- ##markdown-source:
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
pdZrcHq4h3BnX8Wlu4/GernhE9kYPIacNqSgkMoaVQnLIKUnh5tlJQlci2Vt
UB9MqwuUaWzPH9FxGzZZnGKsve+VIB8ddykGjaFEQ0wdp5l6FmbFskQC0gSi
AAJ1hKQ+Ecm4ItJuICbntiKSaWcQBUWk9TOITLcRyH1EpC6NwKZ+yLPrNqvH
0eKLJO8rwU0DvnDessVufQ/+TfkWPRlGK2/KRmboZMv13oyNBLDmHWncEW55
R4b2ytxZ7vsfcO+5/97z3Xc0/byxs+Le+8G7Y/7q770+HLuNgDoOCaiILDOc
PDFY4/LvbpBmjwj4LZw+ghdM12bQQ7sdGdivz9OScXfWlnH/2piJn0eH59PH
QvRzPystzDZseEHsraibOvcXJGgVZt8wQQMR3Zag/9fKLVsHY27BDoLFH6w0
c392IDebiCQD0xEhd1flTVqXqNSQ7ySYmTsTXxQduEUMQjWqbPUXW1GMay35
pe+xXNUaNe03xp/HW5voMnouYc2zeJnVlqloO6Bjt52l31SMZc9lFZ8lDasl
qiRh6k/LFAZLchukZSf15nAfI2F5RsdH//chszxazvYoMP9Xbz8c/P7wtcTO
HtPkn649+W5Ldtpwco1Hb4D/ZFzJlSJThufywTeVo21TcXpeOJjTzG/W1O2n
LDAWs6MZCONU8LiYyVmKl8RW7nEaOjvxMbQVWDQrzZccftYfI0MbsT0ew1Y8
94LTEThrgbZ+eH+Cl7jYqEgDVzaCjZUZJE2fcpblWz72/uIWMret283Nb4nZ
aqcH0+pUO+8PrpYJbNsJ6LvBCYSS/QLwO/3gDeXeLUsMOzuQbsIau33iRFRb
LoV+kxqtoMAcY+qLiCUPdQjY9gmwPeaJtDak599EP7Nrxm0LyxovcXIST7D/
QzzJ2O10mZTpjNrLni2lQwHmIiJ1AqySHTuikOqgmuIZc8u+qQdNivCPcDKv
kxxnT/MuL1PSDyrsrYs6L1Ws+3weLzmT1E18LLWTjQ3Ui2lGdvNHUtqV9N12
RzrUd5UtckciP/ZUK4e1Yr9PsczSIitSp9cSV4iaoO0ZlRZKYIk01Burulww
c+WkJVzZHEn6rOBV1yJVUvAIToSQI56r443avGgsVanuOSqZJQ09bKt7zrHC
kPrK9soLbLv1LfBiI+bH7KEtEZ1LXra2/sTFnLJlF5Wpuo6BA2LT94IfQHcp
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

-->

</rfc>

